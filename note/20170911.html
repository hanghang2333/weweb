<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>20170911.html</title>
  <meta name="generator" content="Haroopad 0.13.1" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <style>div.oembedall-githubrepos{border:1px solid #DDD;border-radius:4px;list-style-type:none;margin:0 0 10px;padding:8px 10px 0;font:13.34px/1.4 helvetica,arial,freesans,clean,sans-serif;width:452px;background-color:#fff}div.oembedall-githubrepos .oembedall-body{background:-moz-linear-gradient(center top,#FAFAFA,#EFEFEF);background:-webkit-gradient(linear,left top,left bottom,from(#FAFAFA),to(#EFEFEF));border-bottom-left-radius:4px;border-bottom-right-radius:4px;border-top:1px solid #EEE;margin-left:-10px;margin-top:8px;padding:5px 10px;width:100%}div.oembedall-githubrepos h3{font-size:14px;margin:0;padding-left:18px;white-space:nowrap}div.oembedall-githubrepos p.oembedall-description{color:#444;font-size:12px;margin:0 0 3px}div.oembedall-githubrepos p.oembedall-updated-at{color:#888;font-size:11px;margin:0}div.oembedall-githubrepos ul.oembedall-repo-stats{border:none;float:right;font-size:11px;font-weight:700;padding-left:15px;position:relative;z-index:5;margin:0}div.oembedall-githubrepos ul.oembedall-repo-stats li{border:none;color:#666;display:inline-block;list-style-type:none;margin:0!important}div.oembedall-githubrepos ul.oembedall-repo-stats li a{background-color:transparent;border:none;color:#666!important;background-position:5px -2px;background-repeat:no-repeat;border-left:1px solid #DDD;display:inline-block;height:21px;line-height:21px;padding:0 5px 0 23px}div.oembedall-githubrepos ul.oembedall-repo-stats li:first-child a{border-left:medium none;margin-right:-3px}div.oembedall-githubrepos ul.oembedall-repo-stats li a:hover{background:5px -27px no-repeat #4183C4;color:#FFF!important;text-decoration:none}div.oembedall-githubrepos ul.oembedall-repo-stats li:first-child a:hover{border-bottom-left-radius:3px;border-top-left-radius:3px}ul.oembedall-repo-stats li:last-child a:hover{border-bottom-right-radius:3px;border-top-right-radius:3px}span.oembedall-closehide{background-color:#aaa;border-radius:2px;cursor:pointer;margin-right:3px}div.oembedall-container{margin-top:5px;text-align:left}.oembedall-ljuser{font-weight:700}.oembedall-ljuser img{vertical-align:bottom;border:0;padding-right:1px}.oembedall-stoqembed{border-bottom:1px dotted #999;float:left;overflow:hidden;width:730px;line-height:1;background:#FFF;color:#000;font-family:Arial,Liberation Sans,DejaVu Sans,sans-serif;font-size:80%;text-align:left;margin:0;padding:0}.oembedall-stoqembed a{color:#07C;text-decoration:none;margin:0;padding:0}.oembedall-stoqembed a:hover{text-decoration:underline}.oembedall-stoqembed a:visited{color:#4A6B82}.oembedall-stoqembed h3{font-family:Trebuchet MS,Liberation Sans,DejaVu Sans,sans-serif;font-size:130%;font-weight:700;margin:0;padding:0}.oembedall-stoqembed .oembedall-reputation-score{color:#444;font-size:120%;font-weight:700;margin-right:2px}.oembedall-stoqembed .oembedall-user-info{height:35px;width:185px}.oembedall-stoqembed .oembedall-user-info .oembedall-user-gravatar32{float:left;height:32px;width:32px}.oembedall-stoqembed .oembedall-user-info .oembedall-user-details{float:left;margin-left:5px;overflow:hidden;white-space:nowrap;width:145px}.oembedall-stoqembed .oembedall-question-hyperlink{font-weight:700}.oembedall-stoqembed .oembedall-stats{background:#EEE;margin:0 0 0 7px;padding:4px 7px 6px;width:58px}.oembedall-stoqembed .oembedall-statscontainer{float:left;margin-right:8px;width:86px}.oembedall-stoqembed .oembedall-votes{color:#555;padding:0 0 7px;text-align:center}.oembedall-stoqembed .oembedall-vote-count-post{font-size:240%;color:#808185;display:block;font-weight:700}.oembedall-stoqembed .oembedall-views{color:#999;padding-top:4px;text-align:center}.oembedall-stoqembed .oembedall-status{margin-top:-3px;padding:4px 0;text-align:center;background:#75845C;color:#FFF}.oembedall-stoqembed .oembedall-status strong{color:#FFF;display:block;font-size:140%}.oembedall-stoqembed .oembedall-summary{float:left;width:635px}.oembedall-stoqembed .oembedall-excerpt{line-height:1.2;margin:0;padding:0 0 5px}.oembedall-stoqembed .oembedall-tags{float:left;line-height:18px}.oembedall-stoqembed .oembedall-tags a:hover{text-decoration:none}.oembedall-stoqembed .oembedall-post-tag{background-color:#E0EAF1;border-bottom:1px solid #3E6D8E;border-right:1px solid #7F9FB6;color:#3E6D8E;font-size:90%;line-height:2.4;margin:2px 2px 2px 0;padding:3px 4px;text-decoration:none;white-space:nowrap}.oembedall-stoqembed .oembedall-post-tag:hover{background-color:#3E6D8E;border-bottom:1px solid #37607D;border-right:1px solid #37607D;color:#E0EAF1}.oembedall-stoqembed .oembedall-fr{float:right}.oembedall-stoqembed .oembedall-statsarrow{background-image:url(http://cdn.sstatic.net/stackoverflow/img/sprites.png?v=3);background-repeat:no-repeat;overflow:hidden;background-position:0 -435px;float:right;height:13px;margin-top:12px;width:7px}.oembedall-facebook1{border:1px solid #1A3C6C;padding:0;font:13.34px/1.4 verdana;width:500px}.oembedall-facebook2{background-color:#627add}.oembedall-facebook2 a{color:#e8e8e8;text-decoration:none}.oembedall-facebookBody{background-color:#fff;vertical-align:top;padding:5px}.oembedall-facebookBody .contents{display:inline-block;width:100%}.oembedall-facebookBody div img{float:left;margin-right:5px}div.oembedall-lanyard{-webkit-box-shadow:none;-webkit-transition-delay:0s;-webkit-transition-duration:.4000000059604645s;-webkit-transition-property:width;-webkit-transition-timing-function:cubic-bezier(0.42,0,.58,1);background-attachment:scroll;background-clip:border-box;background-color:transparent;background-image:none;background-origin:padding-box;border-width:0;box-shadow:none;color:#112644;display:block;float:left;font-family:'Trebuchet MS',Trebuchet,sans-serif;font-size:16px;height:253px;line-height:19px;margin:0;max-width:none;min-height:0;outline:#112644 0;overflow-x:visible;overflow-y:visible;padding:0;position:relative;text-align:left;vertical-align:baseline;width:804px}div.oembedall-lanyard .tagline{font-size:1.5em}div.oembedall-lanyard .wrapper{overflow:hidden;clear:both}div.oembedall-lanyard .split{float:left;display:inline}div.oembedall-lanyard .prominent-place .flag:active,div.oembedall-lanyard .prominent-place .flag:focus,div.oembedall-lanyard .prominent-place .flag:hover,div.oembedall-lanyard .prominent-place .flag:link,div.oembedall-lanyard .prominent-place .flag:visited{float:left;display:block;width:48px;height:48px;position:relative;top:-5px;margin-right:10px}div.oembedall-lanyard .place-context{font-size:.889em}div.oembedall-lanyard .prominent-place .sub-place{display:block}div.oembedall-lanyard .prominent-place{font-size:1.125em;line-height:1.1em;font-weight:400}div.oembedall-lanyard .main-date{color:#8CB4E0;font-weight:700;line-height:1.1}div.oembedall-lanyard .first{width:48.57%;margin:0 0 0 2.857%}.mermaid .label{color:#333}.node circle,.node polygon,.node rect{fill:#cde498;stroke:#13540c;stroke-width:1px}.edgePath .path{stroke:green;stroke-width:1.5px}.cluster rect{fill:#cdffb2;rx:40;stroke:#6eaa49;stroke-width:1px}.cluster text{fill:#333}.actor{stroke:#13540c;fill:#cde498}text.actor{fill:#000;stroke:none}.actor-line{stroke:grey}.messageLine0{stroke-width:1.5;stroke-dasharray:"2 2";marker-end:"url(#arrowhead)";stroke:#333}.messageLine1{stroke-width:1.5;stroke-dasharray:"2 2";stroke:#333}#arrowhead{fill:#333}#crosshead path{fill:#333!important;stroke:#333!important}.messageText{fill:#333;stroke:none}.labelBox{stroke:#326932;fill:#cde498}.labelText,.loopText{fill:#000;stroke:none}.loopLine{stroke-width:2;stroke-dasharray:"2 2";marker-end:"url(#arrowhead)";stroke:#326932}.note{stroke:#6eaa49;fill:#fff5ad}.noteText{fill:#000;stroke:none;font-family:'trebuchet ms',verdana,arial;font-size:14px}.section{stroke:none;opacity:.2}.section0,.section2{fill:#6eaa49}.section1,.section3{fill:#fff;opacity:.2}.sectionTitle0,.sectionTitle1,.sectionTitle2,.sectionTitle3{fill:#333}.sectionTitle{text-anchor:start;font-size:11px;text-height:14px}.grid .tick{stroke:lightgrey;opacity:.3;shape-rendering:crispEdges}.grid path{stroke-width:0}.today{fill:none;stroke:red;stroke-width:2px}.task{stroke-width:2}.taskText{text-anchor:middle;font-size:11px}.taskTextOutsideRight{fill:#000;text-anchor:start;font-size:11px}.taskTextOutsideLeft{fill:#000;text-anchor:end;font-size:11px}.taskText0,.taskText1,.taskText2,.taskText3{fill:#fff}.task0,.task1,.task2,.task3{fill:#487e3a;stroke:#13540c}.taskTextOutside0,.taskTextOutside1,.taskTextOutside2,.taskTextOutside3{fill:#000}.active0,.active1,.active2,.active3{fill:#cde498;stroke:#13540c}.activeText0,.activeText1,.activeText2,.activeText3{fill:#000!important}.done0,.done1,.done2,.done3{stroke:grey;fill:lightgrey;stroke-width:2}.doneText0,.doneText1,.doneText2,.doneText3{fill:#000!important}.crit0,.crit1,.crit2,.crit3{stroke:#f88;fill:red;stroke-width:2}.activeCrit0,.activeCrit1,.activeCrit2,.activeCrit3{stroke:#f88;fill:#cde498;stroke-width:2}.doneCrit0,.doneCrit1,.doneCrit2,.doneCrit3{stroke:#f88;fill:lightgrey;stroke-width:2;cursor:pointer;shape-rendering:crispEdges}.activeCritText0,.activeCritText1,.activeCritText2,.activeCritText3,.doneCritText0,.doneCritText1,.doneCritText2,.doneCritText3{fill:#000!important}.titleText{text-anchor:middle;font-size:18px;fill:#000}text{font-family:'trebuchet ms',verdana,arial;font-size:14px}html{height:100%}body{margin:0!important;padding:5px 20px 26px!important;background-color:#fff;font-family:"Lucida Grande","Segoe UI","Apple SD Gothic Neo","Malgun Gothic","Lucida Sans Unicode",Helvetica,Arial,sans-serif;font-size:.9em;overflow-x:hidden;overflow-y:auto}br,h1,h2,h3,h4,h5,h6{clear:both}hr.page{background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAECAYAAACtBE5DAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBNYWNpbnRvc2giIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OENDRjNBN0E2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OENDRjNBN0I2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo4Q0NGM0E3ODY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo4Q0NGM0E3OTY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PqqezsUAAAAfSURBVHjaYmRABcYwBiM2QSA4y4hNEKYDQxAEAAIMAHNGAzhkPOlYAAAAAElFTkSuQmCC) repeat-x;border:0;height:3px;padding:0}hr.underscore{border-top-style:dashed!important}body >:first-child{margin-top:0!important}img.plugin{box-shadow:0 1px 3px rgba(0,0,0,.1);border-radius:3px}iframe{border:0}figure{-webkit-margin-before:0;-webkit-margin-after:0;-webkit-margin-start:0;-webkit-margin-end:0}kbd{border:1px solid #aaa;-moz-border-radius:2px;-webkit-border-radius:2px;border-radius:2px;-moz-box-shadow:1px 2px 2px #ddd;-webkit-box-shadow:1px 2px 2px #ddd;box-shadow:1px 2px 2px #ddd;background-color:#f9f9f9;background-image:-moz-linear-gradient(top,#eee,#f9f9f9,#eee);background-image:-o-linear-gradient(top,#eee,#f9f9f9,#eee);background-image:-webkit-linear-gradient(top,#eee,#f9f9f9,#eee);background-image:linear-gradient(top,#eee,#f9f9f9,#eee);padding:1px 3px;font-family:inherit;font-size:.85em}.oembeded .oembed_photo{display:inline-block}img[data-echo]{margin:25px 0;width:100px;height:100px;background:url(../img/ajax.gif) center center no-repeat #fff}.spinner{display:inline-block;width:10px;height:10px;margin-bottom:-.1em;border:2px solid rgba(0,0,0,.5);border-top-color:transparent;border-radius:100%;-webkit-animation:spin 1s infinite linear;animation:spin 1s infinite linear}.spinner:after{content:'';display:block;width:0;height:0;position:absolute;top:-6px;left:0;border:4px solid transparent;border-bottom-color:rgba(0,0,0,.5);-webkit-transform:rotate(45deg);transform:rotate(45deg)}@-webkit-keyframes spin{to{-webkit-transform:rotate(360deg)}}@keyframes spin{to{transform:rotate(360deg)}}p.toc{margin:0!important}p.toc ul{padding-left:10px}p.toc>ul{padding:10px;margin:0 10px;display:inline-block;border:1px solid #ededed;border-radius:5px}p.toc li,p.toc ul{list-style-type:none}p.toc li{width:100%;padding:0;overflow:hidden}p.toc li a::after{content:"."}p.toc li a:before{content:"• "}p.toc h5{text-transform:uppercase}p.toc .title{float:left;padding-right:3px}p.toc .number{margin:0;float:right;padding-left:3px;background:#fff;display:none}input.task-list-item{margin-left:-1.62em}.markdown{font-family:"Hiragino Sans GB","Microsoft YaHei",STHeiti,SimSun,"Lucida Grande","Lucida Sans Unicode","Lucida Sans",'Segoe UI',AppleSDGothicNeo-Medium,'Malgun Gothic',Verdana,Tahoma,sans-serif;padding:20px}.markdown a{text-decoration:none;vertical-align:baseline}.markdown a:hover{text-decoration:underline}.markdown h1{font-size:2.2em;font-weight:700;margin:1.5em 0 1em}.markdown h2{font-size:1.8em;font-weight:700;margin:1.275em 0 .85em}.markdown h3{font-size:1.6em;font-weight:700;margin:1.125em 0 .75em}.markdown h4{font-size:1.4em;font-weight:700;margin:.99em 0 .66em}.markdown h5{font-size:1.2em;font-weight:700;margin:.855em 0 .57em}.markdown h6{font-size:1em;font-weight:700;margin:.75em 0 .5em}.markdown h1+p,.markdown h1:first-child,.markdown h2+p,.markdown h2:first-child,.markdown h3+p,.markdown h3:first-child,.markdown h4+p,.markdown h4:first-child,.markdown h5+p,.markdown h5:first-child,.markdown h6+p,.markdown h6:first-child{margin-top:0}.markdown hr{border:1px solid #ccc}.markdown p{margin:1em 0;word-wrap:break-word}.markdown ol{list-style-type:decimal}.markdown li{display:list-item;line-height:1.4em}.markdown blockquote{margin:1em 20px}.markdown blockquote>:first-child{margin-top:0}.markdown blockquote>:last-child{margin-bottom:0}.markdown blockquote cite:before{content:'\2014 \00A0'}.markdown .code{border-radius:3px;word-wrap:break-word}.markdown pre{border-radius:3px;word-wrap:break-word;border:1px solid #ccc;overflow:auto;padding:.5em}.markdown pre code{border:0;display:block}.markdown pre>code{font-family:Consolas,Inconsolata,Courier,monospace;font-weight:700;white-space:pre;margin:0}.markdown code{border-radius:3px;word-wrap:break-word;border:1px solid #ccc;padding:0 5px;margin:0 2px}.markdown img{max-width:100%}.markdown mark{color:#000;background-color:#fcf8e3}.markdown table{padding:0;border-collapse:collapse;border-spacing:0;margin-bottom:16px}.markdown table tr td,.markdown table tr th{border:1px solid #ccc;margin:0;padding:6px 13px}.markdown table tr th{font-weight:700}.markdown table tr th>:first-child{margin-top:0}.markdown table tr th>:last-child{margin-bottom:0}.markdown table tr td>:first-child{margin-top:0}.markdown table tr td>:last-child{margin-bottom:0}.clearness{padding:20px;color:#737373;font-size:15px;background:#fff;-webkit-font-smoothing:antialiased}.clearness a{color:#1e6ea7}.clearness a:hover{color:#268bd2}.clearness h1,.clearness h2,.clearness h3,.clearness h4,.clearness h5{color:#404040}.clearness h2{border-bottom:1px solid #ccc;line-height:1.7em}.clearness h6{color:#666}.clearness hr{border:1px solid #e6e6e6}.clearness pre>code{font-size:.9em}.clearness blockquote{padding:0 15px;font-style:italic}.clearness blockquote:before{content:"\201C";font-size:40px;margin-left:-20px;color:#aaa}.clearness table{background-color:#fff;border-collapse:separate;border-spacing:2px}.clearness table tr td,.clearness table tr th{border:0;padding:.2em 1em}.clearness table tr th{border-bottom:1px solid #bfbfbf}.clearness table tr td{border-bottom:1px solid #d9d9d9}.clearness table tr:nth-child(2n){background-color:#fff}.hljs{display:block;overflow-x:auto;padding:.5em;background:#fdf6e3;color:#657b83;-webkit-text-size-adjust:none}.diff .hljs-header,.hljs-comment,.hljs-doctype,.hljs-javadoc,.hljs-pi,.lisp .hljs-string{color:#93a1a1}.css .hljs-tag,.hljs-addition,.hljs-keyword,.hljs-request,.hljs-status,.hljs-winutils,.method,.nginx .hljs-title{color:#859900}.hljs-command,.hljs-dartdoc,.hljs-hexcolor,.hljs-link_url,.hljs-number,.hljs-phpdoc,.hljs-regexp,.hljs-rules .hljs-value,.hljs-string,.hljs-tag .hljs-value,.tex .hljs-formula{color:#2aa198}.css .hljs-function,.hljs-built_in,.hljs-chunk,.hljs-decorator,.hljs-id,.hljs-identifier,.hljs-localvars,.hljs-title,.vhdl .hljs-literal{color:#268bd2}.hljs-attribute,.hljs-class .hljs-title,.hljs-constant,.hljs-link_reference,.hljs-parent,.hljs-type,.hljs-variable,.lisp .hljs-body,.smalltalk .hljs-number{color:#b58900}.css .hljs-pseudo,.diff .hljs-change,.hljs-attr_selector,.hljs-cdata,.hljs-header,.hljs-pragma,.hljs-preprocessor,.hljs-preprocessor .hljs-keyword,.hljs-shebang,.hljs-special,.hljs-subst,.hljs-symbol,.hljs-symbol .hljs-string{color:#cb4b16}.hljs-deletion,.hljs-important{color:#dc322f}.hljs-link_label{color:#6c71c4}.tex .hljs-formula{background:#eee8d5}.MathJax_Hover_Frame{border-radius:.25em;-webkit-border-radius:.25em;-moz-border-radius:.25em;-khtml-border-radius:.25em;box-shadow:0 0 15px #83A;-webkit-box-shadow:0 0 15px #83A;-moz-box-shadow:0 0 15px #83A;-khtml-box-shadow:0 0 15px #83A;border:1px solid #A6D!important;display:inline-block;position:absolute}.MathJax_Hover_Arrow{position:absolute;width:15px;height:11px;cursor:pointer}#MathJax_About{position:fixed;left:50%;width:auto;text-align:center;border:3px outset;padding:1em 2em;background-color:#DDD;color:#000;cursor:default;font-family:message-box;font-size:120%;font-style:normal;text-indent:0;text-transform:none;line-height:normal;letter-spacing:normal;word-spacing:normal;word-wrap:normal;white-space:nowrap;float:none;z-index:201;border-radius:15px;-webkit-border-radius:15px;-moz-border-radius:15px;-khtml-border-radius:15px;box-shadow:0 10px 20px gray;-webkit-box-shadow:0 10px 20px gray;-moz-box-shadow:0 10px 20px gray;-khtml-box-shadow:0 10px 20px gray;filter:progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}.MathJax_Menu{position:absolute;background-color:#fff;color:#000;width:auto;padding:5px 0;border:1px solid #CCC;margin:0;cursor:default;font:menu;text-align:left;text-indent:0;text-transform:none;line-height:normal;letter-spacing:normal;word-spacing:normal;word-wrap:normal;white-space:nowrap;float:none;z-index:201;border-radius:5px;-webkit-border-radius:5px;-moz-border-radius:5px;-khtml-border-radius:5px;box-shadow:0 10px 20px gray;-webkit-box-shadow:0 10px 20px gray;-moz-box-shadow:0 10px 20px gray;-khtml-box-shadow:0 10px 20px gray;filter:progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}.MathJax_MenuItem{padding:1px 2em;background:0 0}.MathJax_MenuArrow{position:absolute;right:.5em;color:#666}.MathJax_MenuActive .MathJax_MenuArrow{color:#fff}.MathJax_MenuArrow.RTL{left:.5em;right:auto}.MathJax_MenuCheck{position:absolute;left:.7em}.MathJax_MenuCheck.RTL{right:.7em;left:auto}.MathJax_MenuRadioCheck{position:absolute;left:.7em}.MathJax_MenuRadioCheck.RTL{right:.7em;left:auto}.MathJax_MenuLabel{padding:1px 2em 3px 1.33em;font-style:italic}.MathJax_MenuRule{border-top:1px solid #DDD;margin:4px 3px}.MathJax_MenuDisabled{color:GrayText}.MathJax_MenuActive{background-color:#606872;color:#fff}.MathJax_Menu_Close{position:absolute;width:31px;height:31px;top:-15px;left:-15px}#MathJax_Zoom{position:absolute;background-color:#F0F0F0;overflow:auto;display:block;z-index:301;padding:.5em;border:1px solid #000;margin:0;font-weight:400;font-style:normal;text-align:left;text-indent:0;text-transform:none;line-height:normal;letter-spacing:normal;word-spacing:normal;word-wrap:normal;white-space:nowrap;float:none;box-shadow:5px 5px 15px #AAA;-webkit-box-shadow:5px 5px 15px #AAA;-moz-box-shadow:5px 5px 15px #AAA;-khtml-box-shadow:5px 5px 15px #AAA;filter:progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}#MathJax_ZoomOverlay{position:absolute;left:0;top:0;z-index:300;display:inline-block;width:100%;height:100%;border:0;padding:0;margin:0;background-color:#fff;opacity:0;filter:alpha(opacity=0)}#MathJax_ZoomFrame{position:relative;display:inline-block;height:0;width:0}#MathJax_ZoomEventTrap{position:absolute;left:0;top:0;z-index:302;display:inline-block;border:0;padding:0;margin:0;background-color:#fff;opacity:0;filter:alpha(opacity=0)}.MathJax_Preview{color:#888}#MathJax_Message{position:fixed;left:1px;bottom:2px;background-color:#E6E6E6;border:1px solid #959595;margin:0;padding:2px 8px;z-index:102;color:#000;font-size:80%;width:auto;white-space:nowrap}#MathJax_MSIE_Frame{position:absolute;top:0;left:0;width:0;z-index:101;border:0;margin:0;padding:0}.MathJax_Error{color:#C00;font-style:italic}footer{position:fixed;font-size:.8em;text-align:right;bottom:0;margin-left:-25px;height:20px;width:100%}</style>
</head>
<body class="markdown clearness">
<p class="toc" style="undefined"></p><ul>
<li><ul>
<li><ul>
<li><ul>
<li><ul>
<li><span class="title">
<a href="#119帕斯卡三角第k行" title="119帕斯卡三角第k行">119帕斯卡三角第k行</a>
</span>
<!--span class="number">
0
</span-->
</li>
<li><span class="title">
<a href="#650-2-key-keyboard" title="650 2 key keyboard">650 2 key keyboard</a>
</span>
<!--span class="number">
1
</span-->
</li>
<li><span class="title">
<a href="#98-validate-bst" title="98 Validate BST">98 Validate BST</a>
</span>
<!--span class="number">
2
</span-->
</li>
<li><span class="title">
<a href="#383-random-note" title="383 random Note">383 random Note</a>
</span>
<!--span class="number">
3
</span-->
</li>
<li><span class="title">
<a href="#506relative-ranks" title="506relative ranks">506relative ranks</a>
</span>
<!--span class="number">
4
</span-->
</li>
<li><span class="title">
<a href="#640-solve-the-equation" title="640 solve the equation">640 solve the equation</a>
</span>
<!--span class="number">
5
</span-->
</li>
<li><span class="title">
<a href="#220-contains-duplicate-iii" title="220 Contains Duplicate III">220 Contains Duplicate III</a>
</span>
<!--span class="number">
6
</span-->
</li>
<li><span class="title">
<a href="#501-find-mode-in-bst" title="501 find mode in BST">501 find mode in BST</a>
</span>
<!--span class="number">
7
</span-->
</li>
<li><span class="title">
<a href="#459-repeated-substring-pattern" title="459 repeated substring pattern">459 repeated substring pattern</a>
</span>
<!--span class="number">
8
</span-->
</li>
<li><span class="title">
<a href="#73-matrix-setzeros" title="73 matrix setzeros">73 matrix setzeros</a>
</span>
<!--span class="number">
9
</span-->
</li>
<li><span class="title">
<a href="#657-judeg-route-circle" title="657 judeg route circle">657 judeg route circle</a>
</span>
<!--span class="number">
10
</span-->
</li>
<li><span class="title">
<a href="#343-interbreak" title="343 interbreak">343 interbreak</a>
</span>
<!--span class="number">
11
</span-->
</li>
<li><span class="title">
<a href="#112-path-sum" title="112 Path Sum">112 Path Sum</a>
</span>
<!--span class="number">
12
</span-->
</li>
<li><span class="title">
<a href="#49-group-anagrams" title="49 group Anagrams">49 group Anagrams</a>
</span>
<!--span class="number">
13
</span-->
</li>
<li><span class="title">
<a href="#24-swap-nodes-in-pairs" title="24 swap nodes in pairs">24 swap nodes in pairs</a>
</span>
<!--span class="number">
14
</span-->
</li>
<li><span class="title">
<a href="#319-bulb-switcher" title="319 Bulb Switcher">319 Bulb Switcher</a>
</span>
<!--span class="number">
15
</span-->
</li>
<li><span class="title">
<a href="#439-find-right-interval" title="439 find right interval">439 find right interval</a>
</span>
<!--span class="number">
16
</span-->
</li>
<li><span class="title">
<a href="#645-set-mismatch" title="645 set mismatch">645 set mismatch</a>
</span>
<!--span class="number">
17
</span-->
</li>
<li><span class="title">
<a href="#27-remove-element" title="27 remove element">27 remove element</a>
</span>
<!--span class="number">
18
</span-->
</li>
<li><span class="title">
<a href="#152-maximum-product-subarray" title="152 maximum product subarray">152 maximum product subarray</a>
</span>
<!--span class="number">
19
</span-->
</li>
<li><span class="title">
<a href="#166-fraction-to-recurring-decimal" title="166 fraction to recurring decimal">166 fraction to recurring decimal</a>
</span>
<!--span class="number">
20
</span-->
</li>
<li><span class="title">
<a href="#566-reshape-matrix" title="566 reshape matrix">566 reshape matrix</a>
</span>
<!--span class="number">
21
</span-->
</li>
<li><span class="title">
<a href="#3-longest-substring" title="3 longest substring">3 longest substring</a>
</span>
<!--span class="number">
22
</span-->
</li>
<li><span class="title">
<a href="#492-construct-the-rectangle" title="492 construct the rectangle">492 construct the rectangle</a>
</span>
<!--span class="number">
23
</span-->
</li>
<li><span class="title">
<a href="#375-guess-number-high-or-low" title="375 guess number high or low">375 guess number high or low</a>
</span>
<!--span class="number">
24
</span-->
</li>
<li><span class="title">
<a href="#515-find-largest-value-in-each-tree-row" title="515 find largest value in each tree row">515 find largest value in each tree row</a>
</span>
<!--span class="number">
25
</span-->
</li>
<li><span class="title">
<a href="#542-01matrix" title="542 01matrix">542 01matrix</a>
</span>
<!--span class="number">
26
</span-->
</li>
<li><span class="title">
<a href="#399-evaluation-division" title="399 evaluation division">399 evaluation division</a>
</span>
<!--span class="number">
27
</span-->
</li>
<li><span class="title">
<a href="#61-rotate-list" title="61 rotate list">61 rotate list</a>
</span>
<!--span class="number">
28
</span-->
</li>
<li><span class="title">
<a href="#458-poor-pigs" title="458 poor pigs">458 poor pigs</a>
</span>
<!--span class="number">
29
</span-->
</li>
<li><span class="title">
<a href="#406-queue-reconstruction" title="406 queue reconstruction">406 queue reconstruction</a>
</span>
<!--span class="number">
30
</span-->
</li>
<li><span class="title">
<a href="#368-largest-divisible-subset" title="368 largest divisible subset">368 largest divisible subset</a>
</span>
<!--span class="number">
31
</span-->
</li>
<li><span class="title">
<a href="#207-course-schedule" title="207 course schedule">207 course schedule</a>
</span>
<!--span class="number">
32
</span-->
</li>
<li><span class="title">
<a href="#40-combination-sum2" title="40 combination sum2">40 combination sum2</a>
</span>
<!--span class="number">
33
</span-->
</li>
<li><span class="title">
<a href="#39-combination-sum" title="39 combination sum">39 combination sum</a>
</span>
<!--span class="number">
34
</span-->
</li>
<li><span class="title">
<a href="#17-letter-combinations-of-phone" title="17 letter combinations of phone">17 letter combinations of phone</a>
</span>
<!--span class="number">
35
</span-->
</li>
<li><span class="title">
<a href="#474-ones-and-zeros" title="474 ones and zeros">474 ones and zeros</a>
</span>
<!--span class="number">
36
</span-->
</li>
<li><span class="title">
<a href="#530" title="530">530</a>
</span>
<!--span class="number">
37
</span-->
</li>
<li><span class="title">
<a href="#532-k-diff-in-an-array" title="532 K-diff in an array">532 K-diff in an array</a>
</span>
<!--span class="number">
38
</span-->
</li>
<li><span class="title">
<a href="#617-merge-two-binary-trees" title="617 merge two Binary Trees">617 merge two Binary Trees</a>
</span>
<!--span class="number">
39
</span-->
</li>
<li><span class="title">
<a href="#223-rectangle-area" title="223 Rectangle area">223 Rectangle area</a>
</span>
<!--span class="number">
40
</span-->
</li>
<li><span class="title">
<a href="#654-maximumbinary-tree" title="654 Maximumbinary Tree">654 Maximumbinary Tree</a>
</span>
<!--span class="number">
41
</span-->
</li>
<li><span class="title">
<a href="#198-lowest-common-rob" title="198 lowest common rob">198 lowest common rob</a>
</span>
<!--span class="number">
42
</span-->
</li>
<li><span class="title">
<a href="#235-lowest-common-ancestor-of-bst" title="235 lowest common ancestor of BST">235 lowest common ancestor of BST</a>
</span>
<!--span class="number">
43
</span-->
</li>
<li><span class="title">
<a href="#553-optimal-division" title="553 optimal division">553 optimal division</a>
</span>
<!--span class="number">
44
</span-->
</li>
<li><span class="title">
<a href="#479-largest-palindrome-product" title="479 largest palindrome product">479 largest palindrome product</a>
</span>
<!--span class="number">
45
</span-->
</li>
<li><span class="title">
<a href="#58-length-word" title="58 length word">58 length word</a>
</span>
<!--span class="number">
46
</span-->
</li>
<li><span class="title">
<a href="#345-reverse-vowels-of-a-string" title="345 reverse vowels of a string">345 reverse vowels of a string</a>
</span>
<!--span class="number">
47
</span-->
</li>
<li><span class="title">
<a href="#1-two-sum" title="1 two sum">1 two sum</a>
</span>
<!--span class="number">
48
</span-->
</li>
<li><span class="title">
<a href="#331-verify-preorder-serialization-of-binary-tree" title="331 Verify Preorder Serialization of Binary Tree">331 Verify Preorder Serialization of Binary Tree</a>
</span>
<!--span class="number">
49
</span-->
</li>
<li><span class="title">
<a href="#461-haming-distance" title="461 haming distance">461 haming distance</a>
</span>
<!--span class="number">
50
</span-->
</li>
<li><span class="title">
<a href="#534-diameter-of-binary-tree" title="534 Diameter of Binary Tree">534 Diameter of Binary Tree</a>
</span>
<!--span class="number">
51
</span-->
</li>
<li><span class="title">
<a href="#105-construct-binarytree-for-inorder-and-preorder" title="105 construct binarytree for inorder and preorder">105 construct binarytree for inorder and preorder</a>
</span>
<!--span class="number">
52
</span-->
</li>
<li><span class="title">
<a href="#118-pasical-rectangle" title="118 pasical rectangle">118 pasical rectangle</a>
</span>
<!--span class="number">
53
</span-->
</li>
<li><span class="title">
<a href="#26-remove-duplicates-from-sorted-array" title="26 remove duplicates from sorted array">26 remove duplicates from sorted array</a>
</span>
<!--span class="number">
54
</span-->
</li>
<li><span class="title">
<a href="#6-zigzag-apttern" title="6 zigzag apttern">6 zigzag apttern</a>
</span>
<!--span class="number">
55
</span-->
</li>
<li><span class="title">
<a href="#395-longest-substring-with-at-least-k-repeating-characters" title="395 longest substring with at least k repeating characters">395 longest substring with at least k repeating characters</a>
</span>
<!--span class="number">
56
</span-->
</li>
<li><span class="title">
<a href="#575-distribute-candies" title="575 distribute candies">575 distribute candies</a>
</span>
<!--span class="number">
57
</span-->
</li>
<li><span class="title">
<a href="#312-burst-balloons" title="312 burst balloons">312 burst balloons</a>
</span>
<!--span class="number">
58
</span-->
</li>
<li><span class="title">
<a href="#102bt层次遍历" title="102BT层次遍历">102BT层次遍历</a>
</span>
<!--span class="number">
59
</span-->
</li>
<li><span class="title">
<a href="#260-single-number-3" title="260 single number 3">260 single number 3</a>
</span>
<!--span class="number">
60
</span-->
</li>
<li><span class="title">
<a href="#397-integer-replacement" title="397 integer replacement">397 integer replacement</a>
</span>
<!--span class="number">
61
</span-->
</li>
<li><span class="title">
<a href="#587凸包构建" title="587凸包构建">587凸包构建</a>
</span>
<!--span class="number">
62
</span-->
</li>
<li><span class="title">
<a href="#101-对称二叉树判断" title="101 对称二叉树判断">101 对称二叉树判断</a>
</span>
<!--span class="number">
63
</span-->
</li>
<li><span class="title">
<a href="#521-最长不一样子串" title="521 最长不一样子串">521 最长不一样子串</a>
</span>
<!--span class="number">
64
</span-->
</li>
<li><span class="title">
<a href="#171-excel-列名称" title="171 excel 列名称">171 excel 列名称</a>
</span>
<!--span class="number">
65
</span-->
</li>
<li><span class="title">
<a href="#168-excel将数字转换为字母" title="168 excel将数字转换为字母">168 excel将数字转换为字母</a>
</span>
<!--span class="number">
66
</span-->
</li>
<li><span class="title">
<a href="#669-trim-bst" title="669 trim BST">669 trim BST</a>
</span>
<!--span class="number">
67
</span-->
</li>
<li><span class="title">
<a href="#554-break-wall" title="554 break wall">554 break wall</a>
</span>
<!--span class="number">
68
</span-->
</li>
<li><span class="title">
<a href="#594-最长和谐子串" title="594 最长和谐子串">594 最长和谐子串</a>
</span>
<!--span class="number">
69
</span-->
</li>
<li><span class="title">
<a href="#60-permutation-sequence" title="60 permutation sequence">60 permutation sequence</a>
</span>
<!--span class="number">
70
</span-->
</li>
<li><span class="title">
<a href="#51-n皇后" title="51 N皇后">51 N皇后</a>
</span>
<!--span class="number">
71
</span-->
</li>
<li><span class="title">
<a href="#503-next-great-element" title="503 next great element">503 next great element</a>
</span>
<!--span class="number">
72
</span-->
</li>
<li><span class="title">
<a href="#496-next-great-element" title="496 next great element">496 next great element</a>
</span>
<!--span class="number">
73
</span-->
</li>
<li><span class="title">
<a href="#556-next-great-3" title="556 next great 3">556 next great 3</a>
</span>
<!--span class="number">
74
</span-->
</li>
<li><span class="title">
<a href="#14-最长公共前缀" title="14 最长公共前缀">14 最长公共前缀</a>
</span>
<!--span class="number">
75
</span-->
</li>
<li><span class="title">
<a href="#600-二进制不包含连1的非负整数个数" title="600 二进制不包含连1的非负整数个数">600 二进制不包含连1的非负整数个数</a>
</span>
<!--span class="number">
76
</span-->
</li>
<li><span class="title">
<a href="#139-wordbreak" title="139 wordbreak">139 wordbreak</a>
</span>
<!--span class="number">
77
</span-->
</li>
<li><span class="title">
<a href="#373-find-k-pairs-with-samllest-sum" title="373 find k pairs with samllest sum">373 find k pairs with samllest sum</a>
</span>
<!--span class="number">
78
</span-->
</li>
<li><span class="title">
<a href="#290-word-pattern" title="290 word pattern">290 word pattern</a>
</span>
<!--span class="number">
79
</span-->
</li>
<li><span class="title">
<a href="#639-decode-ways-2" title="639 decode ways 2">639 decode ways 2</a>
</span>
<!--span class="number">
80
</span-->
</li>
<li><span class="title">
<a href="#658" title="658">658</a>
</span>
<!--span class="number">
81
</span-->
<ul>
<li><span class="title">
<a href="#19-remove-kth-node-in-list" title="19 remove kth node in list">19 remove kth node in list</a>
</span>
<!--span class="number">
82
</span-->
</li>
</ul>
</li>
<li><span class="title">
<a href="#16-3sum-closest" title="16 3sum closest">16 3sum closest</a>
</span>
<!--span class="number">
83
</span-->
</li>
<li><span class="title">
<a href="#86-partion-list" title="86 partion list">86 partion list</a>
</span>
<!--span class="number">
84
</span-->
</li>
<li><span class="title">
<a href="#148-链表排序" title="148 链表排序">148 链表排序</a>
</span>
<!--span class="number">
85
</span-->
</li>
<li><span class="title">
<a href="#322-coin-changes" title="322 coin changes">322 coin changes</a>
</span>
<!--span class="number">
86
</span-->
</li>
<li><span class="title">
<a href="#673-number-of-longest-sequence" title="673 number Of longest sequence">673 number Of longest sequence</a>
</span>
<!--span class="number">
87
</span-->
</li>
<li><span class="title">
<a href="#525-二进制数组最长等量1和0" title="525 二进制数组最长等量1和0">525 二进制数组最长等量1和0</a>
</span>
<!--span class="number">
88
</span-->
</li>
<li><span class="title">
<a href="#357" title="357">357</a>
</span>
<!--span class="number">
89
</span-->
</li>
<li><span class="title">
<a href="#300-最长增长子串" title="300 最长增长子串">300 最长增长子串</a>
</span>
<!--span class="number">
90
</span-->
</li>
<li><span class="title">
<a href="#421-最大的亦或值" title="421 最大的亦或值">421 最大的亦或值</a>
</span>
<!--span class="number">
91
</span-->
</li>
<li><span class="title">
<a href="#423-等长连续增长子序列个数" title="423 等长连续增长子序列个数">423 等长连续增长子序列个数</a>
</span>
<!--span class="number">
92
</span-->
</li>
<li><span class="title">
<a href="#507-完美数" title="507 完美数">507 完美数</a>
</span>
<!--span class="number">
93
</span-->
</li>
<li><span class="title">
<a href="#372-super-pow" title="372 super pow">372 super pow</a>
</span>
<!--span class="number">
94
</span-->
</li>
<li><span class="title">
<a href="#129-从根到叶子的和" title="129 从根到叶子的和">129 从根到叶子的和</a>
</span>
<!--span class="number">
95
</span-->
</li>
<li><span class="title">
<a href="#481-magic-string" title="481 magic string">481 magic string</a>
</span>
<!--span class="number">
96
</span-->
</li>
<li><span class="title">
<a href="#477-total-hamming-distance" title="477 total hamming distance">477 total hamming distance</a>
</span>
<!--span class="number">
97
</span-->
</li>
<li><span class="title">
<a href="#337-house-rober-3" title="337 house rober 3">337 house rober 3</a>
</span>
<!--span class="number">
98
</span-->
</li>
<li><span class="title">
<a href="#213-house-rober-2" title="213 house rober 2">213 house rober 2</a>
</span>
<!--span class="number">
99
</span-->
</li>
<li><span class="title">
<a href="#93-重组ip" title="93 重组ip">93 重组ip</a>
</span>
<!--span class="number">
100
</span-->
</li>
<li><span class="title">
<a href="#124-二叉树最大和路径" title="124 二叉树最大和路径">124 二叉树最大和路径</a>
</span>
<!--span class="number">
101
</span-->
</li>
<li><span class="title">
<a href="#224-basic-calculator" title="224 basic calculator">224 basic calculator</a>
</span>
<!--span class="number">
102
</span-->
</li>
<li><span class="title">
<a href="#377-combination-sum-4" title="377 combination sum 4">377 combination sum 4</a>
</span>
<!--span class="number">
103
</span-->
</li>
<li><span class="title">
<a href="#222-统计完全二叉树节点个数" title="222 统计完全二叉树节点个数">222 统计完全二叉树节点个数</a>
</span>
<!--span class="number">
104
</span-->
</li>
<li><span class="title">
<a href="#445-add-two-numbers-2" title="445 add two numbers 2">445 add two numbers 2</a>
</span>
<!--span class="number">
105
</span-->
</li>
<li><span class="title">
<a href="#138-deepcopy一个带有随机指针的链表" title="138 deepcopy一个带有随机指针的链表">138 deepcopy一个带有随机指针的链表</a>
</span>
<!--span class="number">
106
</span-->
</li>
<li><span class="title">
<a href="#475-heaters" title="475 heaters">475 heaters</a>
</span>
<!--span class="number">
107
</span-->
</li>
<li><span class="title">
<a href="#236-最低公共父节点" title="236 最低公共父节点">236 最低公共父节点</a>
</span>
<!--span class="number">
108
</span-->
</li>
<li><span class="title">
<a href="#334-连续增长3个元素" title="334 连续增长3个元素">334 连续增长3个元素</a>
</span>
<!--span class="number">
109
</span-->
</li>
<li><span class="title">
<a href="#605-can-place-flower" title="605 can place flower">605 can place flower</a>
</span>
<!--span class="number">
110
</span-->
</li>
<li><span class="title">
<a href="#72-编辑距离" title="72 编辑距离">72 编辑距离</a>
</span>
<!--span class="number">
111
</span-->
</li>
<li><span class="title">
<a href="#54-spiral-matrix" title="54 spiral matrix">54 spiral matrix</a>
</span>
<!--span class="number">
112
</span-->
</li>
<li><span class="title">
<a href="#652-find-duplicate-subtree" title="652 find duplicate subtree">652 find duplicate subtree</a>
</span>
<!--span class="number">
113
</span-->
</li>
<li><span class="title">
<a href="#665-no-decreasing-array" title="665 no decreasing array">665 no decreasing array</a>
</span>
<!--span class="number">
114
</span-->
</li>
<li><span class="title">
<a href="#258-add-digits" title="258 add digits">258 add digits</a>
</span>
<!--span class="number">
115
</span-->
</li>
<li><span class="title">
<a href="#intersection-of-two-linked-list链表是否交叉" title="intersection of two linked list链表是否交叉">intersection of two linked list链表是否交叉</a>
</span>
<!--span class="number">
116
</span-->
</li>
<li><span class="title">
<a href="#207-课表" title="207 课表">207 课表</a>
</span>
<!--span class="number">
117
</span-->
</li>
<li><span class="title">
<a href="#11-包含最多水量的容器" title="11 包含最多水量的容器">11 包含最多水量的容器</a>
</span>
<!--span class="number">
118
</span-->
</li>
<li><span class="title">
<a href="#338-counts-bits" title="338 counts bits">338 counts bits</a>
</span>
<!--span class="number">
119
</span-->
</li>
<li><span class="title">
<a href="#240-search-a-2d-matrix" title="240 search a 2d matrix">240 search a 2d matrix</a>
</span>
<!--span class="number">
120
</span-->
</li>
<li><span class="title">
<a href="#678-vaild-parenthesis-string" title="678 vaild parenthesis string">678 vaild parenthesis string</a>
</span>
<!--span class="number">
121
</span-->
</li>
<li><span class="title">
<a href="#274-h-index" title="274 h-index">274 h-index</a>
</span>
<!--span class="number">
122
</span-->
</li>
<li><span class="title">
<a href="#145-二叉树的迭代遍历" title="145 二叉树的迭代遍历">145 二叉树的迭代遍历</a>
</span>
<!--span class="number">
123
</span-->
</li>
<li><span class="title">
<a href="#permutations" title="permutations">permutations</a>
</span>
<!--span class="number">
124
</span-->
</li>
<li><span class="title">
<a href="#239滑动窗口最大值" title="239滑动窗口最大值">239滑动窗口最大值</a>
</span>
<!--span class="number">
125
</span-->
</li>
<li><span class="title">
<a href="#155-min-stack" title="155 min stack">155 min stack</a>
</span>
<!--span class="number">
126
</span-->
</li>
<li><span class="title">
<a href="#583-最少删除操作" title="583 最少删除操作">583 最少删除操作</a>
</span>
<!--span class="number">
127
</span-->
</li>
<li><span class="title">
<a href="#丑数" title="丑数">丑数</a>
</span>
<!--span class="number">
128
</span-->
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>

</ul>
<p></p><h5 id="119帕斯卡三角第k行"><a name="119帕斯卡三角第k行" href="#119帕斯卡三角第k行"></a>119帕斯卡三角第k行</h5><p>1<br>1 1<br>1 2 1<br>1 3 3 1<br>1 4 6 4 1.<br>一开始以为可以从行数k直接推导公式,后来发现十分困难,不好总结(二次三次,,,的叠加)<br>于是想到可以从第0行开始计算.<br>第0行是[1]<br>那么第一行元素可以由第0行推导出来.这时,可以假设每一行左右都有两个[0]元素.这样就可以相加了.<br>那么由这个思路可以导出两种类似的解法,一个是上面说的两边加0,一个是左右各自加0,其实是一样的.</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>    def getRow(self, rowIndex):
        &quot;&quot;&quot;
        :type rowIndex: int
        :rtype: List[int]
        &quot;&quot;&quot;
        #Solution 1
        res = [1]
        for i in range(rowIndex):
            res = [x+y for x,y in zip([0]+res,res+[0])]
        return res
        #Solution 2
        res = [1]
        for i in range(rowIndex):
            res1 = [0]+res+[0]
            res = [res1[i]+res1[i+1] for i in range(len(res1)-1)]
        return res
</code></pre>">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getRow</span><span class="hljs-params">(self, rowIndex)</span>:</span>
        <span class="hljs-string">"""
        :type rowIndex: int
        :rtype: List[int]
        """</span>
        <span class="hljs-comment">#Solution 1</span>
        res = [<span class="hljs-number">1</span>]
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(rowIndex):
            res = [x+y <span class="hljs-keyword">for</span> x,y <span class="hljs-keyword">in</span> zip([<span class="hljs-number">0</span>]+res,res+[<span class="hljs-number">0</span>])]
        <span class="hljs-keyword">return</span> res
        <span class="hljs-comment">#Solution 2</span>
        res = [<span class="hljs-number">1</span>]
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(rowIndex):
            res1 = [<span class="hljs-number">0</span>]+res+[<span class="hljs-number">0</span>]
            res = [res1[i]+res1[i+<span class="hljs-number">1</span>] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(res1)-<span class="hljs-number">1</span>)]
        <span class="hljs-keyword">return</span> res
</code></pre><h5 id="650-2-key-keyboard"><a name="650-2-key-keyboard" href="#650-2-key-keyboard"></a>650 2 key keyboard</h5><p>给出n.假设book上初始只有一个’A’,只可以进行两个操作1复制book上文字,2粘贴.求解需要的最少步骤.<br>思路的话假设n=12,那么从后面思考,最后一步粘贴的个数k一定是n的约数,比如3,4,6这样的,那么只需要假设最后一步粘贴了3个,再求出第一次在book上制作出3个需要几步就行了.<br>这里为了避免处理1这个问题,(book)上本来就有1个,不需要进行其他操作,所以对1,2,3三种情况单独处理.并且也以1作为初始最少步数.递归即可.</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>def yueshu(n):
    res = []
    for i in range(2,n):
        if n%i == 0:
            res.append(i)
    return res
def minSteps(n):
    &quot;&quot;&quot;
    :type n: int
    :rtype: int
    &quot;&quot;&quot;
    if n == 1:
        return 0
    if n == 2:
        return 2
    if n == 3:
        return 3
    mins = n
    nowmins = n
    ylist = yueshu(n)
    for y in ylist:
        nowmins = (n-y)/y+1+minstep(y)
        mins = min(mins,nowmins)
    return mins
</code></pre>"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">yueshu</span><span class="hljs-params">(n)</span>:</span>
    res = []
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>,n):
        <span class="hljs-keyword">if</span> n%i == <span class="hljs-number">0</span>:
            res.append(i)
    <span class="hljs-keyword">return</span> res
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">minSteps</span><span class="hljs-params">(n)</span>:</span>
    <span class="hljs-string">"""
    :type n: int
    :rtype: int
    """</span>
    <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>
    <span class="hljs-keyword">if</span> n == <span class="hljs-number">2</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>
    <span class="hljs-keyword">if</span> n == <span class="hljs-number">3</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>
    mins = n
    nowmins = n
    ylist = yueshu(n)
    <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> ylist:
        nowmins = (n-y)/y+<span class="hljs-number">1</span>+minstep(y)
        mins = min(mins,nowmins)
    <span class="hljs-keyword">return</span> mins
</code></pre><h5 id="98-validate-bst"><a name="98-validate-bst" href="#98-validate-bst"></a>98 Validate BST</h5><p>题目比较简单,给定一个二叉树判断是不是二叉搜索树,刚开始想错了方向,以为递归比较左叶子和右叶子,忽略了BST的规则是要求左叶子的所有节点值也要小于该节点,而只比较该节点左右并递归则忽略了这一点.后来想到可以使用中序遍历的结果是否升序进行判断即可.</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>    def isValid(self,root,res):
        if root.left!=None:
            self.isValid(root.left,res)
        res.append(root.val)
        if root.right !=None:
            self.isValid(root.right,res)

    def isValidBST(self, root):
        &quot;&quot;&quot;
        :type root: TreeNode
        :rtype: bool
        &quot;&quot;&quot;
        res = []
        self.isValid(root,res)
        for i in range(len(res)-1):
            if res[i]&amp;gt;=res[i+1]:
                return False
        return True
</code></pre>">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isValid</span><span class="hljs-params">(self,root,res)</span>:</span>
        <span class="hljs-keyword">if</span> root.left!=<span class="hljs-keyword">None</span>:
            self.isValid(root.left,res)
        res.append(root.val)
        <span class="hljs-keyword">if</span> root.right !=<span class="hljs-keyword">None</span>:
            self.isValid(root.right,res)

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(self, root)</span>:</span>
        <span class="hljs-string">"""
        :type root: TreeNode
        :rtype: bool
        """</span>
        res = []
        self.isValid(root,res)
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(res)-<span class="hljs-number">1</span>):
            <span class="hljs-keyword">if</span> res[i]&gt;=res[i+<span class="hljs-number">1</span>]:
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">False</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">True</span>
</code></pre><h5 id="383-random-note"><a name="383-random-note" href="#383-random-note"></a>383 random Note</h5><p>给定两个字符串,判断前一个能否使用后一个里的内容组成,顺序无关,个数有关.<br>直接将后一个组成字典而后尝试组成第一个判断即可.</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>    def canConstruct(self, ransomNote, magazine):
        &quot;&quot;&quot;
        :type ransomNote: str
        :type magazine: str
        :rtype: bool
        &quot;&quot;&quot;
        dict2 = {}
        for i in magazine:
            if i in dict2:
                dict2[i] = dict2[i]+1
            else:
                dict2[i] = 1
        for i in ransomNote:
            if i not in dict2 or dict2[i]==0:
                return False
            else:
                dict2[i] = dict2[i]-1
        return True
</code></pre>">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">canConstruct</span><span class="hljs-params">(self, ransomNote, magazine)</span>:</span>
        <span class="hljs-string">"""
        :type ransomNote: str
        :type magazine: str
        :rtype: bool
        """</span>
        dict2 = {}
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> magazine:
            <span class="hljs-keyword">if</span> i <span class="hljs-keyword">in</span> dict2:
                dict2[i] = dict2[i]+<span class="hljs-number">1</span>
            <span class="hljs-keyword">else</span>:
                dict2[i] = <span class="hljs-number">1</span>
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> ransomNote:
            <span class="hljs-keyword">if</span> i <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> dict2 <span class="hljs-keyword">or</span> dict2[i]==<span class="hljs-number">0</span>:
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">False</span>
            <span class="hljs-keyword">else</span>:
                dict2[i] = dict2[i]-<span class="hljs-number">1</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">True</span>
</code></pre><h5 id="506relative-ranks"><a name="506relative-ranks" href="#506relative-ranks"></a>506relative ranks</h5><p>本题也比较简单,给定一串数字,给出他们相应的排名,前三名替换成相关的词语即可.<br>还是以一个dict存储数组的排名而后遍历数组查找排名值进行更改.</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>    def findRelativeRanks(self, nums):
        &quot;&quot;&quot;
        :type nums: List[int]
        :rtype: List[str]
        &quot;&quot;&quot;
        res = sorted(nums,reverse=True)
        dict1 = {i:inx for inx,i in enumerate(res)}
        print(nums)
        for inx,i in enumerate(nums):
            if dict1[i]&amp;gt;=3:
                nums[inx] = str(dict1[i]+1)
            elif dict1[i]==0:
                nums[inx]=&quot;Gold Medal&quot;
            elif dict1[i]==1:
                nums[inx] =&quot;Silver Medal&quot;
            else:
                nums[inx] =  &quot;Bronze Medal&quot;
        return nums
</code></pre>">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findRelativeRanks</span><span class="hljs-params">(self, nums)</span>:</span>
        <span class="hljs-string">"""
        :type nums: List[int]
        :rtype: List[str]
        """</span>
        res = sorted(nums,reverse=<span class="hljs-keyword">True</span>)
        dict1 = {i:inx <span class="hljs-keyword">for</span> inx,i <span class="hljs-keyword">in</span> enumerate(res)}
        print(nums)
        <span class="hljs-keyword">for</span> inx,i <span class="hljs-keyword">in</span> enumerate(nums):
            <span class="hljs-keyword">if</span> dict1[i]&gt;=<span class="hljs-number">3</span>:
                nums[inx] = str(dict1[i]+<span class="hljs-number">1</span>)
            <span class="hljs-keyword">elif</span> dict1[i]==<span class="hljs-number">0</span>:
                nums[inx]=<span class="hljs-string">"Gold Medal"</span>
            <span class="hljs-keyword">elif</span> dict1[i]==<span class="hljs-number">1</span>:
                nums[inx] =<span class="hljs-string">"Silver Medal"</span>
            <span class="hljs-keyword">else</span>:
                nums[inx] =  <span class="hljs-string">"Bronze Medal"</span>
        <span class="hljs-keyword">return</span> nums
</code></pre><h5 id="640-solve-the-equation"><a name="640-solve-the-equation" href="#640-solve-the-equation"></a>640 solve the equation</h5><p>求解一个方程式,简单之处在于确定了只有加减和x变量.<br>思路的话就是先将方程规范化后分别统计x的个数个常数的值最后进行计算即可.</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>class Solution(object):
    def makexp(self,str):
        xcount = 0
        numcount = 0
        start = 0
        end = 0
        i = 0
        while i &amp;lt; len(str):
            if str[i]=='+' or str[i]=='-':
                start = i
                i = i + 1
            while i&amp;lt;len(str) and (str[i]!='+' and str[i]!='-') :
                i = i + 1
            end = i
            tmp = str[start:end]
            if 'x' in tmp:
                xcount = xcount + int(tmp[0:-1])
            else:
                numcount = numcount + int(tmp)
            if end==len(str)-1:
                break
        return xcount,numcount
    def solveEquation(self, equation):
        &quot;&quot;&quot;
        :type equation: str
        :rtype: str
        &quot;&quot;&quot;
        str1 = equation[0:equation.index('=')]
        str2 = equation[equation.index('=')+1:]
        if str1[0]!='-':
            str1 = '+'+str1
        if str2[0]!='-':
            str2 = '+'+str2
        str1 = str1.replace('+x','+1x')
        str1 = str1.replace('-x','-1x')
        str2 = str2.replace('+x','+1x')
        str2 = str2.replace('-x','-1x')
        x1,n1 = self.makexp(str1)
        x2,n2 = self.makexp(str2)
        x = x1-x2
        n = n1-n2
        result = ''
        if x==0 and n!=0:
            result = 'No solution'
        elif x==0 and n == 0:
            result = 'Infinite solutions'
        else:
            result = 'x='+str(-1*n/x)
        return result
</code></pre>"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">makexp</span><span class="hljs-params">(self,str)</span>:</span>
        xcount = <span class="hljs-number">0</span>
        numcount = <span class="hljs-number">0</span>
        start = <span class="hljs-number">0</span>
        end = <span class="hljs-number">0</span>
        i = <span class="hljs-number">0</span>
        <span class="hljs-keyword">while</span> i &lt; len(str):
            <span class="hljs-keyword">if</span> str[i]==<span class="hljs-string">'+'</span> <span class="hljs-keyword">or</span> str[i]==<span class="hljs-string">'-'</span>:
                start = i
                i = i + <span class="hljs-number">1</span>
            <span class="hljs-keyword">while</span> i&lt;len(str) <span class="hljs-keyword">and</span> (str[i]!=<span class="hljs-string">'+'</span> <span class="hljs-keyword">and</span> str[i]!=<span class="hljs-string">'-'</span>) :
                i = i + <span class="hljs-number">1</span>
            end = i
            tmp = str[start:end]
            <span class="hljs-keyword">if</span> <span class="hljs-string">'x'</span> <span class="hljs-keyword">in</span> tmp:
                xcount = xcount + int(tmp[<span class="hljs-number">0</span>:-<span class="hljs-number">1</span>])
            <span class="hljs-keyword">else</span>:
                numcount = numcount + int(tmp)
            <span class="hljs-keyword">if</span> end==len(str)-<span class="hljs-number">1</span>:
                <span class="hljs-keyword">break</span>
        <span class="hljs-keyword">return</span> xcount,numcount
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">solveEquation</span><span class="hljs-params">(self, equation)</span>:</span>
        <span class="hljs-string">"""
        :type equation: str
        :rtype: str
        """</span>
        str1 = equation[<span class="hljs-number">0</span>:equation.index(<span class="hljs-string">'='</span>)]
        str2 = equation[equation.index(<span class="hljs-string">'='</span>)+<span class="hljs-number">1</span>:]
        <span class="hljs-keyword">if</span> str1[<span class="hljs-number">0</span>]!=<span class="hljs-string">'-'</span>:
            str1 = <span class="hljs-string">'+'</span>+str1
        <span class="hljs-keyword">if</span> str2[<span class="hljs-number">0</span>]!=<span class="hljs-string">'-'</span>:
            str2 = <span class="hljs-string">'+'</span>+str2
        str1 = str1.replace(<span class="hljs-string">'+x'</span>,<span class="hljs-string">'+1x'</span>)
        str1 = str1.replace(<span class="hljs-string">'-x'</span>,<span class="hljs-string">'-1x'</span>)
        str2 = str2.replace(<span class="hljs-string">'+x'</span>,<span class="hljs-string">'+1x'</span>)
        str2 = str2.replace(<span class="hljs-string">'-x'</span>,<span class="hljs-string">'-1x'</span>)
        x1,n1 = self.makexp(str1)
        x2,n2 = self.makexp(str2)
        x = x1-x2
        n = n1-n2
        result = <span class="hljs-string">''</span>
        <span class="hljs-keyword">if</span> x==<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> n!=<span class="hljs-number">0</span>:
            result = <span class="hljs-string">'No solution'</span>
        <span class="hljs-keyword">elif</span> x==<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> n == <span class="hljs-number">0</span>:
            result = <span class="hljs-string">'Infinite solutions'</span>
        <span class="hljs-keyword">else</span>:
            result = <span class="hljs-string">'x='</span>+str(-<span class="hljs-number">1</span>*n/x)
        <span class="hljs-keyword">return</span> result
</code></pre><h5 id="220-contains-duplicate-iii"><a name="220-contains-duplicate-iii" href="#220-contains-duplicate-iii"></a>220 Contains Duplicate III</h5><p>这道题目比较难.没有做出来,看了别人的思路后理解了.<br>首先最简单的思路肯定是循环遍历,这样的思路的话复杂度是kn,显然是没法通过的.<br>由此可以想到hash和桶这两种思路.<br>桶的话需要考虑一个桶的边界,这里因为要求两个数之间差值小于等于t,那么就以t+1作为桶的大小这样.然后就可以得到两个结论:分好桶之后,两个差值小于等于t的数必定是在同一个桶或者相邻两边的桶.如此即可判断.<br>这样的话需要考虑每过k个点需要将前面超过k长度的部分清空.这里其实很简单,之间每一步删除即可.这里有个小前提就是删除的话其实已经间接的表明了前面k个数里没有小于t的差值所以可以保证删除的那个正好就是向前数k个位置的.<br>这样通过遍历,每次求出当前数字的桶标号后查看左右两边是否符合,并且同时将向前数k个位置的删除.即可.</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>class Solution(object):
    def containsNearbyAlmostDuplicate(self, nums, k, t):
        &quot;&quot;&quot;
        :type nums: List[int]
        :type k: int
        :type t: int
        :rtype: bool
        &quot;&quot;&quot;
        if t&amp;lt;0:
            return False
        w = t + 1
        d ={}
        for i in range(len(nums)):
            m = nums[i]/w
            if m in d:
                return True
            if m-1 in d and abs(nums[i]-d[m-1])&amp;lt;w:
                return True
            if m+1 in d and abs(nums[i]-d[m+1])&amp;lt;w:
                return True
            d[m] = nums[i]
            if i&amp;gt;=k:
                del d[nums[i-k]/w]
        return False
</code></pre>"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">containsNearbyAlmostDuplicate</span><span class="hljs-params">(self, nums, k, t)</span>:</span>
        <span class="hljs-string">"""
        :type nums: List[int]
        :type k: int
        :type t: int
        :rtype: bool
        """</span>
        <span class="hljs-keyword">if</span> t&lt;<span class="hljs-number">0</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">False</span>
        w = t + <span class="hljs-number">1</span>
        d ={}
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(nums)):
            m = nums[i]/w
            <span class="hljs-keyword">if</span> m <span class="hljs-keyword">in</span> d:
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">True</span>
            <span class="hljs-keyword">if</span> m-<span class="hljs-number">1</span> <span class="hljs-keyword">in</span> d <span class="hljs-keyword">and</span> abs(nums[i]-d[m-<span class="hljs-number">1</span>])&lt;w:
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">True</span>
            <span class="hljs-keyword">if</span> m+<span class="hljs-number">1</span> <span class="hljs-keyword">in</span> d <span class="hljs-keyword">and</span> abs(nums[i]-d[m+<span class="hljs-number">1</span>])&lt;w:
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">True</span>
            d[m] = nums[i]
            <span class="hljs-keyword">if</span> i&gt;=k:
                <span class="hljs-keyword">del</span> d[nums[i-k]/w]
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">False</span>
</code></pre><h5 id="501-find-mode-in-bst"><a name="501-find-mode-in-bst" href="#501-find-mode-in-bst"></a>501 find mode in BST</h5><p>在BST中找出出现次数最多的.直接中序遍历后就已经是顺序的了,然后统计即可.可以遍历统计这样比较方便且节省存储.</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>class Solution(object):
    def isValid(self,root,res):
        if root.left!=None:
            self.isValid(root.left,res)
        res.append(root.val)
        if root.right !=None:
            self.isValid(root.right,res)
    def findMode(self, root):
        &quot;&quot;&quot;
        :type root: TreeNode
        :rtype: List[int]
        &quot;&quot;&quot;
        if root == None:
            return []
        res = []
        maxnow = 0
        self.isValid(root,res)
        n = len(res)
        if n == 1:
            return res
        i = 0
        rrr = []
        while i&amp;lt;n:
            time = 1
            while i+1&amp;lt;n and res[i]==res[i+1]:
                i = i + 1
                time = time + 1
            if time &amp;gt; maxnow:
                rrr = []
                rrr.append(res[i])
                maxnow = time
            elif time == maxnow:
                rrr.append(res[i])
            i = i + 1
        return rrr
</code></pre>"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isValid</span><span class="hljs-params">(self,root,res)</span>:</span>
        <span class="hljs-keyword">if</span> root.left!=<span class="hljs-keyword">None</span>:
            self.isValid(root.left,res)
        res.append(root.val)
        <span class="hljs-keyword">if</span> root.right !=<span class="hljs-keyword">None</span>:
            self.isValid(root.right,res)
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findMode</span><span class="hljs-params">(self, root)</span>:</span>
        <span class="hljs-string">"""
        :type root: TreeNode
        :rtype: List[int]
        """</span>
        <span class="hljs-keyword">if</span> root == <span class="hljs-keyword">None</span>:
            <span class="hljs-keyword">return</span> []
        res = []
        maxnow = <span class="hljs-number">0</span>
        self.isValid(root,res)
        n = len(res)
        <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span>:
            <span class="hljs-keyword">return</span> res
        i = <span class="hljs-number">0</span>
        rrr = []
        <span class="hljs-keyword">while</span> i&lt;n:
            time = <span class="hljs-number">1</span>
            <span class="hljs-keyword">while</span> i+<span class="hljs-number">1</span>&lt;n <span class="hljs-keyword">and</span> res[i]==res[i+<span class="hljs-number">1</span>]:
                i = i + <span class="hljs-number">1</span>
                time = time + <span class="hljs-number">1</span>
            <span class="hljs-keyword">if</span> time &gt; maxnow:
                rrr = []
                rrr.append(res[i])
                maxnow = time
            <span class="hljs-keyword">elif</span> time == maxnow:
                rrr.append(res[i])
            i = i + <span class="hljs-number">1</span>
        <span class="hljs-keyword">return</span> rrr
</code></pre><h5 id="459-repeated-substring-pattern"><a name="459-repeated-substring-pattern" href="#459-repeated-substring-pattern"></a>459 repeated substring pattern</h5><p>求一个字符串是否是由子串复制n次得出来的.<br>基本的思路是查看其中出现次数最少的字母出现的次数,那么循环区间长度一定是length/(次数的约数)这个范围内,而后挨个遍历即可.</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>    def repeatedSubstringPattern(self, s):
        &quot;&quot;&quot;
        :type s: str
        :rtype: bool
        &quot;&quot;&quot;
        d = {}
        for i in s:
            if i in d:
                d[i] = d[i] + 1
            else:
                d[i] = 1
        print(d)
        dk = min(d.values())
        if dk == 1:
            return False
        ys = []
        n = len(s)
        for i in range(dk,1,-1):
            if dk%i == 0 and n%i==0:
                ys.append(n/i)
        print(dk,ys)
        for i in ys:
            nowc = i
            flag = True
            for j in range(0,len(s)/nowc-1):
                if s[j*nowc:(j+1)*nowc] != s[(j+1)*nowc:(j+2)*nowc]:
                    flag = False
            if flag == True:
                return True
        return False
</code></pre>">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">repeatedSubstringPattern</span><span class="hljs-params">(self, s)</span>:</span>
        <span class="hljs-string">"""
        :type s: str
        :rtype: bool
        """</span>
        d = {}
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> s:
            <span class="hljs-keyword">if</span> i <span class="hljs-keyword">in</span> d:
                d[i] = d[i] + <span class="hljs-number">1</span>
            <span class="hljs-keyword">else</span>:
                d[i] = <span class="hljs-number">1</span>
        print(d)
        dk = min(d.values())
        <span class="hljs-keyword">if</span> dk == <span class="hljs-number">1</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">False</span>
        ys = []
        n = len(s)
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(dk,<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>):
            <span class="hljs-keyword">if</span> dk%i == <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> n%i==<span class="hljs-number">0</span>:
                ys.append(n/i)
        print(dk,ys)
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> ys:
            nowc = i
            flag = <span class="hljs-keyword">True</span>
            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>,len(s)/nowc-<span class="hljs-number">1</span>):
                <span class="hljs-keyword">if</span> s[j*nowc:(j+<span class="hljs-number">1</span>)*nowc] != s[(j+<span class="hljs-number">1</span>)*nowc:(j+<span class="hljs-number">2</span>)*nowc]:
                    flag = <span class="hljs-keyword">False</span>
            <span class="hljs-keyword">if</span> flag == <span class="hljs-keyword">True</span>:
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">True</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">False</span>
</code></pre><h5 id="73-matrix-setzeros"><a name="73-matrix-setzeros" href="#73-matrix-setzeros"></a>73 matrix setzeros</h5><p>要求将元素0的行列全部置换为0,要求原地修改.那么有一点需要注意的就是如果在统计的时候就修改了,后导致后面的统计出错.</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>class Solution(object):
    def setZeroes(self, matrix):
        &quot;&quot;&quot;
        :type matrix: List[List[int]]
        :rtype: void Do not return anything, modify matrix in-place instead.
        &quot;&quot;&quot;
        lx = len(matrix)
        ly = len(matrix[0])
        d = set()
        for row in range(len(matrix)):
            for col in range(len(matrix[0])):
                if matrix[row][col] == 0:
                    d.add((row,col))
        for (i,j) in d:
            nowx = i
            nowy = j
            print(i,j)
            matrix[i]=[0 for k in range(ly)]
            for k in range(lx):
                matrix[k][j]=0
</code></pre>"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">setZeroes</span><span class="hljs-params">(self, matrix)</span>:</span>
        <span class="hljs-string">"""
        :type matrix: List[List[int]]
        :rtype: void Do not return anything, modify matrix in-place instead.
        """</span>
        lx = len(matrix)
        ly = len(matrix[<span class="hljs-number">0</span>])
        d = set()
        <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> range(len(matrix)):
            <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> range(len(matrix[<span class="hljs-number">0</span>])):
                <span class="hljs-keyword">if</span> matrix[row][col] == <span class="hljs-number">0</span>:
                    d.add((row,col))
        <span class="hljs-keyword">for</span> (i,j) <span class="hljs-keyword">in</span> d:
            nowx = i
            nowy = j
            print(i,j)
            matrix[i]=[<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> range(ly)]
            <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> range(lx):
                matrix[k][j]=<span class="hljs-number">0</span>
</code></pre><h5 id="657-judeg-route-circle"><a name="657-judeg-route-circle" href="#657-judeg-route-circle"></a>657 judeg route circle</h5><p>起点0,0,经过几次移动后判断是否回到起点,直接模拟运动判断即可.</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>class Solution(object):
    def judgeCircle(self, moves):
        &quot;&quot;&quot;
        :type moves: str
        :rtype: bool
        &quot;&quot;&quot;
        &quot;LRUD&quot;
        origin = [0,0]
        for i in moves:
            if i=='L':
                origin[1] = origin[1]-1
            if i=='R':
                origin[1]=origin[1]+1
            if i=='U':
                origin[0]=origin[0]-1
            if i=='D':
                origin[0]=origin[0]+1
        if origin[0] == 0 and origin[1]==0:
            return True
        return False
</code></pre>"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">judgeCircle</span><span class="hljs-params">(self, moves)</span>:</span>
        <span class="hljs-string">"""
        :type moves: str
        :rtype: bool
        """</span>
        <span class="hljs-string">"LRUD"</span>
        origin = [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> moves:
            <span class="hljs-keyword">if</span> i==<span class="hljs-string">'L'</span>:
                origin[<span class="hljs-number">1</span>] = origin[<span class="hljs-number">1</span>]-<span class="hljs-number">1</span>
            <span class="hljs-keyword">if</span> i==<span class="hljs-string">'R'</span>:
                origin[<span class="hljs-number">1</span>]=origin[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>
            <span class="hljs-keyword">if</span> i==<span class="hljs-string">'U'</span>:
                origin[<span class="hljs-number">0</span>]=origin[<span class="hljs-number">0</span>]-<span class="hljs-number">1</span>
            <span class="hljs-keyword">if</span> i==<span class="hljs-string">'D'</span>:
                origin[<span class="hljs-number">0</span>]=origin[<span class="hljs-number">0</span>]+<span class="hljs-number">1</span>
        <span class="hljs-keyword">if</span> origin[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> origin[<span class="hljs-number">1</span>]==<span class="hljs-number">0</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">True</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">False</span>
</code></pre><h5 id="343-interbreak"><a name="343-interbreak" href="#343-interbreak"></a>343 interbreak</h5><p>给定一个整数,将其分解为几个正数之和使得这几个整数乘积最大.<br>直接递归即可,加上一个memory形成dp即可.需要注意这里需要比较的不仅仅是递归项inter(n-i)还有(n-i)本身的值.因为其有可能是大于inter(n-i)的.</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>class Solution(object):
    def inter(self,n,d):
        if n == 1:
            return 1
        maxvalue = 1
        tag = 0
        for i in range(1,n):
            tmp2 = 0
            if n-i in d:
                tmp2 = i*d[n-i]
            else:
                tmp2 = i*self.inter(n-i,d)
            if tmp2&amp;gt;maxvalue:
                tag = i
                maxvalue = tmp2
            if i*(n-i)&amp;gt;maxvalue:
                maxvalue = i*(n-i)
        d[n] = maxvalue
        return maxvalue
    def integerBreak(self, n):
        &quot;&quot;&quot;
        :type n: int
        :rtype: int
        &quot;&quot;&quot;
        d = {}
        res = self.inter(n,d)
        return res
</code></pre>"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">inter</span><span class="hljs-params">(self,n,d)</span>:</span>
        <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>
        maxvalue = <span class="hljs-number">1</span>
        tag = <span class="hljs-number">0</span>
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>,n):
            tmp2 = <span class="hljs-number">0</span>
            <span class="hljs-keyword">if</span> n-i <span class="hljs-keyword">in</span> d:
                tmp2 = i*d[n-i]
            <span class="hljs-keyword">else</span>:
                tmp2 = i*self.inter(n-i,d)
            <span class="hljs-keyword">if</span> tmp2&gt;maxvalue:
                tag = i
                maxvalue = tmp2
            <span class="hljs-keyword">if</span> i*(n-i)&gt;maxvalue:
                maxvalue = i*(n-i)
        d[n] = maxvalue
        <span class="hljs-keyword">return</span> maxvalue
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">integerBreak</span><span class="hljs-params">(self, n)</span>:</span>
        <span class="hljs-string">"""
        :type n: int
        :rtype: int
        """</span>
        d = {}
        res = self.inter(n,d)
        <span class="hljs-keyword">return</span> res
</code></pre><h5 id="112-path-sum"><a name="112-path-sum" href="#112-path-sum"></a>112 Path Sum</h5><p>给定二叉树,求解在所有从根到节点这样的路径上是否有和等于给定sum的.<br>采取了一个比较粗略的方式就是遍历整颗树直接将父节点的值增加到子节点上,最后统计叶子节点的值,没有再找出所有路径这样的.</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;># Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution(object):
    def dd(self,root,res):
        if root.left!=None:
            root.left.val = root.left.val+root.val
            self.dd(root.left,res)
        if root.right!=None:
            root.right.val = root.right.val+root.val
            self.dd(root.right,res)
        if root.left == None and root.right==None:
            res.append(root.val)


    def hasPathSum(self, root, sum):
        &quot;&quot;&quot;
        :type root: TreeNode
        :type sum: int
        :rtype: bool
        &quot;&quot;&quot;
        if root==None:
            return False
        res = []
        self.dd(root,res)
        if sum in res:
            return True
        return False
</code></pre>"><span class="hljs-comment"># Definition for a binary tree node.</span>
<span class="hljs-comment"># class TreeNode(object):</span>
<span class="hljs-comment">#     def __init__(self, x):</span>
<span class="hljs-comment">#         self.val = x</span>
<span class="hljs-comment">#         self.left = None</span>
<span class="hljs-comment">#         self.right = None</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dd</span><span class="hljs-params">(self,root,res)</span>:</span>
        <span class="hljs-keyword">if</span> root.left!=<span class="hljs-keyword">None</span>:
            root.left.val = root.left.val+root.val
            self.dd(root.left,res)
        <span class="hljs-keyword">if</span> root.right!=<span class="hljs-keyword">None</span>:
            root.right.val = root.right.val+root.val
            self.dd(root.right,res)
        <span class="hljs-keyword">if</span> root.left == <span class="hljs-keyword">None</span> <span class="hljs-keyword">and</span> root.right==<span class="hljs-keyword">None</span>:
            res.append(root.val)


    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hasPathSum</span><span class="hljs-params">(self, root, sum)</span>:</span>
        <span class="hljs-string">"""
        :type root: TreeNode
        :type sum: int
        :rtype: bool
        """</span>
        <span class="hljs-keyword">if</span> root==<span class="hljs-keyword">None</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">False</span>
        res = []
        self.dd(root,res)
        <span class="hljs-keyword">if</span> sum <span class="hljs-keyword">in</span> res:
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">True</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">False</span>
</code></pre><h5 id="49-group-anagrams"><a name="49-group-anagrams" href="#49-group-anagrams"></a>49 group Anagrams</h5><p>该题目给定一个字符串数组,需要将其中字符串内容一致的放在一起这样.<br>主要的内容是记录下一共几种字符串并且记录下相同字符串位置.这里采用了python里的tuple和dict分别记录了字符串种类和位置,然后重组即可.</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>class Solution(object):
    def groupAnagrams(self, strs):
        &quot;&quot;&quot;
        :type strs: List[str]
        :rtype: List[List[str]]
        [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;],
        [[&quot;ate&quot;, &quot;eat&quot;,&quot;tea&quot;],
        [&quot;nat&quot;,&quot;tan&quot;],
        [&quot;bat&quot;]
        &quot;&quot;&quot;
        res = []
        d = {}
        for i in range(len(strs)):
            tmp = tuple(sorted(strs[i]))
            if tmp in d:
                d[tmp] = d[tmp]+[i]
            else:
                d[tmp] = [i]
        for key in d:
            tmp = []
            for value in d[key]:
                tmp.append(strs[value])
            res.append(tmp)
        return res
</code></pre>"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">groupAnagrams</span><span class="hljs-params">(self, strs)</span>:</span>
        <span class="hljs-string">"""
        :type strs: List[str]
        :rtype: List[List[str]]
        ["eat", "tea", "tan", "ate", "nat", "bat"],
        [["ate", "eat","tea"],
        ["nat","tan"],
        ["bat"]
        """</span>
        res = []
        d = {}
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(strs)):
            tmp = tuple(sorted(strs[i]))
            <span class="hljs-keyword">if</span> tmp <span class="hljs-keyword">in</span> d:
                d[tmp] = d[tmp]+[i]
            <span class="hljs-keyword">else</span>:
                d[tmp] = [i]
        <span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> d:
            tmp = []
            <span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> d[key]:
                tmp.append(strs[value])
            res.append(tmp)
        <span class="hljs-keyword">return</span> res
</code></pre><h5 id="24-swap-nodes-in-pairs"><a name="24-swap-nodes-in-pairs" href="#24-swap-nodes-in-pairs"></a>24 swap nodes in pairs</h5><p>交换list里的每两个元素,要求是交换节点而不是节点的值.<br>思路的话交换两个节点的操作,需要一个prehead以避免头节点无指针,需要判断遍历到的节点是否为None以及下一个是否为None这样.最后还要记得保存下头节点(或者是交换后的头节点)</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;># Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution(object):
    def swapPairs(self, head):
        &quot;&quot;&quot;
        :type head: ListNode
        :rtype: ListNode
        &quot;&quot;&quot;
        if head==None:
            return head
        prehead = ListNode(0)
        prehead.next = head
        first = True
        bak = head
        while head!=None and head.next !=None:
            nextone = head.next
            head.next = nextone.next
            nextone.next = head
            prehead.next = nextone
            prehead = head
            head = head.next
            if first:
                bak = nextone
                first = False
        return bak
</code></pre>"><span class="hljs-comment"># Definition for singly-linked list.</span>
<span class="hljs-comment"># class ListNode(object):</span>
<span class="hljs-comment">#     def __init__(self, x):</span>
<span class="hljs-comment">#         self.val = x</span>
<span class="hljs-comment">#         self.next = None</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">swapPairs</span><span class="hljs-params">(self, head)</span>:</span>
        <span class="hljs-string">"""
        :type head: ListNode
        :rtype: ListNode
        """</span>
        <span class="hljs-keyword">if</span> head==<span class="hljs-keyword">None</span>:
            <span class="hljs-keyword">return</span> head
        prehead = ListNode(<span class="hljs-number">0</span>)
        prehead.next = head
        first = <span class="hljs-keyword">True</span>
        bak = head
        <span class="hljs-keyword">while</span> head!=<span class="hljs-keyword">None</span> <span class="hljs-keyword">and</span> head.next !=<span class="hljs-keyword">None</span>:
            nextone = head.next
            head.next = nextone.next
            nextone.next = head
            prehead.next = nextone
            prehead = head
            head = head.next
            <span class="hljs-keyword">if</span> first:
                bak = nextone
                first = <span class="hljs-keyword">False</span>
        <span class="hljs-keyword">return</span> bak
</code></pre><h5 id="319-bulb-switcher"><a name="319-bulb-switcher" href="#319-bulb-switcher"></a>319 Bulb Switcher</h5><p>给定一个n,表示有n个灯,然后第一次挨个按一下,第二次每两个按一下,第三次每三个按一下(不是圈,每次都从第一个开始数数,数到第n个后按下这样),最初是off,问最后有多少on.<br>很容易想到按下奇数次的是on,那么哪些数会被按下奇数次呢,首先可以确定的是每个位置被按下的次数是该数字的约数的个数,那么就容易知道被按下奇数次的那些是完全平方数.因为非完全平方数约数都是一一对应必定是偶数个的.</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>class Solution(object):
    def bulbSwitch(self, n):
        &quot;&quot;&quot;
        :type n: int
        :rtype: int
        &quot;&quot;&quot;
        count = 0
        inx = 1
        while inx*inx&amp;lt;=n:
            count = count + 1
            inx = inx + 1
        return count
</code></pre>"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bulbSwitch</span><span class="hljs-params">(self, n)</span>:</span>
        <span class="hljs-string">"""
        :type n: int
        :rtype: int
        """</span>
        count = <span class="hljs-number">0</span>
        inx = <span class="hljs-number">1</span>
        <span class="hljs-keyword">while</span> inx*inx&lt;=n:
            count = count + <span class="hljs-number">1</span>
            inx = inx + <span class="hljs-number">1</span>
        <span class="hljs-keyword">return</span> count
</code></pre><h5 id="439-find-right-interval"><a name="439-find-right-interval" href="#439-find-right-interval"></a>439 find right interval</h5><p>给定一个数组,里面元素表明了一条线的起点和终点位置.需要求的是每条线的终点后离的最近的那条线(以起点计),如果没有的话则为-1.<br>首先需要将所有线的起点排序,因为题意说了起点不重复且起点一定小于终点,所以很多特殊情况不需要考虑.<br>而后对每个线的终点,在排好序的起点里二分查找其对应的位置,并返回,然后根据这个点的值去对应出该起点在原数组里对应的坐标即可.</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;># Definition for an interval.
# class Interval(object):
#     def __init__(self, s=0, e=0):
#         self.start = s
#         self.end = e

class Solution(object):
    def bs(self,nums,key):
        left = 0
        right = len(nums)
        while left+1&amp;lt;right:
            medium = (left+right)/2
            if nums[medium]&amp;lt;key:
                left = medium
            elif nums[medium]&amp;gt;key:
                right = medium
            else:
                return medium
        if right&amp;gt;=len(nums):
            right = -1
        return right
    def findRightInterval(self, intervals):
        &quot;&quot;&quot;
        :type intervals: List[Interval]
        :rtype: List[int]
        &quot;&quot;&quot;
        rrr = []
        start = [i.start for i in intervals]
        sortstart = sorted(start)
        sdict = {i:inx for inx,i in enumerate(start)}
        for i in intervals:
            end = i.end
            inx = self.bs(sortstart,end)
            if inx == -1:
                rrr.append(-1)
            else:
                rn = sortstart[inx]
                ri = sdict[rn]
                rrr.append(ri)
        return rrr
</code></pre>"><span class="hljs-comment"># Definition for an interval.</span>
<span class="hljs-comment"># class Interval(object):</span>
<span class="hljs-comment">#     def __init__(self, s=0, e=0):</span>
<span class="hljs-comment">#         self.start = s</span>
<span class="hljs-comment">#         self.end = e</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bs</span><span class="hljs-params">(self,nums,key)</span>:</span>
        left = <span class="hljs-number">0</span>
        right = len(nums)
        <span class="hljs-keyword">while</span> left+<span class="hljs-number">1</span>&lt;right:
            medium = (left+right)/<span class="hljs-number">2</span>
            <span class="hljs-keyword">if</span> nums[medium]&lt;key:
                left = medium
            <span class="hljs-keyword">elif</span> nums[medium]&gt;key:
                right = medium
            <span class="hljs-keyword">else</span>:
                <span class="hljs-keyword">return</span> medium
        <span class="hljs-keyword">if</span> right&gt;=len(nums):
            right = -<span class="hljs-number">1</span>
        <span class="hljs-keyword">return</span> right
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findRightInterval</span><span class="hljs-params">(self, intervals)</span>:</span>
        <span class="hljs-string">"""
        :type intervals: List[Interval]
        :rtype: List[int]
        """</span>
        rrr = []
        start = [i.start <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> intervals]
        sortstart = sorted(start)
        sdict = {i:inx <span class="hljs-keyword">for</span> inx,i <span class="hljs-keyword">in</span> enumerate(start)}
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> intervals:
            end = i.end
            inx = self.bs(sortstart,end)
            <span class="hljs-keyword">if</span> inx == -<span class="hljs-number">1</span>:
                rrr.append(-<span class="hljs-number">1</span>)
            <span class="hljs-keyword">else</span>:
                rn = sortstart[inx]
                ri = sdict[rn]
                rrr.append(ri)
        <span class="hljs-keyword">return</span> rrr
</code></pre><h5 id="645-set-mismatch"><a name="645-set-mismatch" href="#645-set-mismatch"></a>645 set mismatch</h5><p>一个从1到n的数组里有一个元素变成了另一个元素,导致了一个数字出现两次一个没出现,求出这两个.<br>遍历两次即可.</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>class Solution(object):
    def findErrorNums(self, nums):
        &quot;&quot;&quot;
        :type nums: List[int]
        :rtype: List[int]
        &quot;&quot;&quot;
        d = {}
        double = 0
        remove = 0
        for i in nums:
            if i in d:
                double = i
                #break
            else:
                d[i] = 1
        for i in range(1,len(nums)+1):
            if i not in d:
                remove = i
                break
        return [double,remove]
</code></pre>"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findErrorNums</span><span class="hljs-params">(self, nums)</span>:</span>
        <span class="hljs-string">"""
        :type nums: List[int]
        :rtype: List[int]
        """</span>
        d = {}
        double = <span class="hljs-number">0</span>
        remove = <span class="hljs-number">0</span>
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> nums:
            <span class="hljs-keyword">if</span> i <span class="hljs-keyword">in</span> d:
                double = i
                <span class="hljs-comment">#break</span>
            <span class="hljs-keyword">else</span>:
                d[i] = <span class="hljs-number">1</span>
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>,len(nums)+<span class="hljs-number">1</span>):
            <span class="hljs-keyword">if</span> i <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> d:
                remove = i
                <span class="hljs-keyword">break</span>
        <span class="hljs-keyword">return</span> [double,remove]
</code></pre><h5 id="27-remove-element"><a name="27-remove-element" href="#27-remove-element"></a>27 remove element</h5><p>原地删除数组特定元素,位置可以混乱.<br>直接将后面的元素复制过来即可.记录下删除了多少个就行.</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>class Solution(object):
    def removeElement(self, nums, val):
        &quot;&quot;&quot;
        :type nums: List[int]
        :type val: int
        :rtype: int
        &quot;&quot;&quot;
        end = len(nums)-1
        rem = 0
        i = 0
        while i&amp;lt;len(nums)-rem:
            if nums[i]==val:
                nums[i]=nums[end]
                end = end -1
                rem = rem + 1
            else:
                i = i + 1
        return len(nums)-rem
</code></pre>"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">removeElement</span><span class="hljs-params">(self, nums, val)</span>:</span>
        <span class="hljs-string">"""
        :type nums: List[int]
        :type val: int
        :rtype: int
        """</span>
        end = len(nums)-<span class="hljs-number">1</span>
        rem = <span class="hljs-number">0</span>
        i = <span class="hljs-number">0</span>
        <span class="hljs-keyword">while</span> i&lt;len(nums)-rem:
            <span class="hljs-keyword">if</span> nums[i]==val:
                nums[i]=nums[end]
                end = end -<span class="hljs-number">1</span>
                rem = rem + <span class="hljs-number">1</span>
            <span class="hljs-keyword">else</span>:
                i = i + <span class="hljs-number">1</span>
        <span class="hljs-keyword">return</span> len(nums)-rem
</code></pre><h5 id="152-maximum-product-subarray"><a name="152-maximum-product-subarray" href="#152-maximum-product-subarray"></a>152 maximum product subarray</h5><p>给定一个数组(含负数),求乘积最大的子序列的乘积值是多少.<br>显然是使用dp,但是和和最大的子序列还不一样,这里因为有负数,所以存在某些情况下最大的值乘以负数后变成最小的值而后被丢掉的情况.所以我们在dp时需要保持两个,一个是以当前结尾的最大乘积,一个是最小乘积,当碰到负数时,最小乘积和最大乘积就需要调换以使得乘完后仍然满足最大最小.然后以一个res记录最大值即可.<br>这里主要是要考虑到负数并且想到使用增加记录一个当前乘积最小值的情况去包含进这种情况.主要是负数乘积仍然有可能在后面碰到一个负数使得其值变的很大.而如果只碰到一个负数,那么保留最小值也可以准确的表达出在这个地方的最大值.</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>class Solution(object):
    def maxProduct(self, nums):
        &quot;&quot;&quot;
        :type nums: List[int]
        :rtype: int
        &quot;&quot;&quot;
        n = len(nums)
        imax = nums[0]
        imin = nums[0]
        r = nums[0]
        for i in range(1,n):
            if nums[i]&amp;lt;0:
                imax,imin = imin,imax
            imax = max(imax*nums[i],nums[i])
            imin = min(imin*nums[i],nums[i])
            r = max(r,imax)
        return r
</code></pre>"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maxProduct</span><span class="hljs-params">(self, nums)</span>:</span>
        <span class="hljs-string">"""
        :type nums: List[int]
        :rtype: int
        """</span>
        n = len(nums)
        imax = nums[<span class="hljs-number">0</span>]
        imin = nums[<span class="hljs-number">0</span>]
        r = nums[<span class="hljs-number">0</span>]
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>,n):
            <span class="hljs-keyword">if</span> nums[i]&lt;<span class="hljs-number">0</span>:
                imax,imin = imin,imax
            imax = max(imax*nums[i],nums[i])
            imin = min(imin*nums[i],nums[i])
            r = max(r,imax)
        <span class="hljs-keyword">return</span> r
</code></pre><h5 id="166-fraction-to-recurring-decimal"><a name="166-fraction-to-recurring-decimal" href="#166-fraction-to-recurring-decimal"></a>166 fraction to recurring decimal</h5><p>给定除数和被除数,求出商,要求循环小数的话循环节需要括号括起来<br>这个的难点在于寻找正确的循环节.总体的思路是存储下每个余数对应的小数结果的序号,从而再计算到相同的余数时能够正确的取出循环节.其中细节很多,需要多调试总结不同的思路和情况.</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>class Solution(object):
    def fractionToDecimal(self, numerator, denominator):
        &quot;&quot;&quot;
        :type numerator: int
        :type denominator: int
        :rtype: str
        &quot;&quot;&quot;
        zs = ''
        f = False
        if numerator*denominator&amp;lt;0:
            f = True
        if numerator&amp;lt;0:
            numerator = -1*numerator
        if denominator&amp;lt;0:
            denominator = -1*denominator
        if numerator&amp;lt;denominator:
            zs = '0'
        else:
            zs = str(numerator/denominator)
        if f == True:
            zs = '-'+zs
        ys = numerator - (numerator/denominator*denominator)
        #print(ys)
        if ys == 0:
            return zs
        zs = zs+'.'
        xslist = ''
        hisys = {}
        #hisys[ys] = 0
        while ys!=0:
            if ys in hisys:
                #print(hisys,ys)
                #xunhuan start,end
                start = hisys[ys]
                end = len(xslist)
                xslist = xslist[0:start]+'('+xslist[start:]+')'
                break
            hisys[ys] = len(xslist)
            #print(hisys)
            ys = ys*10
            hisys[ys] = len(xslist)+1
            while ys&amp;lt;denominator:
                ys = ys * 10
                #xslist=xslist+'0'
                if ys in hisys:
                #print(hisys,ys)
                #xunhuan start,end
                    start = hisys[ys]
                    end = len(xslist)
                    xslist = xslist[0:start]+'('+xslist[start:]+')'
                    break
                xslist=xslist+'0'
                hisys[ys] = len(xslist)+1
            jg = ys/denominator
            #xslist=xslist+str(jg)
            #print(xslist)
            ys = ys-jg*denominator
            xslist=xslist+str(jg)
            if ys == 0:
                break
        return zs+xslist
</code></pre>"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fractionToDecimal</span><span class="hljs-params">(self, numerator, denominator)</span>:</span>
        <span class="hljs-string">"""
        :type numerator: int
        :type denominator: int
        :rtype: str
        """</span>
        zs = <span class="hljs-string">''</span>
        f = <span class="hljs-keyword">False</span>
        <span class="hljs-keyword">if</span> numerator*denominator&lt;<span class="hljs-number">0</span>:
            f = <span class="hljs-keyword">True</span>
        <span class="hljs-keyword">if</span> numerator&lt;<span class="hljs-number">0</span>:
            numerator = -<span class="hljs-number">1</span>*numerator
        <span class="hljs-keyword">if</span> denominator&lt;<span class="hljs-number">0</span>:
            denominator = -<span class="hljs-number">1</span>*denominator
        <span class="hljs-keyword">if</span> numerator&lt;denominator:
            zs = <span class="hljs-string">'0'</span>
        <span class="hljs-keyword">else</span>:
            zs = str(numerator/denominator)
        <span class="hljs-keyword">if</span> f == <span class="hljs-keyword">True</span>:
            zs = <span class="hljs-string">'-'</span>+zs
        ys = numerator - (numerator/denominator*denominator)
        <span class="hljs-comment">#print(ys)</span>
        <span class="hljs-keyword">if</span> ys == <span class="hljs-number">0</span>:
            <span class="hljs-keyword">return</span> zs
        zs = zs+<span class="hljs-string">'.'</span>
        xslist = <span class="hljs-string">''</span>
        hisys = {}
        <span class="hljs-comment">#hisys[ys] = 0</span>
        <span class="hljs-keyword">while</span> ys!=<span class="hljs-number">0</span>:
            <span class="hljs-keyword">if</span> ys <span class="hljs-keyword">in</span> hisys:
                <span class="hljs-comment">#print(hisys,ys)</span>
                <span class="hljs-comment">#xunhuan start,end</span>
                start = hisys[ys]
                end = len(xslist)
                xslist = xslist[<span class="hljs-number">0</span>:start]+<span class="hljs-string">'('</span>+xslist[start:]+<span class="hljs-string">')'</span>
                <span class="hljs-keyword">break</span>
            hisys[ys] = len(xslist)
            <span class="hljs-comment">#print(hisys)</span>
            ys = ys*<span class="hljs-number">10</span>
            hisys[ys] = len(xslist)+<span class="hljs-number">1</span>
            <span class="hljs-keyword">while</span> ys&lt;denominator:
                ys = ys * <span class="hljs-number">10</span>
                <span class="hljs-comment">#xslist=xslist+'0'</span>
                <span class="hljs-keyword">if</span> ys <span class="hljs-keyword">in</span> hisys:
                <span class="hljs-comment">#print(hisys,ys)</span>
                <span class="hljs-comment">#xunhuan start,end</span>
                    start = hisys[ys]
                    end = len(xslist)
                    xslist = xslist[<span class="hljs-number">0</span>:start]+<span class="hljs-string">'('</span>+xslist[start:]+<span class="hljs-string">')'</span>
                    <span class="hljs-keyword">break</span>
                xslist=xslist+<span class="hljs-string">'0'</span>
                hisys[ys] = len(xslist)+<span class="hljs-number">1</span>
            jg = ys/denominator
            <span class="hljs-comment">#xslist=xslist+str(jg)</span>
            <span class="hljs-comment">#print(xslist)</span>
            ys = ys-jg*denominator
            xslist=xslist+str(jg)
            <span class="hljs-keyword">if</span> ys == <span class="hljs-number">0</span>:
                <span class="hljs-keyword">break</span>
        <span class="hljs-keyword">return</span> zs+xslist
</code></pre><h5 id="566-reshape-matrix"><a name="566-reshape-matrix" href="#566-reshape-matrix"></a>566 reshape matrix</h5><p>直接将原matrix保存而后挨个放入即可。</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>class Solution(object):
    def matrixReshape(self, nums, r, c):
        &quot;&quot;&quot;
        :type nums: List[List[int]]
        :type r: int
        :type c: int
        :rtype: List[List[int]]
        &quot;&quot;&quot;
        ir = len(nums)
        ic = len(nums[0])
        if ic*ir != r*c:
            return nums
        count = r*c
        def makei(i):
            start = i*c
            res = []
            for j in range(c):
                res.append(nums[start/ic][start%ic])
                start = start + 1
            return res
        res = [makei(i) for i in range(r)]
        return res
</code></pre>"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">matrixReshape</span><span class="hljs-params">(self, nums, r, c)</span>:</span>
        <span class="hljs-string">"""
        :type nums: List[List[int]]
        :type r: int
        :type c: int
        :rtype: List[List[int]]
        """</span>
        ir = len(nums)
        ic = len(nums[<span class="hljs-number">0</span>])
        <span class="hljs-keyword">if</span> ic*ir != r*c:
            <span class="hljs-keyword">return</span> nums
        count = r*c
        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">makei</span><span class="hljs-params">(i)</span>:</span>
            start = i*c
            res = []
            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(c):
                res.append(nums[start/ic][start%ic])
                start = start + <span class="hljs-number">1</span>
            <span class="hljs-keyword">return</span> res
        res = [makei(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(r)]
        <span class="hljs-keyword">return</span> res
</code></pre><h5 id="3-longest-substring"><a name="3-longest-substring" href="#3-longest-substring"></a>3 longest substring</h5><p>给出一个字符串，求里面包含最多不重复元素的最长子串长度。<br>思路肯定是使用dp，dp[i]的意思也毫无疑问是指的以该元素结尾的最长子串是多长。不过这里需要注意的是重复元素的存在和判断。解决方案里使用了一种使用dict存储的方法，遍历的过程中存储下碰到的最新的元素对应的坐标，在遍历过程中如果碰到前面已经见过的，则需要更新下start位置重新计算长度这样的。</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>class Solution(object):
    def lengthOfLongestSubstring(self, s):
        &quot;&quot;&quot;
        :type s: str
        :rtype: int
        &quot;&quot;&quot;
        used = {}
        start = 0
        maxlength = 0
        for i in range(len(s)):
            if s[i] in used and used[s[i]]&amp;gt;=start:
                start = used[s[i]]+1
            else:
                maxlength = max(maxlength,i-start+1)
            used[s[i]] = i
        return maxlength
</code></pre>"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(self, s)</span>:</span>
        <span class="hljs-string">"""
        :type s: str
        :rtype: int
        """</span>
        used = {}
        start = <span class="hljs-number">0</span>
        maxlength = <span class="hljs-number">0</span>
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(s)):
            <span class="hljs-keyword">if</span> s[i] <span class="hljs-keyword">in</span> used <span class="hljs-keyword">and</span> used[s[i]]&gt;=start:
                start = used[s[i]]+<span class="hljs-number">1</span>
            <span class="hljs-keyword">else</span>:
                maxlength = max(maxlength,i-start+<span class="hljs-number">1</span>)
            used[s[i]] = i
        <span class="hljs-keyword">return</span> maxlength
</code></pre><h5 id="492-construct-the-rectangle"><a name="492-construct-the-rectangle" href="#492-construct-the-rectangle"></a>492 construct the rectangle</h5><p>给定面积求竟可能方的长宽。</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>class Solution(object):
    def constructRectangle(self, area):
        &quot;&quot;&quot;
        :type area: int
        :rtype: List[int]
        &quot;&quot;&quot;
        import math
        start = int(math.sqrt(area))
        for i in range(start,0,-1):
            if area%i==0:
                return [max(area/i,i),min(area/i,i)]
</code></pre>"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">constructRectangle</span><span class="hljs-params">(self, area)</span>:</span>
        <span class="hljs-string">"""
        :type area: int
        :rtype: List[int]
        """</span>
        <span class="hljs-keyword">import</span> math
        start = int(math.sqrt(area))
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(start,<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>):
            <span class="hljs-keyword">if</span> area%i==<span class="hljs-number">0</span>:
                <span class="hljs-keyword">return</span> [max(area/i,i),min(area/i,i)]
</code></pre><h5 id="375-guess-number-high-or-low"><a name="375-guess-number-high-or-low" href="#375-guess-number-high-or-low"></a>375 guess number high or low</h5><p>这道题说给定一个n，它随意猜一个，然后程序猜，猜错了付钱，那么最少付多少前可以确保猜到。<br>开始以为很简单二分，后来发现不是这样的。需要使用dp。原理的话还是摘录别人的了。<br>Definition of dp[i][j]: minimum number of money to guarantee win for subproblem [i, j].</p><p>Target: dp[1][n]</p><p>Corner case: dp[i][i] = 0 (because the only element must be correct)</p><p>Equation: we can choose k (i&lt;=k&lt;=j) as our guess, and pay price k. After our guess, the problem is divided into two subproblems. Notice we do not need to pay the money for both subproblems. We only need to pay the worst case (because the system will tell us which side we should go) to guarantee win. So dp[i][j] = min (i&lt;=k&lt;=j) { k + max(dp[i][k-1], dp[k+1][j]) }</p><pre class="java hljs"><code class="java" data-origin="<pre><code class=&quot;java&quot;>public class Solution {
    public int getMoneyAmount(int n) {
        if (n == 1) {
            return 0;
        }
        int[][] dp = new int[n + 1][n + 1];
        for (int jminusi = 1; jminusi &amp;lt; n; jminusi++) {
            for (int i = 0; i + jminusi &amp;lt;= n; i++) {
                int j = i + jminusi;
                dp[i][j] = Integer.MAX_VALUE;
                for (int k = i; k &amp;lt;= j; k++) {
                    dp[i][j] = Math.min(dp[i][j],
                                        k + Math.max(k - 1 &amp;gt;= i ? dp[i][k - 1] : 0,
                                                     j &amp;gt;= k + 1 ? dp[k + 1][j] : 0));
                }
            }
        }
        return dp[1][n];
    }
}
</code></pre>"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMoneyAmount</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>{
        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        }
        <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> jminusi = <span class="hljs-number">1</span>; jminusi &lt; n; jminusi++) {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i + jminusi &lt;= n; i++) {
                <span class="hljs-keyword">int</span> j = i + jminusi;
                dp[i][j] = Integer.MAX_VALUE;
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = i; k &lt;= j; k++) {
                    dp[i][j] = Math.min(dp[i][j],
                                        k + Math.max(k - <span class="hljs-number">1</span> &gt;= i ? dp[i][k - <span class="hljs-number">1</span>] : <span class="hljs-number">0</span>,
                                                     j &gt;= k + <span class="hljs-number">1</span> ? dp[k + <span class="hljs-number">1</span>][j] : <span class="hljs-number">0</span>));
                }
            }
        }
        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">1</span>][n];
    }
}
</code></pre><h5 id="515-find-largest-value-in-each-tree-row"><a name="515-find-largest-value-in-each-tree-row" href="#515-find-largest-value-in-each-tree-row"></a>515 find largest value in each tree row</h5><p>对二叉树层次遍历后得到每层最大元素。<br>刚开始有点不知道怎么层次遍历，想了下后既然是二叉树肯定也得递归做，那么就在递归里记录当前是在第几层并且将该元素存储到相应层的记录里吧。使用了一个字典d和层次标记now，每层遍历完后now加1进入下一层这样。</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;># Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution(object):
    def remthis(self,root,d,now):
        if root==None:
            return
        if now in d:
            tmp = d[now]
            tmp.append(root.val)
            d[now] = tmp
        else:
            d[now] = [root.val]
        self.remthis(root.left,d,now+1)
        self.remthis(root.right,d,now+1)
    def largestValues(self, root):
        &quot;&quot;&quot;
        :type root: TreeNode
        :rtype: List[int]
        &quot;&quot;&quot;
        d = {}
        now = 0
        self.remthis(root,d,0)
        res = []
        print(d)
        for i in range(len(d)):
            res.append(max(d[i]))
        return res
</code></pre>"><span class="hljs-comment"># Definition for a binary tree node.</span>
<span class="hljs-comment"># class TreeNode(object):</span>
<span class="hljs-comment">#     def __init__(self, x):</span>
<span class="hljs-comment">#         self.val = x</span>
<span class="hljs-comment">#         self.left = None</span>
<span class="hljs-comment">#         self.right = None</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">remthis</span><span class="hljs-params">(self,root,d,now)</span>:</span>
        <span class="hljs-keyword">if</span> root==<span class="hljs-keyword">None</span>:
            <span class="hljs-keyword">return</span>
        <span class="hljs-keyword">if</span> now <span class="hljs-keyword">in</span> d:
            tmp = d[now]
            tmp.append(root.val)
            d[now] = tmp
        <span class="hljs-keyword">else</span>:
            d[now] = [root.val]
        self.remthis(root.left,d,now+<span class="hljs-number">1</span>)
        self.remthis(root.right,d,now+<span class="hljs-number">1</span>)
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">largestValues</span><span class="hljs-params">(self, root)</span>:</span>
        <span class="hljs-string">"""
        :type root: TreeNode
        :rtype: List[int]
        """</span>
        d = {}
        now = <span class="hljs-number">0</span>
        self.remthis(root,d,<span class="hljs-number">0</span>)
        res = []
        print(d)
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(d)):
            res.append(max(d[i]))
        <span class="hljs-keyword">return</span> res
</code></pre><h5 id="542-01matrix"><a name="542-01matrix" href="#542-01matrix"></a>542 01matrix</h5><p>给定一个matrix里面为0或者1，求出每个元素离0元素的距离。<br>这个本次使用了dfs即广度搜索。由于是坐标搜索所以还涉及了一些坐标的检查。代码基本思路很简单，dfs时需要注意一些点即可。</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>class Solution(object):
    def updateMatrix(self, matrix):
        &quot;&quot;&quot;
        :type matrix: List[List[int]]
        :rtype: List[List[int]]
        &quot;&quot;&quot;
        if matrix==[]:
            return []
        path = {'up':(-1,0),'down':(1,0),'left':(0,-1),'right':(0,1)}
        nx = len(matrix)
        ny = len(matrix[0])
        def getvalid(now,nx,ny):
            #print('now',now)
            res = []
            for i in path:
                x = now[0]+path[i][0]
                y = now[1]+path[i][1]
                if x&amp;gt;=0 and x&amp;lt;=nx-1 and y&amp;gt;=0 and y&amp;lt;=ny-1:
                    res.append((x,y))
            return res
        def getallvalid(nowlist):
            #print('nowlist',nowlist)
            res = []
            for i in nowlist:
                tmp = getvalid(i,nx,ny)
                res = res + tmp
            res = list(set(res))
            return res
        def has0(res):
            #print('res',res)
            flag = False
            for i in range(len(res)):
                if matrix[res[i][0]][res[i][1]] == 0:
                    return True
            return False
        result = [[0 for i in range(ny)]for j in range(nx)]
        def dfs(now,depth):
            res = getallvalid(now)
            if has0(res):
                return depth
            else:
                return dfs(res,depth+1)
        for i in range(nx):
            for j in range(ny):
                if matrix[i][j]==0:
                    result[i][j]=0
                else:
                    result[i][j]=dfs([[i,j]],1)
        return result
</code></pre>"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">updateMatrix</span><span class="hljs-params">(self, matrix)</span>:</span>
        <span class="hljs-string">"""
        :type matrix: List[List[int]]
        :rtype: List[List[int]]
        """</span>
        <span class="hljs-keyword">if</span> matrix==[]:
            <span class="hljs-keyword">return</span> []
        path = {<span class="hljs-string">'up'</span>:(-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>),<span class="hljs-string">'down'</span>:(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>),<span class="hljs-string">'left'</span>:(<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>),<span class="hljs-string">'right'</span>:(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)}
        nx = len(matrix)
        ny = len(matrix[<span class="hljs-number">0</span>])
        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getvalid</span><span class="hljs-params">(now,nx,ny)</span>:</span>
            <span class="hljs-comment">#print('now',now)</span>
            res = []
            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> path:
                x = now[<span class="hljs-number">0</span>]+path[i][<span class="hljs-number">0</span>]
                y = now[<span class="hljs-number">1</span>]+path[i][<span class="hljs-number">1</span>]
                <span class="hljs-keyword">if</span> x&gt;=<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> x&lt;=nx-<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> y&gt;=<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> y&lt;=ny-<span class="hljs-number">1</span>:
                    res.append((x,y))
            <span class="hljs-keyword">return</span> res
        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getallvalid</span><span class="hljs-params">(nowlist)</span>:</span>
            <span class="hljs-comment">#print('nowlist',nowlist)</span>
            res = []
            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> nowlist:
                tmp = getvalid(i,nx,ny)
                res = res + tmp
            res = list(set(res))
            <span class="hljs-keyword">return</span> res
        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">has0</span><span class="hljs-params">(res)</span>:</span>
            <span class="hljs-comment">#print('res',res)</span>
            flag = <span class="hljs-keyword">False</span>
            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(res)):
                <span class="hljs-keyword">if</span> matrix[res[i][<span class="hljs-number">0</span>]][res[i][<span class="hljs-number">1</span>]] == <span class="hljs-number">0</span>:
                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">True</span>
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">False</span>
        result = [[<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(ny)]<span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(nx)]
        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dfs</span><span class="hljs-params">(now,depth)</span>:</span>
            res = getallvalid(now)
            <span class="hljs-keyword">if</span> has0(res):
                <span class="hljs-keyword">return</span> depth
            <span class="hljs-keyword">else</span>:
                <span class="hljs-keyword">return</span> dfs(res,depth+<span class="hljs-number">1</span>)
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(nx):
            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(ny):
                <span class="hljs-keyword">if</span> matrix[i][j]==<span class="hljs-number">0</span>:
                    result[i][j]=<span class="hljs-number">0</span>
                <span class="hljs-keyword">else</span>:
                    result[i][j]=dfs([[i,j]],<span class="hljs-number">1</span>)
        <span class="hljs-keyword">return</span> result
</code></pre><h5 id="399-evaluation-division"><a name="399-evaluation-division" href="#399-evaluation-division"></a>399 evaluation division</h5><p>给出一个数组每个元素是两个字符表示变量，相应的还有一个数组表示上面数组里每一对元素除法后的值，然后给一些query求值，如果无法确定则返回-1.0.<br>这个题目的关键在于确定下来哪些值有关联也就是可以通过前面的值推断出当前值。<br>我的思路是以一个dict记录所有有关联的值，以第一个元素为1其他的按照计算值给值。这样遍历的时候可能会碰到当前两个值都无法确定值的情况，这种情况先保留下来对应的元素然后在下一轮遍历里再看元素是否在相应的dict里。并且如果该元素与之前确实无关系的话那么则需要将原dict保留并重开一个dict去记录。<br>这里说实话感觉虽然AC了但是还是有漏洞的，就是在下一轮遍历的时候如果元素顺序很凑巧的话是有可能误认为与之前dict无关联了的。不过我感觉这种凑巧的例子可能官方也写不出用例吧。<br>本次还学到了python里嵌套函数是无法直接修改外部参数的，原因不明，后续碰到这个小心点吧。</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>class Solution(object):
    def calcEquation(self, equations, values, queries):
        &quot;&quot;&quot;
        :type equations: List[List[str]]
        :type values: List[float]
        :type queries: List[List[str]]
        :rtype: List[float]
        &quot;&quot;&quot;
        d = {}
        dd = []
        def diedai(equations,values):
            #global d
            others = []
            othersvalue = []
            first = True
            for pair,value in zip(equations,values):
                if pair[0] in d:
                    d[pair[1]] = d[pair[0]]/value
                elif pair[1] in d:
                    d[pair[0]] = d[pair[1]]*value
                else:
                    if first == False:
                        others.append(pair)
                        othersvalue.append(value)
                    else:
                        #print('dd',d)
                        c = d.copy()
                        dd.append(c)
                        d.clear()
                        d[pair[1]] = 1.0
                        d[pair[0]] = d[pair[1]]*value
                        first = False
            #print(others)
            equations = others
            values = othersvalue
            if len(others)!=0:
                return True,others,othersvalue
            return False,others,othersvalue
        while(True):
            #print(equations,values)
            flag,equations,values = diedai(equations,values)
            if flag == False:
                break
        dd.append(d)
        res = []
        for pair in queries:
            flag = False
            for d in dd:
                if pair[0] in d and pair[1] in d:
                    res.append(d[pair[0]]/d[pair[1]])
                    flag = True
                    break
            if flag == False:
                res.append(-1.0)
        return res
</code></pre>"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">calcEquation</span><span class="hljs-params">(self, equations, values, queries)</span>:</span>
        <span class="hljs-string">"""
        :type equations: List[List[str]]
        :type values: List[float]
        :type queries: List[List[str]]
        :rtype: List[float]
        """</span>
        d = {}
        dd = []
        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">diedai</span><span class="hljs-params">(equations,values)</span>:</span>
            <span class="hljs-comment">#global d</span>
            others = []
            othersvalue = []
            first = <span class="hljs-keyword">True</span>
            <span class="hljs-keyword">for</span> pair,value <span class="hljs-keyword">in</span> zip(equations,values):
                <span class="hljs-keyword">if</span> pair[<span class="hljs-number">0</span>] <span class="hljs-keyword">in</span> d:
                    d[pair[<span class="hljs-number">1</span>]] = d[pair[<span class="hljs-number">0</span>]]/value
                <span class="hljs-keyword">elif</span> pair[<span class="hljs-number">1</span>] <span class="hljs-keyword">in</span> d:
                    d[pair[<span class="hljs-number">0</span>]] = d[pair[<span class="hljs-number">1</span>]]*value
                <span class="hljs-keyword">else</span>:
                    <span class="hljs-keyword">if</span> first == <span class="hljs-keyword">False</span>:
                        others.append(pair)
                        othersvalue.append(value)
                    <span class="hljs-keyword">else</span>:
                        <span class="hljs-comment">#print('dd',d)</span>
                        c = d.copy()
                        dd.append(c)
                        d.clear()
                        d[pair[<span class="hljs-number">1</span>]] = <span class="hljs-number">1.0</span>
                        d[pair[<span class="hljs-number">0</span>]] = d[pair[<span class="hljs-number">1</span>]]*value
                        first = <span class="hljs-keyword">False</span>
            <span class="hljs-comment">#print(others)</span>
            equations = others
            values = othersvalue
            <span class="hljs-keyword">if</span> len(others)!=<span class="hljs-number">0</span>:
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">True</span>,others,othersvalue
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">False</span>,others,othersvalue
        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">True</span>):
            <span class="hljs-comment">#print(equations,values)</span>
            flag,equations,values = diedai(equations,values)
            <span class="hljs-keyword">if</span> flag == <span class="hljs-keyword">False</span>:
                <span class="hljs-keyword">break</span>
        dd.append(d)
        res = []
        <span class="hljs-keyword">for</span> pair <span class="hljs-keyword">in</span> queries:
            flag = <span class="hljs-keyword">False</span>
            <span class="hljs-keyword">for</span> d <span class="hljs-keyword">in</span> dd:
                <span class="hljs-keyword">if</span> pair[<span class="hljs-number">0</span>] <span class="hljs-keyword">in</span> d <span class="hljs-keyword">and</span> pair[<span class="hljs-number">1</span>] <span class="hljs-keyword">in</span> d:
                    res.append(d[pair[<span class="hljs-number">0</span>]]/d[pair[<span class="hljs-number">1</span>]])
                    flag = <span class="hljs-keyword">True</span>
                    <span class="hljs-keyword">break</span>
            <span class="hljs-keyword">if</span> flag == <span class="hljs-keyword">False</span>:
                res.append(-<span class="hljs-number">1.0</span>)
        <span class="hljs-keyword">return</span> res
</code></pre><h5 id="61-rotate-list"><a name="61-rotate-list" href="#61-rotate-list"></a>61 rotate list</h5><p>将list按照某个位置旋转<br>这种题目最好画图看看就简单了。</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;># Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution(object):
    def rotateRight(self, head, k):
        &quot;&quot;&quot;
        :type head: ListNode
        :type k: int
        :rtype: ListNode
        &quot;&quot;&quot;
        if head == None or head.next==None or k==0:
            return head
        count = 0
        headbak = head
        while(head!=None):
            head = head.next
            count = count + 1
        k = k%count
        inx = count - k
        prehead = ListNode(0)
        prehead.next = headbak
        preheadbak = headbak
        print(count,inx)
        for i in range(count):
            print(i,headbak.val,prehead.next.val)
            if i==inx:
                preheadbak = headbak
            if i == count -1:
                headbak.next = prehead.next
            headbak = headbak.next
        headbak = prehead.next
        for i in range(count):
            if i==inx-1:
                headbak.next = None
                break
            else:
                headbak = headbak.next
        return preheadbak
</code></pre>"><span class="hljs-comment"># Definition for singly-linked list.</span>
<span class="hljs-comment"># class ListNode(object):</span>
<span class="hljs-comment">#     def __init__(self, x):</span>
<span class="hljs-comment">#         self.val = x</span>
<span class="hljs-comment">#         self.next = None</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">rotateRight</span><span class="hljs-params">(self, head, k)</span>:</span>
        <span class="hljs-string">"""
        :type head: ListNode
        :type k: int
        :rtype: ListNode
        """</span>
        <span class="hljs-keyword">if</span> head == <span class="hljs-keyword">None</span> <span class="hljs-keyword">or</span> head.next==<span class="hljs-keyword">None</span> <span class="hljs-keyword">or</span> k==<span class="hljs-number">0</span>:
            <span class="hljs-keyword">return</span> head
        count = <span class="hljs-number">0</span>
        headbak = head
        <span class="hljs-keyword">while</span>(head!=<span class="hljs-keyword">None</span>):
            head = head.next
            count = count + <span class="hljs-number">1</span>
        k = k%count
        inx = count - k
        prehead = ListNode(<span class="hljs-number">0</span>)
        prehead.next = headbak
        preheadbak = headbak
        print(count,inx)
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(count):
            print(i,headbak.val,prehead.next.val)
            <span class="hljs-keyword">if</span> i==inx:
                preheadbak = headbak
            <span class="hljs-keyword">if</span> i == count -<span class="hljs-number">1</span>:
                headbak.next = prehead.next
            headbak = headbak.next
        headbak = prehead.next
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(count):
            <span class="hljs-keyword">if</span> i==inx-<span class="hljs-number">1</span>:
                headbak.next = <span class="hljs-keyword">None</span>
                <span class="hljs-keyword">break</span>
            <span class="hljs-keyword">else</span>:
                headbak = headbak.next
        <span class="hljs-keyword">return</span> preheadbak
</code></pre><h5 id="458-poor-pigs"><a name="458-poor-pigs" href="#458-poor-pigs"></a>458 poor pigs</h5><p>1000个桶，猪喝了15分钟死，一小时内确定下来哪个有毒，需要多少猪。扩展，n个桶，喝了m分钟死一共h时间，需要多少猪。<br>这道题直接去思考分配方法很困难，可以从信息论的角度推出最少需要多少猪。从n个桶里判断哪个有毒需要信息量为log(1/n),而每个猪死在什么时间加入15分钟一小时那么一共五种情况（不死）也就是log（1/5）信息量，如此就可以计算出需要多少猪。</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>class Solution(object):
    def poorPigs(self, buckets, minutesToDie, minutesToTest):
        &quot;&quot;&quot;
        :type buckets: int
        :type minutesToDie: int
        :type minutesToTest: int
        :rtype: int
        &quot;&quot;&quot;
        import math
        res = 1.0*math.log(buckets)/math.log(minutesToTest/minutesToDie+1)
        if int(res)==res:
            return int(res)
        else:
            return int(res)+1
</code></pre>"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">poorPigs</span><span class="hljs-params">(self, buckets, minutesToDie, minutesToTest)</span>:</span>
        <span class="hljs-string">"""
        :type buckets: int
        :type minutesToDie: int
        :type minutesToTest: int
        :rtype: int
        """</span>
        <span class="hljs-keyword">import</span> math
        res = <span class="hljs-number">1.0</span>*math.log(buckets)/math.log(minutesToTest/minutesToDie+<span class="hljs-number">1</span>)
        <span class="hljs-keyword">if</span> int(res)==res:
            <span class="hljs-keyword">return</span> int(res)
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">return</span> int(res)+<span class="hljs-number">1</span>
</code></pre><h5 id="406-queue-reconstruction"><a name="406-queue-reconstruction" href="#406-queue-reconstruction"></a>406 queue reconstruction</h5><p>一个数组，每个元素为一个二元数组，内容为身高和在其前面升高大于等于他的人的个数。要求按照这个信息将这些人重新排列使得符合元素的标识。<br>这道题目主要是利用了插入排序的思路，也就是从头开始遍历所有人，在面对一个新元素时根据其个人信息判断应该将其插在哪里这样，具体的规则和插入过程比较繁琐，但思路就是插入排序。<br>还有一点需要注意的就是输入的人需要按照其前面人的个数去排序。这样做的目的是因为插入排序是从头向后排的，并且插入位置提取也是从前向后遍历，这样按照前面的人的个数排序后可以避免一个元素开始插入时正确后面因为其他元素插入到其前面使得其出错的情况。这个为什么加了排序才正确呢，其实这个题目本身给的输入就是符合一定规则的，如果真的是随意的输入是无法保证能够重组数组的。所以排序后按照顺序去插入不会出错可以归结成输入本身的特性。</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>class Solution(object):
    def reconstructQueue(self, people):
        &quot;&quot;&quot;
        :type people: List[List[int]]
        :rtype: List[List[int]]
        &quot;&quot;&quot;
        people = sorted(people,key=lambda i:i[1])
        if len(people)&amp;lt;=1:
            return people
        res = [people[0]]
        tag = [1 for _ in range(len(people))]
        tag[0] = 0
        while(sum(tag)!=0):
            for i in range(1,len(people)):
                if tag[i]==1:
                    nowheight = people[i][0]
                    nowbefore = people[i][1]
                    inx = 0
                    count = 0
                    ok = False
                    if nowbefore == 0:
                        ok = True
                    else:
                        for j in range(len(res)):
                            inx = inx + 1
                            #print('www',i,j,res,count,nowbefore,nowheight,res[j][0])
                            if res[j][0]&amp;gt;=nowheight:
                                count = count + 1
                            if count == nowbefore:
                                ok = True
                                break
                    if ok:
                        while inx&amp;lt;len(res) and res[inx][0]&amp;lt;=nowheight:
                            inx = inx + 1
                        res.insert(inx,people[i])
                        tag[i] = 0
        return res
</code></pre>"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reconstructQueue</span><span class="hljs-params">(self, people)</span>:</span>
        <span class="hljs-string">"""
        :type people: List[List[int]]
        :rtype: List[List[int]]
        """</span>
        people = sorted(people,key=<span class="hljs-keyword">lambda</span> i:i[<span class="hljs-number">1</span>])
        <span class="hljs-keyword">if</span> len(people)&lt;=<span class="hljs-number">1</span>:
            <span class="hljs-keyword">return</span> people
        res = [people[<span class="hljs-number">0</span>]]
        tag = [<span class="hljs-number">1</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(len(people))]
        tag[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>
        <span class="hljs-keyword">while</span>(sum(tag)!=<span class="hljs-number">0</span>):
            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>,len(people)):
                <span class="hljs-keyword">if</span> tag[i]==<span class="hljs-number">1</span>:
                    nowheight = people[i][<span class="hljs-number">0</span>]
                    nowbefore = people[i][<span class="hljs-number">1</span>]
                    inx = <span class="hljs-number">0</span>
                    count = <span class="hljs-number">0</span>
                    ok = <span class="hljs-keyword">False</span>
                    <span class="hljs-keyword">if</span> nowbefore == <span class="hljs-number">0</span>:
                        ok = <span class="hljs-keyword">True</span>
                    <span class="hljs-keyword">else</span>:
                        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(len(res)):
                            inx = inx + <span class="hljs-number">1</span>
                            <span class="hljs-comment">#print('www',i,j,res,count,nowbefore,nowheight,res[j][0])</span>
                            <span class="hljs-keyword">if</span> res[j][<span class="hljs-number">0</span>]&gt;=nowheight:
                                count = count + <span class="hljs-number">1</span>
                            <span class="hljs-keyword">if</span> count == nowbefore:
                                ok = <span class="hljs-keyword">True</span>
                                <span class="hljs-keyword">break</span>
                    <span class="hljs-keyword">if</span> ok:
                        <span class="hljs-keyword">while</span> inx&lt;len(res) <span class="hljs-keyword">and</span> res[inx][<span class="hljs-number">0</span>]&lt;=nowheight:
                            inx = inx + <span class="hljs-number">1</span>
                        res.insert(inx,people[i])
                        tag[i] = <span class="hljs-number">0</span>
        <span class="hljs-keyword">return</span> res
</code></pre><h5 id="368-largest-divisible-subset"><a name="368-largest-divisible-subset" href="#368-largest-divisible-subset"></a>368 largest divisible subset</h5><p>给定一个数组，求最大子集合，使得其中任意两个元素之间都可以整除。<br>为了方便求整除我们先排序。从小到大。而后想到还是使用dp。dp[i]的意思当前就是包含第i个元素的最大子集是多长。那么递归公式，则需要遍历i前面的j个元素，如果i可以整除j，那么就将问题转换为1+dp[j],其中每个dp内不单单存储长度而是具体的元素，因为最后结果就是要求返回这个东西。</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>class Solution(object):
    def largestDivisibleSubset(self, nums):
        &quot;&quot;&quot;
        :type nums: List[int]
        :rtype: List[int]
        &quot;&quot;&quot;
        from copy import copy
        nums.sort()
        n = len(nums)
        if n==0:
            return []
        dp = [0]*n
        dp[0]= [nums[0]]
        for i in range(1,n):
            curNum = nums[i]
            maxSet = []
            for j in range(i):
                if curNum%nums[j]==0:
                    localSet = copy(dp[j])
                    if len(localSet)&amp;gt;len(maxSet):
                        maxSet = localSet
            maxSet.append(nums[i])
            dp[i] = maxSet
        res = []
        for localSet in dp:
            if len(localSet)&amp;gt;len(res):
                res = localSet
        return res
</code></pre>"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">largestDivisibleSubset</span><span class="hljs-params">(self, nums)</span>:</span>
        <span class="hljs-string">"""
        :type nums: List[int]
        :rtype: List[int]
        """</span>
        <span class="hljs-keyword">from</span> copy <span class="hljs-keyword">import</span> copy
        nums.sort()
        n = len(nums)
        <span class="hljs-keyword">if</span> n==<span class="hljs-number">0</span>:
            <span class="hljs-keyword">return</span> []
        dp = [<span class="hljs-number">0</span>]*n
        dp[<span class="hljs-number">0</span>]= [nums[<span class="hljs-number">0</span>]]
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>,n):
            curNum = nums[i]
            maxSet = []
            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(i):
                <span class="hljs-keyword">if</span> curNum%nums[j]==<span class="hljs-number">0</span>:
                    localSet = copy(dp[j])
                    <span class="hljs-keyword">if</span> len(localSet)&gt;len(maxSet):
                        maxSet = localSet
            maxSet.append(nums[i])
            dp[i] = maxSet
        res = []
        <span class="hljs-keyword">for</span> localSet <span class="hljs-keyword">in</span> dp:
            <span class="hljs-keyword">if</span> len(localSet)&gt;len(res):
                res = localSet
        <span class="hljs-keyword">return</span> res
</code></pre><h5 id="207-course-schedule"><a name="207-course-schedule" href="#207-course-schedule"></a>207 course schedule</h5><p>给定一个数组，里面是每两个课程之间的先会关系，查看是否有环路。<br>先建图，然后dfs或者bfs都行。<br>思路如下：dfs的时候对于正在遍历的节点标记为-1，遍历完后标记为1.意思就是如果碰到-1的那肯定是出现了环路，因为正常的遍历是不会出现遍历到正在遍历的点的。如果碰到1则可以认为从这个节点向后遍历也不会出错。</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>def canFinish(self, numCourses, prerequisites):
    graph = [[] for _ in xrange(numCourses)]
    visit = [0 for _ in xrange(numCourses)]
    for x, y in prerequisites:
        graph[x].append(y)
    def dfs(i):
        if visit[i] == -1:
            return False
        if visit[i] == 1:
            return True
        visit[i] = -1
        for j in graph[i]:
            if not dfs(j):
                return False
        visit[i] = 1
        return True
    for i in xrange(numCourses):
        if not dfs(i):
            return False
    return True
</code></pre>"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">canFinish</span><span class="hljs-params">(self, numCourses, prerequisites)</span>:</span>
    graph = [[] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> xrange(numCourses)]
    visit = [<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> xrange(numCourses)]
    <span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> prerequisites:
        graph[x].append(y)
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dfs</span><span class="hljs-params">(i)</span>:</span>
        <span class="hljs-keyword">if</span> visit[i] == -<span class="hljs-number">1</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">False</span>
        <span class="hljs-keyword">if</span> visit[i] == <span class="hljs-number">1</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">True</span>
        visit[i] = -<span class="hljs-number">1</span>
        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> graph[i]:
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> dfs(j):
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">False</span>
        visit[i] = <span class="hljs-number">1</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">True</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> xrange(numCourses):
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> dfs(i):
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">False</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">True</span>
</code></pre><h5 id="40-combination-sum2"><a name="40-combination-sum2" href="#40-combination-sum2"></a>40 combination sum2</h5><p>给定一个数组和一个值，求出数组里相应元素是否有几个加起来等于该值的。<br>回溯法。回溯的时候需要注意的有一个就是一定要在递归语句后将状态恢复过来。或者递归里面就使用局部变量来代替。</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>class Solution(object):
    def hs(self,nums,target,now,resnow,res,inx):
        if target == now:
            h = False
            tmp1 = sorted(resnow)
            for i in res:
                #print(resnow,res)
                tmp2 = sorted(i)
                if tmp1==tmp2:
                    h = True
                #    print(resnow)
            if h == False:
                res.append(resnow)
            return
        for i in range(inx,len(nums)):
            if now+nums[i]&amp;lt;=target:
                tmp = []
                for j in resnow:
                    tmp.append(j)
                tmp.append(nums[i])
                self.hs(nums,target,now+nums[i],tmp,res,i+1)
                tmp = tmp[0:-1]
                #self.hs(nums,target,now,tmp,res,i+1)

    def combinationSum2(self, candidates, target):
        &quot;&quot;&quot;
        :type candidates: List[int]
        :type target: int
        :rtype: List[List[int]]
        For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,
        [
         [1, 7],
         [1, 2, 5],
         [2, 6],
         [1, 1, 6]
        ]
        &quot;&quot;&quot;
        n = len (candidates)
        res = []
        resnow = []
        self.hs(candidates,target,0,resnow,res,0)
        return res
</code></pre>"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hs</span><span class="hljs-params">(self,nums,target,now,resnow,res,inx)</span>:</span>
        <span class="hljs-keyword">if</span> target == now:
            h = <span class="hljs-keyword">False</span>
            tmp1 = sorted(resnow)
            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> res:
                <span class="hljs-comment">#print(resnow,res)</span>
                tmp2 = sorted(i)
                <span class="hljs-keyword">if</span> tmp1==tmp2:
                    h = <span class="hljs-keyword">True</span>
                <span class="hljs-comment">#    print(resnow)</span>
            <span class="hljs-keyword">if</span> h == <span class="hljs-keyword">False</span>:
                res.append(resnow)
            <span class="hljs-keyword">return</span>
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(inx,len(nums)):
            <span class="hljs-keyword">if</span> now+nums[i]&lt;=target:
                tmp = []
                <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> resnow:
                    tmp.append(j)
                tmp.append(nums[i])
                self.hs(nums,target,now+nums[i],tmp,res,i+<span class="hljs-number">1</span>)
                tmp = tmp[<span class="hljs-number">0</span>:-<span class="hljs-number">1</span>]
                <span class="hljs-comment">#self.hs(nums,target,now,tmp,res,i+1)</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">combinationSum2</span><span class="hljs-params">(self, candidates, target)</span>:</span>
        <span class="hljs-string">"""
        :type candidates: List[int]
        :type target: int
        :rtype: List[List[int]]
        For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,
        [
         [1, 7],
         [1, 2, 5],
         [2, 6],
         [1, 1, 6]
        ]
        """</span>
        n = len (candidates)
        res = []
        resnow = []
        self.hs(candidates,target,<span class="hljs-number">0</span>,resnow,res,<span class="hljs-number">0</span>)
        <span class="hljs-keyword">return</span> res
</code></pre><h5 id="39-combination-sum"><a name="39-combination-sum" href="#39-combination-sum"></a>39 combination sum</h5><p>和上题基本一样，唯一不同在于这里可以使用重复一个值。<br>思路的话还是回溯，区别在于递归的时候依然可以从当前坐标位置开始查找。</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>class Solution(object):
    def hs(self,nums,target,now,resnow,res,inx):
        if target == now:
            h = False
            tmp1 = sorted(resnow)
            for i in res:
                #print(resnow,res)
                tmp2 = sorted(i)
                if tmp1==tmp2:
                    h = True
                #    print(resnow)
            if h == False:
                res.append(resnow)
            return
        for i in range(inx,len(nums)):
            if now+nums[i]&amp;lt;=target:
                tmp = []
                for j in resnow:
                    tmp.append(j)
                tmp.append(nums[i])
                self.hs(nums,target,now+nums[i],tmp,res,i)
                tmp = tmp[0:-1]
                #self.hs(nums,target,now,tmp,res,i+1)

    def combinationSum(self, candidates, target):
        &quot;&quot;&quot;
        :type candidates: List[int]
        :type target: int
        :rtype: List[List[int]]
        For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,
        [
         [1, 7],
         [1, 2, 5],
         [2, 6],
         [1, 1, 6]
        ]
        &quot;&quot;&quot;
        n = len (candidates)
        res = []
        resnow = []
        self.hs(candidates,target,0,resnow,res,0)
        return res
</code></pre>"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hs</span><span class="hljs-params">(self,nums,target,now,resnow,res,inx)</span>:</span>
        <span class="hljs-keyword">if</span> target == now:
            h = <span class="hljs-keyword">False</span>
            tmp1 = sorted(resnow)
            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> res:
                <span class="hljs-comment">#print(resnow,res)</span>
                tmp2 = sorted(i)
                <span class="hljs-keyword">if</span> tmp1==tmp2:
                    h = <span class="hljs-keyword">True</span>
                <span class="hljs-comment">#    print(resnow)</span>
            <span class="hljs-keyword">if</span> h == <span class="hljs-keyword">False</span>:
                res.append(resnow)
            <span class="hljs-keyword">return</span>
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(inx,len(nums)):
            <span class="hljs-keyword">if</span> now+nums[i]&lt;=target:
                tmp = []
                <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> resnow:
                    tmp.append(j)
                tmp.append(nums[i])
                self.hs(nums,target,now+nums[i],tmp,res,i)
                tmp = tmp[<span class="hljs-number">0</span>:-<span class="hljs-number">1</span>]
                <span class="hljs-comment">#self.hs(nums,target,now,tmp,res,i+1)</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">combinationSum</span><span class="hljs-params">(self, candidates, target)</span>:</span>
        <span class="hljs-string">"""
        :type candidates: List[int]
        :type target: int
        :rtype: List[List[int]]
        For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,
        [
         [1, 7],
         [1, 2, 5],
         [2, 6],
         [1, 1, 6]
        ]
        """</span>
        n = len (candidates)
        res = []
        resnow = []
        self.hs(candidates,target,<span class="hljs-number">0</span>,resnow,res,<span class="hljs-number">0</span>)
        <span class="hljs-keyword">return</span> res
</code></pre><h5 id="17-letter-combinations-of-phone"><a name="17-letter-combinations-of-phone" href="#17-letter-combinations-of-phone"></a>17 letter combinations of phone</h5><p>给出手机上0-9对应的字母。给出数字求所有可能字母集合。<br>直接挨个遍历即可。</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>class Solution(object):
    def letterCombinations(self, digits):
        &quot;&quot;&quot;
        :type digits: str
        :rtype: List[str]
        &quot;&quot;&quot;
        d = {1:'*',2:'abc',3:'def',4:'ghi',5:'jkl',6:'mno',7:'pqrs',8:'tuv',9:'wxyz',0:' '}
        n = len(digits)
        if n == 0:
            return []
        res = list(d[int(digits[0])])
        if n == 1:
            return res
        for i in digits[1:]:#2
            now = d[int(i)]#abc
            tmp = []
            for j in now:#a
                for k in res:
                    tmp.append(k+j)
            res = tmp
        return res
</code></pre>"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">letterCombinations</span><span class="hljs-params">(self, digits)</span>:</span>
        <span class="hljs-string">"""
        :type digits: str
        :rtype: List[str]
        """</span>
        d = {<span class="hljs-number">1</span>:<span class="hljs-string">'*'</span>,<span class="hljs-number">2</span>:<span class="hljs-string">'abc'</span>,<span class="hljs-number">3</span>:<span class="hljs-string">'def'</span>,<span class="hljs-number">4</span>:<span class="hljs-string">'ghi'</span>,<span class="hljs-number">5</span>:<span class="hljs-string">'jkl'</span>,<span class="hljs-number">6</span>:<span class="hljs-string">'mno'</span>,<span class="hljs-number">7</span>:<span class="hljs-string">'pqrs'</span>,<span class="hljs-number">8</span>:<span class="hljs-string">'tuv'</span>,<span class="hljs-number">9</span>:<span class="hljs-string">'wxyz'</span>,<span class="hljs-number">0</span>:<span class="hljs-string">' '</span>}
        n = len(digits)
        <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>:
            <span class="hljs-keyword">return</span> []
        res = list(d[int(digits[<span class="hljs-number">0</span>])])
        <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span>:
            <span class="hljs-keyword">return</span> res
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> digits[<span class="hljs-number">1</span>:]:<span class="hljs-comment">#2</span>
            now = d[int(i)]<span class="hljs-comment">#abc</span>
            tmp = []
            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> now:<span class="hljs-comment">#a</span>
                <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> res:
                    tmp.append(k+j)
            res = tmp
        <span class="hljs-keyword">return</span> res
</code></pre><h5 id="474-ones-and-zeros"><a name="474-ones-and-zeros" href="#474-ones-and-zeros"></a>474 ones and zeros</h5><p>给定一个数组，里面的元素是由不等的‘0’和‘1’组成的字符串。那么再给定m，n分别指0和1的最大数目。求解这m，n个0,1最多组成数组里多少个字符串。每个字符串统计一次，每个0,1也只使用一次。<br>刚开始时以为只有按照长度排序而后贪心的消耗m，n即可。但是只能通过一部分测试。主要原因是贪心没有考虑周全所有情况。那么考虑使用dp。dp公式的话有三个变量，数组坐标，m，n，就是三维dp。dp[k][m][n]意思是前k个数组，m个0n个1的结果，那么可以考虑出递归公式是dp[k][m][n] = max(1+dp[k-1][m-s0][n-s1],dp[k-1][m-s0][n-s1]).也就是考虑第k个元素是否加入，如果加入则需要m，n减去这个元素的0和1，或者不加入。<br>写程序时可以三层循环，也可以将k的循环写成对元素的遍历。需要注意的是k是从小到大遍历，而m和n是从大到小遍历，这里注意原因是使用了滚动数组的思想来节省空间，所以mn需要从大到小以保证递归公式里k是k-1这样的。</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>class Solution(object):
    def findMaxForm(self, strs, m, n):
        dp = [[0]*(n+1) for _ in range(m+1)]
        def count(s):
            return sum(1 for c in s if c=='0'),sum(1 for c in s if c=='1')
        for s0,s1 in [count(s) for s in strs]:
            for x in range(m,-1,-1):
                for y in range(n,-1,-1):
                    if x&amp;gt;=s0 and y&amp;gt;=s1:
                        dp[x][y] = max(1+dp[x-s0][y-s1],dp[x][y])
        return dp[m][n]
</code></pre>"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findMaxForm</span><span class="hljs-params">(self, strs, m, n)</span>:</span>
        dp = [[<span class="hljs-number">0</span>]*(n+<span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(m+<span class="hljs-number">1</span>)]
        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">count</span><span class="hljs-params">(s)</span>:</span>
            <span class="hljs-keyword">return</span> sum(<span class="hljs-number">1</span> <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> s <span class="hljs-keyword">if</span> c==<span class="hljs-string">'0'</span>),sum(<span class="hljs-number">1</span> <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> s <span class="hljs-keyword">if</span> c==<span class="hljs-string">'1'</span>)
        <span class="hljs-keyword">for</span> s0,s1 <span class="hljs-keyword">in</span> [count(s) <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> strs]:
            <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(m,-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>):
                <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> range(n,-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>):
                    <span class="hljs-keyword">if</span> x&gt;=s0 <span class="hljs-keyword">and</span> y&gt;=s1:
                        dp[x][y] = max(<span class="hljs-number">1</span>+dp[x-s0][y-s1],dp[x][y])
        <span class="hljs-keyword">return</span> dp[m][n]
</code></pre><h5 id="530"><a name="530" href="#530"></a>530</h5><p>BST里求任意两个节点最小差值。<br>直接中序遍历而后遍历差值即可。</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;># Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution(object):
    def isValid(self,root,res):
        if root.left!=None:
            self.isValid(root.left,res)
        res.append(root.val)
        if root.right !=None:
            self.isValid(root.right,res)
    def getMinimumDifference(self, root):
        &quot;&quot;&quot;
        :type root: TreeNode
        :rtype: int
        &quot;&quot;&quot;
        res = []
        self.isValid(root,res)
        minv = res[-1]-res[0]
        for i in range(len(res)-1):
            minv = min(minv,res[i+1]-res[i])
        return minv
</code></pre>"><span class="hljs-comment"># Definition for a binary tree node.</span>
<span class="hljs-comment"># class TreeNode(object):</span>
<span class="hljs-comment">#     def __init__(self, x):</span>
<span class="hljs-comment">#         self.val = x</span>
<span class="hljs-comment">#         self.left = None</span>
<span class="hljs-comment">#         self.right = None</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isValid</span><span class="hljs-params">(self,root,res)</span>:</span>
        <span class="hljs-keyword">if</span> root.left!=<span class="hljs-keyword">None</span>:
            self.isValid(root.left,res)
        res.append(root.val)
        <span class="hljs-keyword">if</span> root.right !=<span class="hljs-keyword">None</span>:
            self.isValid(root.right,res)
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getMinimumDifference</span><span class="hljs-params">(self, root)</span>:</span>
        <span class="hljs-string">"""
        :type root: TreeNode
        :rtype: int
        """</span>
        res = []
        self.isValid(root,res)
        minv = res[-<span class="hljs-number">1</span>]-res[<span class="hljs-number">0</span>]
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(res)-<span class="hljs-number">1</span>):
            minv = min(minv,res[i+<span class="hljs-number">1</span>]-res[i])
        <span class="hljs-keyword">return</span> minv
</code></pre><h5 id="532-k-diff-in-an-array"><a name="532-k-diff-in-an-array" href="#532-k-diff-in-an-array"></a>532 K-diff in an array</h5><p>一个数组，求里面两个数对差值绝对值等于k的。<br>一开始居然没有想到使用dict而是超时后才想到。。。</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>class Solution(object):
    def findPairs(self, nums, k):
        &quot;&quot;&quot;
        :type nums: List[int]
        :type k: int
        :rtype: int
        &quot;&quot;&quot;
        res = 0
        if k == 0:
            dou = []
            d = {}
            for i in nums:
                if i in d:
                    d[i] = d[i] + 1
                else:
                    d[i] = 1
            for i in d:
                if d[i]&amp;gt;1:
                    res = res + 1
            return res
        else:
            nums = set(nums)
            d = {}
            for i in nums:
                d[i] =1
            if k&amp;lt;0:
                return 0
            for i in nums:
                if k+i in d:
                    res = res + 1
        return res
</code></pre>"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findPairs</span><span class="hljs-params">(self, nums, k)</span>:</span>
        <span class="hljs-string">"""
        :type nums: List[int]
        :type k: int
        :rtype: int
        """</span>
        res = <span class="hljs-number">0</span>
        <span class="hljs-keyword">if</span> k == <span class="hljs-number">0</span>:
            dou = []
            d = {}
            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> nums:
                <span class="hljs-keyword">if</span> i <span class="hljs-keyword">in</span> d:
                    d[i] = d[i] + <span class="hljs-number">1</span>
                <span class="hljs-keyword">else</span>:
                    d[i] = <span class="hljs-number">1</span>
            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> d:
                <span class="hljs-keyword">if</span> d[i]&gt;<span class="hljs-number">1</span>:
                    res = res + <span class="hljs-number">1</span>
            <span class="hljs-keyword">return</span> res
        <span class="hljs-keyword">else</span>:
            nums = set(nums)
            d = {}
            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> nums:
                d[i] =<span class="hljs-number">1</span>
            <span class="hljs-keyword">if</span> k&lt;<span class="hljs-number">0</span>:
                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>
            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> nums:
                <span class="hljs-keyword">if</span> k+i <span class="hljs-keyword">in</span> d:
                    res = res + <span class="hljs-number">1</span>
        <span class="hljs-keyword">return</span> res
</code></pre><h5 id="617-merge-two-binary-trees"><a name="617-merge-two-binary-trees" href="#617-merge-two-binary-trees"></a>617 merge two Binary Trees</h5><p>将两颗二叉树合并，都有值的sum，一个有一个没有的算有的那个。<br>直接重新生成一颗新树好了，递归这样的生成。</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;># Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution(object):
    def mergeTrees(self, t1, t2):
        &quot;&quot;&quot;
        :type t1: TreeNode
        :type t2: TreeNode
        :rtype: TreeNode
        &quot;&quot;&quot;
        if t1==None and t2!=None:
            return t2
        if t2==None and t1!=None:
            return t1
        if t1==None and t2==None:
            return None
        tmp = TreeNode(0)
        tmp.val = t1.val+t2.val
        tmp.left = self.mergeTrees(t1.left,t2.left)
        tmp.right = self.mergeTrees(t1.right,t2.right)
        return tmp
</code></pre>"><span class="hljs-comment"># Definition for a binary tree node.</span>
<span class="hljs-comment"># class TreeNode(object):</span>
<span class="hljs-comment">#     def __init__(self, x):</span>
<span class="hljs-comment">#         self.val = x</span>
<span class="hljs-comment">#         self.left = None</span>
<span class="hljs-comment">#         self.right = None</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mergeTrees</span><span class="hljs-params">(self, t1, t2)</span>:</span>
        <span class="hljs-string">"""
        :type t1: TreeNode
        :type t2: TreeNode
        :rtype: TreeNode
        """</span>
        <span class="hljs-keyword">if</span> t1==<span class="hljs-keyword">None</span> <span class="hljs-keyword">and</span> t2!=<span class="hljs-keyword">None</span>:
            <span class="hljs-keyword">return</span> t2
        <span class="hljs-keyword">if</span> t2==<span class="hljs-keyword">None</span> <span class="hljs-keyword">and</span> t1!=<span class="hljs-keyword">None</span>:
            <span class="hljs-keyword">return</span> t1
        <span class="hljs-keyword">if</span> t1==<span class="hljs-keyword">None</span> <span class="hljs-keyword">and</span> t2==<span class="hljs-keyword">None</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">None</span>
        tmp = TreeNode(<span class="hljs-number">0</span>)
        tmp.val = t1.val+t2.val
        tmp.left = self.mergeTrees(t1.left,t2.left)
        tmp.right = self.mergeTrees(t1.right,t2.right)
        <span class="hljs-keyword">return</span> tmp
</code></pre><h5 id="223-rectangle-area"><a name="223-rectangle-area" href="#223-rectangle-area"></a>223 Rectangle area</h5><p>给定两个长方形的左下角和右上角坐标，求两者面积之和。<br>这个需要方便的判断重叠区域的坐标。<br>这个方法确实不太容易马上想到，最好是花几个图总结一下规律。求出重叠区域的左，右，上，下四个边界的值。</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>class Solution(object):
    def computeArea(self, A, B, C, D, E, F, G, H):
        &quot;&quot;&quot;
        :type A: int
        :type B: int
        :type C: int
        :type D: int
        :type E: int
        :type F: int
        :type G: int
        :type H: int
        :rtype: int
        &quot;&quot;&quot;
        left = max(A,E)
        right = max(min(C,G),left)
        bottom = max(B,F)
        top = max(min(D,H),bottom)
        return (D-B)*(C-A)+(G-E)*(H-F)-(right-left)*(top-bottom)
</code></pre>"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">computeArea</span><span class="hljs-params">(self, A, B, C, D, E, F, G, H)</span>:</span>
        <span class="hljs-string">"""
        :type A: int
        :type B: int
        :type C: int
        :type D: int
        :type E: int
        :type F: int
        :type G: int
        :type H: int
        :rtype: int
        """</span>
        left = max(A,E)
        right = max(min(C,G),left)
        bottom = max(B,F)
        top = max(min(D,H),bottom)
        <span class="hljs-keyword">return</span> (D-B)*(C-A)+(G-E)*(H-F)-(right-left)*(top-bottom)
</code></pre><h5 id="654-maximumbinary-tree"><a name="654-maximumbinary-tree" href="#654-maximumbinary-tree"></a>654 Maximumbinary Tree</h5><p>给定数组，按照指定规则构建二叉树。最大为root，左右遍历root元素左右的。</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;># Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution(object):
    def constructMaximumBinaryTree(self, nums):
        &quot;&quot;&quot;
        :type nums: List[int]
        :rtype: TreeNode
        &quot;&quot;&quot;
        if len(nums) == 0:
            return None
        maxv = max(nums)
        inx = nums.index(maxv)
        tmp = TreeNode(maxv)
        tmp.left = self.constructMaximumBinaryTree(nums[0:inx])
        tmp.right = self.constructMaximumBinaryTree(nums[inx+1:])
        return tmp
</code></pre>"><span class="hljs-comment"># Definition for a binary tree node.</span>
<span class="hljs-comment"># class TreeNode(object):</span>
<span class="hljs-comment">#     def __init__(self, x):</span>
<span class="hljs-comment">#         self.val = x</span>
<span class="hljs-comment">#         self.left = None</span>
<span class="hljs-comment">#         self.right = None</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">constructMaximumBinaryTree</span><span class="hljs-params">(self, nums)</span>:</span>
        <span class="hljs-string">"""
        :type nums: List[int]
        :rtype: TreeNode
        """</span>
        <span class="hljs-keyword">if</span> len(nums) == <span class="hljs-number">0</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">None</span>
        maxv = max(nums)
        inx = nums.index(maxv)
        tmp = TreeNode(maxv)
        tmp.left = self.constructMaximumBinaryTree(nums[<span class="hljs-number">0</span>:inx])
        tmp.right = self.constructMaximumBinaryTree(nums[inx+<span class="hljs-number">1</span>:])
        <span class="hljs-keyword">return</span> tmp
</code></pre><h5 id="198-lowest-common-rob"><a name="198-lowest-common-rob" href="#198-lowest-common-rob"></a>198 lowest common rob</h5><p>一列房子有钱，不能偷两个挨着的，问最多偷多少钱。<br>dp。dp[k] = max(max(dp[0:k-2])+nums[k],nums[k])</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>class Solution(object):
    def rob(self, nums):
        &quot;&quot;&quot;
        :type nums: List[int]
        :rtype: int
        &quot;&quot;&quot;
        if len(nums)==0:
            return 0
        if len(nums) ==1:
            return nums[0]
        maxv = 0
        dp = [0 for _ in range(len(nums))]
        dp[0] = nums[0]
        dp[1] = nums[1]
        for i in range(2,len(nums)):
            dp[i] = max(max(dp[0:i-1])+nums[i],nums[i])
        #print(dp)
        return max(dp)
</code></pre>"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">rob</span><span class="hljs-params">(self, nums)</span>:</span>
        <span class="hljs-string">"""
        :type nums: List[int]
        :rtype: int
        """</span>
        <span class="hljs-keyword">if</span> len(nums)==<span class="hljs-number">0</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>
        <span class="hljs-keyword">if</span> len(nums) ==<span class="hljs-number">1</span>:
            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>]
        maxv = <span class="hljs-number">0</span>
        dp = [<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(len(nums))]
        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>]
        dp[<span class="hljs-number">1</span>] = nums[<span class="hljs-number">1</span>]
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>,len(nums)):
            dp[i] = max(max(dp[<span class="hljs-number">0</span>:i-<span class="hljs-number">1</span>])+nums[i],nums[i])
        <span class="hljs-comment">#print(dp)</span>
        <span class="hljs-keyword">return</span> max(dp)
</code></pre><h5 id="235-lowest-common-ancestor-of-bst"><a name="235-lowest-common-ancestor-of-bst" href="#235-lowest-common-ancestor-of-bst"></a>235 lowest common ancestor of BST</h5><p>给定一个BST中的root，q，p，求q和p的最近的父节点。<br>一开始忘记了BST这个条件，实际上根据BST的特点可以轻易的递归求解。</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;># Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution(object):
    def lowestCommonAncestor(self, root, p, q):
        &quot;&quot;&quot;
        :type root: TreeNode
        :type p: TreeNode
        :type q: TreeNode
        :rtype: TreeNode
        &quot;&quot;&quot;
        little = min(p.val,q.val)
        big = max(p.val,q.val)
        if little &amp;lt;=root.val and big&amp;gt;=root.val:
            return root
        if big&amp;lt;root.val:
            return self.lowestCommonAncestor(root.left,p,q)
        if little&amp;gt;root.val:
            return self.lowestCommonAncestor(root.right,p,q)
</code></pre>"><span class="hljs-comment"># Definition for a binary tree node.</span>
<span class="hljs-comment"># class TreeNode(object):</span>
<span class="hljs-comment">#     def __init__(self, x):</span>
<span class="hljs-comment">#         self.val = x</span>
<span class="hljs-comment">#         self.left = None</span>
<span class="hljs-comment">#         self.right = None</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(self, root, p, q)</span>:</span>
        <span class="hljs-string">"""
        :type root: TreeNode
        :type p: TreeNode
        :type q: TreeNode
        :rtype: TreeNode
        """</span>
        little = min(p.val,q.val)
        big = max(p.val,q.val)
        <span class="hljs-keyword">if</span> little &lt;=root.val <span class="hljs-keyword">and</span> big&gt;=root.val:
            <span class="hljs-keyword">return</span> root
        <span class="hljs-keyword">if</span> big&lt;root.val:
            <span class="hljs-keyword">return</span> self.lowestCommonAncestor(root.left,p,q)
        <span class="hljs-keyword">if</span> little&gt;root.val:
            <span class="hljs-keyword">return</span> self.lowestCommonAncestor(root.right,p,q)
</code></pre><h5 id="553-optimal-division"><a name="553-optimal-division" href="#553-optimal-division"></a>553 optimal division</h5><p>给定一个数字数组，向里面加‘/’和‘（）’，以使得结果最大。<br>很容易想到肯定是第一个数作为被除数，后面的挨个除起来作为除数这样的。按照相应格式写即可。</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>class Solution(object):
    def optimalDivision(self, nums):
        &quot;&quot;&quot;
        :type nums: List[int]
        :rtype: str
        &quot;&quot;&quot;
        if len(nums)==1:
            return str(nums[0])
        if len(nums)==2:
            return str(nums[0])+'/'+str(nums[1])
        strs = ''
        strs = strs+str(nums[0])+'/('
        for i in range(1,len(nums)-1):
            strs = strs+str(nums[i])+'/'
        strs = strs+str(nums[-1])+')'
        return strs
</code></pre>"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">optimalDivision</span><span class="hljs-params">(self, nums)</span>:</span>
        <span class="hljs-string">"""
        :type nums: List[int]
        :rtype: str
        """</span>
        <span class="hljs-keyword">if</span> len(nums)==<span class="hljs-number">1</span>:
            <span class="hljs-keyword">return</span> str(nums[<span class="hljs-number">0</span>])
        <span class="hljs-keyword">if</span> len(nums)==<span class="hljs-number">2</span>:
            <span class="hljs-keyword">return</span> str(nums[<span class="hljs-number">0</span>])+<span class="hljs-string">'/'</span>+str(nums[<span class="hljs-number">1</span>])
        strs = <span class="hljs-string">''</span>
        strs = strs+str(nums[<span class="hljs-number">0</span>])+<span class="hljs-string">'/('</span>
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>,len(nums)-<span class="hljs-number">1</span>):
            strs = strs+str(nums[i])+<span class="hljs-string">'/'</span>
        strs = strs+str(nums[-<span class="hljs-number">1</span>])+<span class="hljs-string">')'</span>
        <span class="hljs-keyword">return</span> strs
</code></pre><h5 id="479-largest-palindrome-product"><a name="479-largest-palindrome-product" href="#479-largest-palindrome-product"></a>479 largest palindrome product</h5><p>这个题目比较难，求两个n位数的乘积是回文的，最大。思路的话直接贴上网上看的。</p><pre><code data-origin="<pre><code>Hi there! I am sharing my solution. My idea is strightforward. First off, let's pay attention on some facts. Let's consider maximum number with n digits. Of course that is the number consisting only of digit 9 (999..9). Let's denote that number max, and consider max*max.

It is obvious that any number which is product of two n digit numbers is less than or equal to max*max.
Maximum possible length of the product is 2*n.
If we partition palindrome number into two equal halves, then left half must be equals to the reverse of the right half.
Well, how to find the largest possible palindrome number? Answer: If max*max is palindrome itself, then that is the largest possible palindrome. Otherwise partition it into two equal(by length) halves. If left half is less than, or equals to the right half, then the largest palindrome number is concatenation of left part and reversed left part. Otherwise decrement left part, then find the largest palindrome as concatenation of left and reverse of it. Can we find next palindrome? Answer: yes. It is enough to repeat the latter operation, to obtain next largest palindrome. For example for input n = 2, max*max = 99*99 = 9801. So left half (further just left) is 98 and right half (further just right) is 01. 98&amp;gt;1, it mean largest palindrome is 9779. But it is not answer for our problem. Because this number is not product of two numbers with 2 digits. Well, to get valid palindromic number, we need to traverse all the palindromic numbers and check whether that number is a product of two numbers with n digits. To get the largest palindromic number, we have to approach the palindromic numbers greedily. It means, we need to traverse them from the largest to the smallest. Once we have found a palindrome, which is product of two n digital numbers return that number by mod 1337. That's all with the idea.
Note the following points in implementation:

To optimally validate a palindrome number, (i.e whether it is product of two n digital numbers) use greedy approach. In other words, start from largest possible number until the number is greater than its pair. Because it prevents you from considering duplicate pairs. For instance, if a&amp;gt;b and a*b = pal, then no need to consider b*a = pal. It saves huge amount of time. Cope example:
       for(int i = max;i&amp;gt;pro/i;i--){
               if(pro%i == 0 ) {
                   return (int)(pro%m);
               }
        }
Do not forget to assign palindrome number ( pro in my case, which stands for product) long datatype. Because maximum possible palindrome consists of 16 digits, which is greater than Integer.MAX_VALUE.
To sum up, I think this problem is NOT an EASY one. It would be better to tag it as MEDIUM.
</code></pre>">Hi there! I am sharing my solution. My idea is strightforward. First off, let's pay attention on some facts. Let's consider maximum number with n digits. Of course that is the number consisting only of digit 9 (999..9). Let's denote that number max, and consider max*max.

It is obvious that any number which is product of two n digit numbers is less than or equal to max*max.
Maximum possible length of the product is 2*n.
If we partition palindrome number into two equal halves, then left half must be equals to the reverse of the right half.
Well, how to find the largest possible palindrome number? Answer: If max*max is palindrome itself, then that is the largest possible palindrome. Otherwise partition it into two equal(by length) halves. If left half is less than, or equals to the right half, then the largest palindrome number is concatenation of left part and reversed left part. Otherwise decrement left part, then find the largest palindrome as concatenation of left and reverse of it. Can we find next palindrome? Answer: yes. It is enough to repeat the latter operation, to obtain next largest palindrome. For example for input n = 2, max*max = 99*99 = 9801. So left half (further just left) is 98 and right half (further just right) is 01. 98&gt;1, it mean largest palindrome is 9779. But it is not answer for our problem. Because this number is not product of two numbers with 2 digits. Well, to get valid palindromic number, we need to traverse all the palindromic numbers and check whether that number is a product of two numbers with n digits. To get the largest palindromic number, we have to approach the palindromic numbers greedily. It means, we need to traverse them from the largest to the smallest. Once we have found a palindrome, which is product of two n digital numbers return that number by mod 1337. That's all with the idea.
Note the following points in implementation:

To optimally validate a palindrome number, (i.e whether it is product of two n digital numbers) use greedy approach. In other words, start from largest possible number until the number is greater than its pair. Because it prevents you from considering duplicate pairs. For instance, if a&gt;b and a*b = pal, then no need to consider b*a = pal. It saves huge amount of time. Cope example:
       for(int i = max;i&gt;pro/i;i--){
               if(pro%i == 0 ) {
                   return (int)(pro%m);
               }
        }
Do not forget to assign palindrome number ( pro in my case, which stands for product) long datatype. Because maximum possible palindrome consists of 16 digits, which is greater than Integer.MAX_VALUE.
To sum up, I think this problem is NOT an EASY one. It would be better to tag it as MEDIUM.
</code></pre><pre class="java hljs"><code class="java" data-origin="<pre><code class=&quot;java&quot;>public class Solution {
    public int largestPalindrome(int n) {
        if(n == 1) return 9;
        int m = 1337;
        int mod = (int)Math.pow(10, n);
        int max = (int)Math.pow(10, n)-1;
        long pro = (long)max*(long)max;
        int right = (int)(pro%mod);
        int left = (int)(pro/mod);
        if(left == reverse(right,n)) return (int)(pro%m);
        if(left &amp;gt; right) {left--;}
        pro = (long)left*(long)mod+(long)reverse(left,n);
        while(left != mod/10){
            for(int i = max;i&amp;gt;pro/i;i--){
                if(pro%i == 0 ) {
                    return (int)(pro%m);
                }
            }
            left--;
            pro = (long)left*(long)mod+(long)reverse(left,n);
        }

        return (int)(pro%m);
    }

    private int reverse(int n, int dig){
        int x = n;
        int res = 0;
        int ten = (int)Math.pow(10,dig-1);
        while(x != 0 ){
            int d = x%10;
            res+=ten*d;
            ten/=10;
            x/=10;
        }
        return res;
    }

}
</code></pre>"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">largestPalindrome</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>{
        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">9</span>;
        <span class="hljs-keyword">int</span> m = <span class="hljs-number">1337</span>;
        <span class="hljs-keyword">int</span> mod = (<span class="hljs-keyword">int</span>)Math.pow(<span class="hljs-number">10</span>, n);
        <span class="hljs-keyword">int</span> max = (<span class="hljs-keyword">int</span>)Math.pow(<span class="hljs-number">10</span>, n)-<span class="hljs-number">1</span>;
        <span class="hljs-keyword">long</span> pro = (<span class="hljs-keyword">long</span>)max*(<span class="hljs-keyword">long</span>)max;
        <span class="hljs-keyword">int</span> right = (<span class="hljs-keyword">int</span>)(pro%mod);
        <span class="hljs-keyword">int</span> left = (<span class="hljs-keyword">int</span>)(pro/mod);
        <span class="hljs-keyword">if</span>(left == reverse(right,n)) <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>)(pro%m);
        <span class="hljs-keyword">if</span>(left &gt; right) {left--;}
        pro = (<span class="hljs-keyword">long</span>)left*(<span class="hljs-keyword">long</span>)mod+(<span class="hljs-keyword">long</span>)reverse(left,n);
        <span class="hljs-keyword">while</span>(left != mod/<span class="hljs-number">10</span>){
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = max;i&gt;pro/i;i--){
                <span class="hljs-keyword">if</span>(pro%i == <span class="hljs-number">0</span> ) {
                    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>)(pro%m);
                }
            }
            left--;
            pro = (<span class="hljs-keyword">long</span>)left*(<span class="hljs-keyword">long</span>)mod+(<span class="hljs-keyword">long</span>)reverse(left,n);
        }

        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>)(pro%m);
    }

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">reverse</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> dig)</span></span>{
        <span class="hljs-keyword">int</span> x = n;
        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> ten = (<span class="hljs-keyword">int</span>)Math.pow(<span class="hljs-number">10</span>,dig-<span class="hljs-number">1</span>);
        <span class="hljs-keyword">while</span>(x != <span class="hljs-number">0</span> ){
            <span class="hljs-keyword">int</span> d = x%<span class="hljs-number">10</span>;
            res+=ten*d;
            ten/=<span class="hljs-number">10</span>;
            x/=<span class="hljs-number">10</span>;
        }
        <span class="hljs-keyword">return</span> res;
    }

}
</code></pre><h5 id="58-length-word"><a name="58-length-word" href="#58-length-word"></a>58 length word</h5><p>这个题有什么意义。。。<br>给一个字符串，求最后一个单词长度。</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>class Solution(object):
    def lengthOfLastWord(self, s):
        &quot;&quot;&quot;
        :type s: str
        :rtype: int
        &quot;&quot;&quot;
        words = s.split()
        if len(words) &amp;lt;=0:
            return 0
        return len(words[-1])
</code></pre>"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">lengthOfLastWord</span><span class="hljs-params">(self, s)</span>:</span>
        <span class="hljs-string">"""
        :type s: str
        :rtype: int
        """</span>
        words = s.split()
        <span class="hljs-keyword">if</span> len(words) &lt;=<span class="hljs-number">0</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>
        <span class="hljs-keyword">return</span> len(words[-<span class="hljs-number">1</span>])
</code></pre><h5 id="345-reverse-vowels-of-a-string"><a name="345-reverse-vowels-of-a-string" href="#345-reverse-vowels-of-a-string"></a>345 reverse vowels of a string</h5><p>将一个单词串里的元音字母反转即可。</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>class Solution(object):
    def reverseVowels(self, s):
        &quot;&quot;&quot;
        :type s: str
        :rtype: str
        &quot;&quot;&quot;
        yy = ''
        inx = []
        s=list(s)
        for i in range(len(s)):
            if s[i] in 'aeiouAEIOU':
                inx.append(i)
                yy = yy+s[i]
        yy = yy[::-1]

        for i in range(len(inx)):
            s[inx[i]] = yy[i]
        return ''.join(s)
</code></pre>"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reverseVowels</span><span class="hljs-params">(self, s)</span>:</span>
        <span class="hljs-string">"""
        :type s: str
        :rtype: str
        """</span>
        yy = <span class="hljs-string">''</span>
        inx = []
        s=list(s)
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(s)):
            <span class="hljs-keyword">if</span> s[i] <span class="hljs-keyword">in</span> <span class="hljs-string">'aeiouAEIOU'</span>:
                inx.append(i)
                yy = yy+s[i]
        yy = yy[::-<span class="hljs-number">1</span>]

        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(inx)):
            s[inx[i]] = yy[i]
        <span class="hljs-keyword">return</span> <span class="hljs-string">''</span>.join(s)
</code></pre><h5 id="1-two-sum"><a name="1-two-sum" href="#1-two-sum"></a>1 two sum</h5><p>很简单的题目，有个需要注意的地方就是有可能会有重复元素这样。</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>class Solution(object):
    def twoSum(self, nums, target):
        &quot;&quot;&quot;
        :type nums: List[int]
        :type target: int
        :rtype: List[int]
        &quot;&quot;&quot;
        d = {}
        for inx,i in enumerate(nums):
            if i in d:
                tmp = d[i]
                tmp.append(inx)
                d[i] = tmp
            else:
                d[i] = [inx]
        #print(d)
        for i in range(len(nums)):
            if target-nums[i] in d:
                if len(d[target-nums[i]])==2:
                    return d[target-nums[i]]
                else:
                    if d[target-nums[i]][0]!=i:
                        return [i,d[target-nums[i]][0]]
</code></pre>"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">twoSum</span><span class="hljs-params">(self, nums, target)</span>:</span>
        <span class="hljs-string">"""
        :type nums: List[int]
        :type target: int
        :rtype: List[int]
        """</span>
        d = {}
        <span class="hljs-keyword">for</span> inx,i <span class="hljs-keyword">in</span> enumerate(nums):
            <span class="hljs-keyword">if</span> i <span class="hljs-keyword">in</span> d:
                tmp = d[i]
                tmp.append(inx)
                d[i] = tmp
            <span class="hljs-keyword">else</span>:
                d[i] = [inx]
        <span class="hljs-comment">#print(d)</span>
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(nums)):
            <span class="hljs-keyword">if</span> target-nums[i] <span class="hljs-keyword">in</span> d:
                <span class="hljs-keyword">if</span> len(d[target-nums[i]])==<span class="hljs-number">2</span>:
                    <span class="hljs-keyword">return</span> d[target-nums[i]]
                <span class="hljs-keyword">else</span>:
                    <span class="hljs-keyword">if</span> d[target-nums[i]][<span class="hljs-number">0</span>]!=i:
                        <span class="hljs-keyword">return</span> [i,d[target-nums[i]][<span class="hljs-number">0</span>]]
</code></pre><h5 id="331-verify-preorder-serialization-of-binary-tree"><a name="331-verify-preorder-serialization-of-binary-tree" href="#331-verify-preorder-serialization-of-binary-tree"></a>331 Verify Preorder Serialization of Binary Tree</h5><p>给定一个二叉树的前序遍历结果，空的以‘#’代替，那么判断这个序列能否组成合理的二叉。<br>这个题目有些难想到方法。因为是二叉树结构，一般使用递归或者栈结构，这个题目递归不太好想，那么使用栈存储下遍历到的元素，当碰到两个连续的‘#’代表碰到叶子节点那么将该叶子节点pop出去并且将其以‘#’代替。这样遍历完后如果最后剩下的是‘#’则正确（即剩下root节点）。当然如果遍历过程中栈就空了代表也是错误的。</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>class Solution(object):
    def isValidSerialization(self, preorder):
        &quot;&quot;&quot;
        :type preorder: str
        :rtype: bool
        &quot;&quot;&quot;
        stack = []
        top = -1
        preorder = preorder.split(',')
        for i in preorder:
            stack.append(i)
            top = top+1
            while(self.endtwox(stack)):
                stack.pop()
                top = top -1
                stack.pop()
                top = top -1
                if top&amp;lt;0:
                    return False
                stack.pop()
                stack.append('#')
        if len(stack)==1:
            if stack[0]=='#':
                return True
        return False
    def endtwox(self,stack):
        if len(stack)&amp;lt;=1:
            return False
        if stack[-1]=='#' and stack[-2]=='#':
            return True
</code></pre>"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isValidSerialization</span><span class="hljs-params">(self, preorder)</span>:</span>
        <span class="hljs-string">"""
        :type preorder: str
        :rtype: bool
        """</span>
        stack = []
        top = -<span class="hljs-number">1</span>
        preorder = preorder.split(<span class="hljs-string">','</span>)
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> preorder:
            stack.append(i)
            top = top+<span class="hljs-number">1</span>
            <span class="hljs-keyword">while</span>(self.endtwox(stack)):
                stack.pop()
                top = top -<span class="hljs-number">1</span>
                stack.pop()
                top = top -<span class="hljs-number">1</span>
                <span class="hljs-keyword">if</span> top&lt;<span class="hljs-number">0</span>:
                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">False</span>
                stack.pop()
                stack.append(<span class="hljs-string">'#'</span>)
        <span class="hljs-keyword">if</span> len(stack)==<span class="hljs-number">1</span>:
            <span class="hljs-keyword">if</span> stack[<span class="hljs-number">0</span>]==<span class="hljs-string">'#'</span>:
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">True</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">False</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">endtwox</span><span class="hljs-params">(self,stack)</span>:</span>
        <span class="hljs-keyword">if</span> len(stack)&lt;=<span class="hljs-number">1</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">False</span>
        <span class="hljs-keyword">if</span> stack[-<span class="hljs-number">1</span>]==<span class="hljs-string">'#'</span> <span class="hljs-keyword">and</span> stack[-<span class="hljs-number">2</span>]==<span class="hljs-string">'#'</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">True</span>
</code></pre><h5 id="461-haming-distance"><a name="461-haming-distance" href="#461-haming-distance"></a>461 haming distance</h5><p>给出两个整数求汉明距离。<br>python里有bin可以二进制转换，统计即可。</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>class Solution(object):
    def hammingDistance(self, x, y):
        &quot;&quot;&quot;
        :type x: int
        :type y: int
        :rtype: int
        &quot;&quot;&quot;
        str1 = bin(x)[2:]
        str2 = bin(y)[2:]
        res = 0
        minlen = min(len(str1),len(str2))
        for i in range(-1,-1*minlen-1,-1):
            if str1[i]!=str2[i]:
                res = res + 1
        maxlen = max(len(str1),len(str2))
        str1=list(str1[0:-1*minlen])
        str2 = list(str2[0:-1*minlen])
        print(str1,str2)
        sum1 = sum([int(i)for i in str1])
        sum2 = sum([int(j)for j in str2])
        return res+sum1+sum2
</code></pre>"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hammingDistance</span><span class="hljs-params">(self, x, y)</span>:</span>
        <span class="hljs-string">"""
        :type x: int
        :type y: int
        :rtype: int
        """</span>
        str1 = bin(x)[<span class="hljs-number">2</span>:]
        str2 = bin(y)[<span class="hljs-number">2</span>:]
        res = <span class="hljs-number">0</span>
        minlen = min(len(str1),len(str2))
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>*minlen-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>):
            <span class="hljs-keyword">if</span> str1[i]!=str2[i]:
                res = res + <span class="hljs-number">1</span>
        maxlen = max(len(str1),len(str2))
        str1=list(str1[<span class="hljs-number">0</span>:-<span class="hljs-number">1</span>*minlen])
        str2 = list(str2[<span class="hljs-number">0</span>:-<span class="hljs-number">1</span>*minlen])
        print(str1,str2)
        sum1 = sum([int(i)<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> str1])
        sum2 = sum([int(j)<span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> str2])
        <span class="hljs-keyword">return</span> res+sum1+sum2
</code></pre><h5 id="534-diameter-of-binary-tree"><a name="534-diameter-of-binary-tree" href="#534-diameter-of-binary-tree"></a>534 Diameter of Binary Tree</h5><p>给定一颗二叉树求里面的最长路径。<br>没想到什么特别好的办法，两轮循环吧，第一轮循环每个点求每个点左右的最深路径长度之和，第二层就是根据一个点求这个点上的最长路径。</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;># Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution(object):
    def diedaidepth(self,root):
        res = 0
        if root==None:
            res = 0
        else:
            res = 1+max(self.diedaidepth(root.left),self.diedaidepth(root.right))
        return res
    def diedaipath(self,root,tmp):
        if root==None:
            return
        else:
            tmp.append(self.diedaidepth(root.left)+self.diedaidepth(root.right))
            self.diedaipath(root.left,tmp)
            self.diedaipath(root.right,tmp)
    def diameterOfBinaryTree(self, root):
        &quot;&quot;&quot;
        :type root: TreeNode
        :rtype: int
        &quot;&quot;&quot;
        if root==None:
            return 0
        res = []
        self.diedaipath(root,res)
        print(res)
        return max(res)
</code></pre>"><span class="hljs-comment"># Definition for a binary tree node.</span>
<span class="hljs-comment"># class TreeNode(object):</span>
<span class="hljs-comment">#     def __init__(self, x):</span>
<span class="hljs-comment">#         self.val = x</span>
<span class="hljs-comment">#         self.left = None</span>
<span class="hljs-comment">#         self.right = None</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">diedaidepth</span><span class="hljs-params">(self,root)</span>:</span>
        res = <span class="hljs-number">0</span>
        <span class="hljs-keyword">if</span> root==<span class="hljs-keyword">None</span>:
            res = <span class="hljs-number">0</span>
        <span class="hljs-keyword">else</span>:
            res = <span class="hljs-number">1</span>+max(self.diedaidepth(root.left),self.diedaidepth(root.right))
        <span class="hljs-keyword">return</span> res
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">diedaipath</span><span class="hljs-params">(self,root,tmp)</span>:</span>
        <span class="hljs-keyword">if</span> root==<span class="hljs-keyword">None</span>:
            <span class="hljs-keyword">return</span>
        <span class="hljs-keyword">else</span>:
            tmp.append(self.diedaidepth(root.left)+self.diedaidepth(root.right))
            self.diedaipath(root.left,tmp)
            self.diedaipath(root.right,tmp)
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">diameterOfBinaryTree</span><span class="hljs-params">(self, root)</span>:</span>
        <span class="hljs-string">"""
        :type root: TreeNode
        :rtype: int
        """</span>
        <span class="hljs-keyword">if</span> root==<span class="hljs-keyword">None</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>
        res = []
        self.diedaipath(root,res)
        print(res)
        <span class="hljs-keyword">return</span> max(res)
</code></pre><h5 id="105-construct-binarytree-for-inorder-and-preorder"><a name="105-construct-binarytree-for-inorder-and-preorder" href="#105-construct-binarytree-for-inorder-and-preorder"></a>105 construct binarytree for inorder and preorder</h5><p>从前序和中序遍历构建二叉树。就是递归构建即可。递归的过程中需要记录下当前在的前序遍历中的坐标，并且还需要额外判断左右分支为空后的处理。</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;># Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution(object):
    def diedai(self,pre,ino,inx):
        root = TreeNode(ino[inx[0]])
        medinx = pre.index(ino[inx[0]])
        tmpleft = pre[0:medinx]
        if len(tmpleft)&amp;gt;=1:
            inx[0] = inx[0]+1
            root.left = self.diedai(pre[0:medinx],ino,inx)
        else:
            root.left = None
        tmpright = pre[medinx+1:]
        if len(tmpright)&amp;gt;=1:
            inx[0] = inx[0]+1
            root.right = self.diedai(pre[medinx+1:],ino,inx)
        else:
            root.right = None
        return root
    def buildTree(self, preorder, inorder):
        &quot;&quot;&quot;
        :type preorder: List[int]
        :type inorder: List[int]
        :rtype: TreeNode
        &quot;&quot;&quot;
        if len(preorder)==0:
            return None
        root = self.diedai(inorder,preorder,[0])
        return root
</code></pre>"><span class="hljs-comment"># Definition for a binary tree node.</span>
<span class="hljs-comment"># class TreeNode(object):</span>
<span class="hljs-comment">#     def __init__(self, x):</span>
<span class="hljs-comment">#         self.val = x</span>
<span class="hljs-comment">#         self.left = None</span>
<span class="hljs-comment">#         self.right = None</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">diedai</span><span class="hljs-params">(self,pre,ino,inx)</span>:</span>
        root = TreeNode(ino[inx[<span class="hljs-number">0</span>]])
        medinx = pre.index(ino[inx[<span class="hljs-number">0</span>]])
        tmpleft = pre[<span class="hljs-number">0</span>:medinx]
        <span class="hljs-keyword">if</span> len(tmpleft)&gt;=<span class="hljs-number">1</span>:
            inx[<span class="hljs-number">0</span>] = inx[<span class="hljs-number">0</span>]+<span class="hljs-number">1</span>
            root.left = self.diedai(pre[<span class="hljs-number">0</span>:medinx],ino,inx)
        <span class="hljs-keyword">else</span>:
            root.left = <span class="hljs-keyword">None</span>
        tmpright = pre[medinx+<span class="hljs-number">1</span>:]
        <span class="hljs-keyword">if</span> len(tmpright)&gt;=<span class="hljs-number">1</span>:
            inx[<span class="hljs-number">0</span>] = inx[<span class="hljs-number">0</span>]+<span class="hljs-number">1</span>
            root.right = self.diedai(pre[medinx+<span class="hljs-number">1</span>:],ino,inx)
        <span class="hljs-keyword">else</span>:
            root.right = <span class="hljs-keyword">None</span>
        <span class="hljs-keyword">return</span> root
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">buildTree</span><span class="hljs-params">(self, preorder, inorder)</span>:</span>
        <span class="hljs-string">"""
        :type preorder: List[int]
        :type inorder: List[int]
        :rtype: TreeNode
        """</span>
        <span class="hljs-keyword">if</span> len(preorder)==<span class="hljs-number">0</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">None</span>
        root = self.diedai(inorder,preorder,[<span class="hljs-number">0</span>])
        <span class="hljs-keyword">return</span> root
</code></pre><h5 id="118-pasical-rectangle"><a name="118-pasical-rectangle" href="#118-pasical-rectangle"></a>118 pasical rectangle</h5><p>给出n，求杨慧三角前n行。<br>直接求即可，和求单行一样，假装在前一行两侧加上0后进行遍历求和即可。</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>class Solution(object):
    def generate(self, numRows):
        &quot;&quot;&quot;
        :type numRows: int
        :rtype: List[List[int]]
        &quot;&quot;&quot;
        if numRows==0:
            return []
        res = [[1]]
        for i in range(1,numRows):
            tmp = [0]+res[i-1]+[0]
            tmp1 = [tmp[j]+tmp[j+1] for j in range(i+1)]
            res.append(tmp1)
        return res
</code></pre>"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">generate</span><span class="hljs-params">(self, numRows)</span>:</span>
        <span class="hljs-string">"""
        :type numRows: int
        :rtype: List[List[int]]
        """</span>
        <span class="hljs-keyword">if</span> numRows==<span class="hljs-number">0</span>:
            <span class="hljs-keyword">return</span> []
        res = [[<span class="hljs-number">1</span>]]
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>,numRows):
            tmp = [<span class="hljs-number">0</span>]+res[i-<span class="hljs-number">1</span>]+[<span class="hljs-number">0</span>]
            tmp1 = [tmp[j]+tmp[j+<span class="hljs-number">1</span>] <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(i+<span class="hljs-number">1</span>)]
            res.append(tmp1)
        <span class="hljs-keyword">return</span> res
</code></pre><h5 id="26-remove-duplicates-from-sorted-array"><a name="26-remove-duplicates-from-sorted-array" href="#26-remove-duplicates-from-sorted-array"></a>26 remove duplicates from sorted array</h5><p>原地去除已经排序列表里的重复元素。这个因为已经排好顺序了，所以不妨把数组前半部分当成是栈，然后记录下当前栈顶和栈顶元素，对于后面的元素判断是否相同来入栈，这样就可以了。最后栈顶就是长度。</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>class Solution(object):
    def removeDuplicates(self, nums):
        &quot;&quot;&quot;
        :type nums: List[int]
        :rtype: int
        &quot;&quot;&quot;
        if len(nums)==0:
            return 0
        now = nums[0]
        n = len(nums)
        top = nums[0]
        topinx = 1
        for i in range(1,n):
            if nums[i]!=top:
                nums[topinx] = nums[i]
                top = nums[topinx]
                topinx = topinx + 1
        #print(nums)
        return topinx
</code></pre>"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(self, nums)</span>:</span>
        <span class="hljs-string">"""
        :type nums: List[int]
        :rtype: int
        """</span>
        <span class="hljs-keyword">if</span> len(nums)==<span class="hljs-number">0</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>
        now = nums[<span class="hljs-number">0</span>]
        n = len(nums)
        top = nums[<span class="hljs-number">0</span>]
        topinx = <span class="hljs-number">1</span>
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>,n):
            <span class="hljs-keyword">if</span> nums[i]!=top:
                nums[topinx] = nums[i]
                top = nums[topinx]
                topinx = topinx + <span class="hljs-number">1</span>
        <span class="hljs-comment">#print(nums)</span>
        <span class="hljs-keyword">return</span> topinx
</code></pre><h5 id="6-zigzag-apttern"><a name="6-zigzag-apttern" href="#6-zigzag-apttern"></a>6 zigzag apttern</h5><p>给定一个字符串，求其以zigzag方式排列后按每行读取后的结果。<br>一开始是想着按照zigzag的方式而后重组出zigzag后的结果，但是在最后几个样例上一直无法通过。可见有更简单的方法。<br>观察后可以看到对于原字符串来说是被分配到n行字符串里去了，并且每个字符被分配到第几行其实是可以计算出来的，首先取几个字符串作为放入的桶，而后对每个字符求其应该在第几个桶里，分别是向下走和向上走。就是这样。</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>class Solution(object):
    def convert(self, s, numRows):
        &quot;&quot;&quot;
        :type s: str
        :type numRows: int
        :rtype: str
        &quot;&quot;&quot;
        if numRows == 1 or numRows &amp;gt;= len(s):
            return s

        L = [''] * numRows
        index, step = 0, 1

        for x in s:
            L[index] += x
            if index == 0:
                step = 1
            elif index == numRows -1:
                step = -1
            index += step

        return ''.join(L)
</code></pre>"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">convert</span><span class="hljs-params">(self, s, numRows)</span>:</span>
        <span class="hljs-string">"""
        :type s: str
        :type numRows: int
        :rtype: str
        """</span>
        <span class="hljs-keyword">if</span> numRows == <span class="hljs-number">1</span> <span class="hljs-keyword">or</span> numRows &gt;= len(s):
            <span class="hljs-keyword">return</span> s

        L = [<span class="hljs-string">''</span>] * numRows
        index, step = <span class="hljs-number">0</span>, <span class="hljs-number">1</span>

        <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> s:
            L[index] += x
            <span class="hljs-keyword">if</span> index == <span class="hljs-number">0</span>:
                step = <span class="hljs-number">1</span>
            <span class="hljs-keyword">elif</span> index == numRows -<span class="hljs-number">1</span>:
                step = -<span class="hljs-number">1</span>
            index += step

        <span class="hljs-keyword">return</span> <span class="hljs-string">''</span>.join(L)
</code></pre><h5 id="395-longest-substring-with-at-least-k-repeating-characters"><a name="395-longest-substring-with-at-least-k-repeating-characters" href="#395-longest-substring-with-at-least-k-repeating-characters"></a>395 longest substring with at least k repeating characters</h5><p>给定一个字符串，要求一个子串使得里面每个元素都出现次数不少于k次。<br>开始时想到了使用分治法，但是还是习惯性的认为是二分思维，导致卡住了不知道如何求解。后来想到，其实要求出现次数不低于k次，那么，对于一个字符串来说，如果在整个串里面出现次数小于k，那么相当于最后结果里肯定不能包含这个字符。所以相当于这里分治法的小集合是以这个字符分治后的结果。那么我们就依照这个来进行分治法递归即可。</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>class Solution(object):
    def longestSubstring(self, s, k):
        &quot;&quot;&quot;
        :type s: str
        :type k: int
        :rtype: int
        &quot;&quot;&quot;
        ss = set(s)
        for c in ss:
            if s.count(c)&amp;lt;k:
                return max(self.longestSubstring(i,k) for i in s.split(c))
        return len(s)
</code></pre>"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">longestSubstring</span><span class="hljs-params">(self, s, k)</span>:</span>
        <span class="hljs-string">"""
        :type s: str
        :type k: int
        :rtype: int
        """</span>
        ss = set(s)
        <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> ss:
            <span class="hljs-keyword">if</span> s.count(c)&lt;k:
                <span class="hljs-keyword">return</span> max(self.longestSubstring(i,k) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> s.split(c))
        <span class="hljs-keyword">return</span> len(s)
</code></pre><h5 id="575-distribute-candies"><a name="575-distribute-candies" href="#575-distribute-candies"></a>575 distribute candies</h5><p>各种不同样式的巧克力，一个数字代表一样，数字出现个数代表个数。平分给两人，要求其中一人能够拿到的最多种类。<br>这个它最多拿的种类自然是 所有种类数目 能够拿到数目 其中的最小值。</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>class Solution(object):
    def distributeCandies(self, candies):
        &quot;&quot;&quot;
        :type candies: List[int]
        :rtype: int
        &quot;&quot;&quot;
        count = len(candies)
        cset = set(candies)
        return min(len(cset),count/2)
</code></pre>"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">distributeCandies</span><span class="hljs-params">(self, candies)</span>:</span>
        <span class="hljs-string">"""
        :type candies: List[int]
        :rtype: int
        """</span>
        count = len(candies)
        cset = set(candies)
        <span class="hljs-keyword">return</span> min(len(cset),count/<span class="hljs-number">2</span>)
</code></pre><h5 id="312-burst-balloons"><a name="312-burst-balloons" href="#312-burst-balloons"></a>312 burst balloons</h5><p>给定一些气泡，要求最后全部扎破，扎破某个后会得到一定奖励，数目为左右和该气球值的乘积。<br>使用dp。分治法，但是确定哪个是第一个扎的后没法分治，所以想到常常逆向思维，也就是认为某个气球是最后扎破的。这样就可以将问题分为两个部分。左右各自加一个1，而后dp[i][j]表示i和j区间间的气球能够得到最大的奖励。coins = max(coins, nums[i] <em> nums[k] </em> nums[j] + calculate(i, k) + calculate(k, j))。这里选定第k个是最后扎破的则需要分治然后加上i<em>k</em>j，这个地方不太理解为什么。k是最后扎破的，那么两边能够从k得到的最大奖励也就是与之</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>class Solution(object):
    def maxCoins(self, nums):
        &quot;&quot;&quot;
        :type nums: List[int]
        :rtype: int
        &quot;&quot;&quot;
        nums = [1] + nums + [1]
        n = len(nums)
        dp = [[0] * n for _ in xrange(n)]

        def calculate(i, j):
            if dp[i][j] or j == i + 1: # in memory or gap &amp;lt; 2
                return dp[i][j]
            coins = 0
            for k in xrange(i+1, j): # find the last balloon
                coins = max(coins, nums[i] * nums[k] * nums[j] + calculate(i, k) + calculate(k, j))
            dp[i][j] = coins
            return coins

        return calculate(0, n-1)
</code></pre>"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maxCoins</span><span class="hljs-params">(self, nums)</span>:</span>
        <span class="hljs-string">"""
        :type nums: List[int]
        :rtype: int
        """</span>
        nums = [<span class="hljs-number">1</span>] + nums + [<span class="hljs-number">1</span>]
        n = len(nums)
        dp = [[<span class="hljs-number">0</span>] * n <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> xrange(n)]

        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">calculate</span><span class="hljs-params">(i, j)</span>:</span>
            <span class="hljs-keyword">if</span> dp[i][j] <span class="hljs-keyword">or</span> j == i + <span class="hljs-number">1</span>: <span class="hljs-comment"># in memory or gap &lt; 2</span>
                <span class="hljs-keyword">return</span> dp[i][j]
            coins = <span class="hljs-number">0</span>
            <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> xrange(i+<span class="hljs-number">1</span>, j): <span class="hljs-comment"># find the last balloon</span>
                coins = max(coins, nums[i] * nums[k] * nums[j] + calculate(i, k) + calculate(k, j))
            dp[i][j] = coins
            <span class="hljs-keyword">return</span> coins

        <span class="hljs-keyword">return</span> calculate(<span class="hljs-number">0</span>, n-<span class="hljs-number">1</span>)
</code></pre><h5 id="102bt层次遍历"><a name="102bt层次遍历" href="#102bt层次遍历"></a>102BT层次遍历</h5><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;># Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution(object):
    def dd(self,root,d,depth):
        if root==None:
            return
        if depth in d:
            tmp = d[depth]
            tmp.append(root.val)
            d[depth] = tmp
        else:
            d[depth] = [root.val]
        if root.left!=None:
            self.dd(root.left,d,depth+1)
        if root.right!=None:
            self.dd(root.right,d,depth+1)
    def levelOrder(self, root):
        &quot;&quot;&quot;
        :type root: TreeNode
        :rtype: List[List[int]]
        &quot;&quot;&quot;
        d = {}
        self.dd(root,d,0)
        print(d)
        res = []
        for i in range(len(d)):
            res.append(d[i])
        return res
</code></pre>"><span class="hljs-comment"># Definition for a binary tree node.</span>
<span class="hljs-comment"># class TreeNode(object):</span>
<span class="hljs-comment">#     def __init__(self, x):</span>
<span class="hljs-comment">#         self.val = x</span>
<span class="hljs-comment">#         self.left = None</span>
<span class="hljs-comment">#         self.right = None</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dd</span><span class="hljs-params">(self,root,d,depth)</span>:</span>
        <span class="hljs-keyword">if</span> root==<span class="hljs-keyword">None</span>:
            <span class="hljs-keyword">return</span>
        <span class="hljs-keyword">if</span> depth <span class="hljs-keyword">in</span> d:
            tmp = d[depth]
            tmp.append(root.val)
            d[depth] = tmp
        <span class="hljs-keyword">else</span>:
            d[depth] = [root.val]
        <span class="hljs-keyword">if</span> root.left!=<span class="hljs-keyword">None</span>:
            self.dd(root.left,d,depth+<span class="hljs-number">1</span>)
        <span class="hljs-keyword">if</span> root.right!=<span class="hljs-keyword">None</span>:
            self.dd(root.right,d,depth+<span class="hljs-number">1</span>)
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">levelOrder</span><span class="hljs-params">(self, root)</span>:</span>
        <span class="hljs-string">"""
        :type root: TreeNode
        :rtype: List[List[int]]
        """</span>
        d = {}
        self.dd(root,d,<span class="hljs-number">0</span>)
        print(d)
        res = []
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(d)):
            res.append(d[i])
        <span class="hljs-keyword">return</span> res
</code></pre><h5 id="260-single-number-3"><a name="260-single-number-3" href="#260-single-number-3"></a>260 single number 3</h5><p>一个数组，所有元素都出现了两次只有两个出现了一次，求这两个。<br>思路很容易想到，先一次亦或，确定下来以某一位为1的进行二次遍历即可。<br>有个公式记下 i&amp;~(i-1)可以用来快速求i中最低为1为最高位1其余全0的值。</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>class Solution(object):
    def singleNumber(self, nums):
        &quot;&quot;&quot;
        :type nums: List[int]
        :rtype: List[int]
        &quot;&quot;&quot;
        if len(nums)==0:
            return [0,0]
        if len(nums)==1:
            return [nums[0],0]
        res = nums[0]
        for i in range(1,len(nums)):
            res = res^nums[i]
        s = bin(res)
        if '1' not in s:
            return [0,0]
        r = res&amp;amp;~(res-1)
        num1 = 0
        num2 = 0
        for i in nums:
            if  i&amp;amp;r&amp;gt;0:
                num1 = num1^i
            else:
                num2 = num2^i
        return [num1,num2]
</code></pre>"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(self, nums)</span>:</span>
        <span class="hljs-string">"""
        :type nums: List[int]
        :rtype: List[int]
        """</span>
        <span class="hljs-keyword">if</span> len(nums)==<span class="hljs-number">0</span>:
            <span class="hljs-keyword">return</span> [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]
        <span class="hljs-keyword">if</span> len(nums)==<span class="hljs-number">1</span>:
            <span class="hljs-keyword">return</span> [nums[<span class="hljs-number">0</span>],<span class="hljs-number">0</span>]
        res = nums[<span class="hljs-number">0</span>]
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>,len(nums)):
            res = res^nums[i]
        s = bin(res)
        <span class="hljs-keyword">if</span> <span class="hljs-string">'1'</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> s:
            <span class="hljs-keyword">return</span> [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]
        r = res&amp;~(res-<span class="hljs-number">1</span>)
        num1 = <span class="hljs-number">0</span>
        num2 = <span class="hljs-number">0</span>
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> nums:
            <span class="hljs-keyword">if</span>  i&amp;r&gt;<span class="hljs-number">0</span>:
                num1 = num1^i
            <span class="hljs-keyword">else</span>:
                num2 = num2^i
        <span class="hljs-keyword">return</span> [num1,num2]
</code></pre><h5 id="397-integer-replacement"><a name="397-integer-replacement" href="#397-integer-replacement"></a>397 integer replacement</h5><p>给出一个数，如果是偶数可以除以2，奇数可以加1或者减一。问最少多少步到达1.<br>肯定是使用dp，不过我写的O(n)的算法是一步一步推，占用了较大的存储空间。而看别人答案，似乎还总结出一个更加厉害的公式，如下：<br>If n % 4 = 3 and n != 3, then f(n) = f(n + 1) + 1.<br>If n % 4 = 1 or n = 3, then f(n) = f(n - 1) + 1.<br>This gives us an O(log n) time, O(1) space solution.<br>根据这个公式和我的思路可以写出如下两种：</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>class Solution(object):
    def integerReplacement(self, n):
        &quot;&quot;&quot;
        :type n: int
        :rtype: int
        &quot;&quot;&quot;
        end = 0
        if n%2==0:
            end = n/2
        else:
            end = n/2+1
        dp = [0 for i in range(2*end+1)]#0--n
        dp[2]=1
        for j in range(2,end+1):
            now = j*2
            dp[now] = 1+dp[now/2]
            dp[now-1] = min(1+dp[now-2],1+dp[now])
        #print(dp)
        return dp[n]
    def integerReplacement(self, n):
        rtn = 0
        while n &amp;gt; 1:
            rtn += 1
            if n % 2 == 0:
                n //= 2
            elif n % 4 == 1 or n == 3:
                n -= 1
            else:
                n += 1
        return rtn
</code></pre>"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">integerReplacement</span><span class="hljs-params">(self, n)</span>:</span>
        <span class="hljs-string">"""
        :type n: int
        :rtype: int
        """</span>
        end = <span class="hljs-number">0</span>
        <span class="hljs-keyword">if</span> n%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>:
            end = n/<span class="hljs-number">2</span>
        <span class="hljs-keyword">else</span>:
            end = n/<span class="hljs-number">2</span>+<span class="hljs-number">1</span>
        dp = [<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>*end+<span class="hljs-number">1</span>)]<span class="hljs-comment">#0--n</span>
        dp[<span class="hljs-number">2</span>]=<span class="hljs-number">1</span>
        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>,end+<span class="hljs-number">1</span>):
            now = j*<span class="hljs-number">2</span>
            dp[now] = <span class="hljs-number">1</span>+dp[now/<span class="hljs-number">2</span>]
            dp[now-<span class="hljs-number">1</span>] = min(<span class="hljs-number">1</span>+dp[now-<span class="hljs-number">2</span>],<span class="hljs-number">1</span>+dp[now])
        <span class="hljs-comment">#print(dp)</span>
        <span class="hljs-keyword">return</span> dp[n]
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">integerReplacement</span><span class="hljs-params">(self, n)</span>:</span>
        rtn = <span class="hljs-number">0</span>
        <span class="hljs-keyword">while</span> n &gt; <span class="hljs-number">1</span>:
            rtn += <span class="hljs-number">1</span>
            <span class="hljs-keyword">if</span> n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>:
                n //= <span class="hljs-number">2</span>
            <span class="hljs-keyword">elif</span> n % <span class="hljs-number">4</span> == <span class="hljs-number">1</span> <span class="hljs-keyword">or</span> n == <span class="hljs-number">3</span>:
                n -= <span class="hljs-number">1</span>
            <span class="hljs-keyword">else</span>:
                n += <span class="hljs-number">1</span>
        <span class="hljs-keyword">return</span> rtn
</code></pre><h5 id="587凸包构建"><a name="587凸包构建" href="#587凸包构建"></a>587凸包构建</h5><p>凸包构建是一类算法，具体看印象笔记里的。</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;># Definition for a point.
# class Point(object):
#     def __init__(self, a=0, b=0):
#         self.x = a
#         self.y = b

class Solution(object):
    def outerTrees(self, points):
        A = points
        def sign(p, q, r):
            return cmp((p.x - r.x)*(q.y - r.y), (p.y - r.y)*(q.x - r.x))

        def drive(hull, r):
            hull.append(r)
            while len(hull) &amp;gt;= 3 and sign(*hull[-3:]) &amp;lt; 0:
                hull.pop(-2)
            return hull

        A.sort(key = lambda p: (p.x, p.y))
        lower = reduce(drive, A, [])
        upper = reduce(drive, A[::-1], [])
        return list(set(lower + upper))
</code></pre>"><span class="hljs-comment"># Definition for a point.</span>
<span class="hljs-comment"># class Point(object):</span>
<span class="hljs-comment">#     def __init__(self, a=0, b=0):</span>
<span class="hljs-comment">#         self.x = a</span>
<span class="hljs-comment">#         self.y = b</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">outerTrees</span><span class="hljs-params">(self, points)</span>:</span>
        A = points
        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sign</span><span class="hljs-params">(p, q, r)</span>:</span>
            <span class="hljs-keyword">return</span> cmp((p.x - r.x)*(q.y - r.y), (p.y - r.y)*(q.x - r.x))

        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">drive</span><span class="hljs-params">(hull, r)</span>:</span>
            hull.append(r)
            <span class="hljs-keyword">while</span> len(hull) &gt;= <span class="hljs-number">3</span> <span class="hljs-keyword">and</span> sign(*hull[-<span class="hljs-number">3</span>:]) &lt; <span class="hljs-number">0</span>:
                hull.pop(-<span class="hljs-number">2</span>)
            <span class="hljs-keyword">return</span> hull

        A.sort(key = <span class="hljs-keyword">lambda</span> p: (p.x, p.y))
        lower = reduce(drive, A, [])
        upper = reduce(drive, A[::-<span class="hljs-number">1</span>], [])
        <span class="hljs-keyword">return</span> list(set(lower + upper))
</code></pre><p>75 排序<br>快速排序</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>class Solution(object):
    def quick_sort(self,lists, left, right):
        # 快速排序
        if left &amp;gt;= right:
            return lists
        key = lists[left]
        low = left
        high = right
        while left &amp;lt; right:
            while left &amp;lt; right and lists[right] &amp;gt;= key:
                right -= 1
            lists[left] = lists[right]
            while left &amp;lt; right and lists[left] &amp;lt;= key:
                left += 1
            lists[right] = lists[left]
        lists[right] = key
        self.quick_sort(lists, low, left - 1)
        self.quick_sort(lists, left + 1, high)
        return lists
    def sortColors(self, nums):
        &quot;&quot;&quot;
        :type nums: List[int]
        :rtype: void Do not return anything, modify nums in-place instead.
        &quot;&quot;&quot;
        nums = self.quick_sort(nums,0,len(nums)-1)
</code></pre>"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(self,lists, left, right)</span>:</span>
        <span class="hljs-comment"># 快速排序</span>
        <span class="hljs-keyword">if</span> left &gt;= right:
            <span class="hljs-keyword">return</span> lists
        key = lists[left]
        low = left
        high = right
        <span class="hljs-keyword">while</span> left &lt; right:
            <span class="hljs-keyword">while</span> left &lt; right <span class="hljs-keyword">and</span> lists[right] &gt;= key:
                right -= <span class="hljs-number">1</span>
            lists[left] = lists[right]
            <span class="hljs-keyword">while</span> left &lt; right <span class="hljs-keyword">and</span> lists[left] &lt;= key:
                left += <span class="hljs-number">1</span>
            lists[right] = lists[left]
        lists[right] = key
        self.quick_sort(lists, low, left - <span class="hljs-number">1</span>)
        self.quick_sort(lists, left + <span class="hljs-number">1</span>, high)
        <span class="hljs-keyword">return</span> lists
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sortColors</span><span class="hljs-params">(self, nums)</span>:</span>
        <span class="hljs-string">"""
        :type nums: List[int]
        :rtype: void Do not return anything, modify nums in-place instead.
        """</span>
        nums = self.quick_sort(nums,<span class="hljs-number">0</span>,len(nums)-<span class="hljs-number">1</span>)
</code></pre><h5 id="101-对称二叉树判断"><a name="101-对称二叉树判断" href="#101-对称二叉树判断"></a>101 对称二叉树判断</h5><p>开始时想到以中序遍历结果判断，但是这样碰到一个问题就是二叉树里的null问题，因为有null的存在，仍然有很多情况会误判。想到使用递归好了，输入两颗树，判断这两课树是否相同即可。<br>需要处理的特殊情况是都是None或者1个是None这样。</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;># Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution(object):
    def sifftwo(self,root1,root2):
        if root1==None and root2==None:
            return True
        if root1!=None and root2==None or root1==None and root2!=None:
            return False
        if root1.val!=root2.val:
            return False
        return self.sifftwo(root1.left,root2.right) and self.sifftwo(root1.right,root2.left)
    def isSymmetric(self, root):
        &quot;&quot;&quot;
        :type root: TreeNode
        :rtype: bool
        &quot;&quot;&quot;
        if root==None:
            return True
        return self.sifftwo(root.left,root.right)
</code></pre>"><span class="hljs-comment"># Definition for a binary tree node.</span>
<span class="hljs-comment"># class TreeNode(object):</span>
<span class="hljs-comment">#     def __init__(self, x):</span>
<span class="hljs-comment">#         self.val = x</span>
<span class="hljs-comment">#         self.left = None</span>
<span class="hljs-comment">#         self.right = None</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sifftwo</span><span class="hljs-params">(self,root1,root2)</span>:</span>
        <span class="hljs-keyword">if</span> root1==<span class="hljs-keyword">None</span> <span class="hljs-keyword">and</span> root2==<span class="hljs-keyword">None</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">True</span>
        <span class="hljs-keyword">if</span> root1!=<span class="hljs-keyword">None</span> <span class="hljs-keyword">and</span> root2==<span class="hljs-keyword">None</span> <span class="hljs-keyword">or</span> root1==<span class="hljs-keyword">None</span> <span class="hljs-keyword">and</span> root2!=<span class="hljs-keyword">None</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">False</span>
        <span class="hljs-keyword">if</span> root1.val!=root2.val:
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">False</span>
        <span class="hljs-keyword">return</span> self.sifftwo(root1.left,root2.right) <span class="hljs-keyword">and</span> self.sifftwo(root1.right,root2.left)
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(self, root)</span>:</span>
        <span class="hljs-string">"""
        :type root: TreeNode
        :rtype: bool
        """</span>
        <span class="hljs-keyword">if</span> root==<span class="hljs-keyword">None</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">True</span>
        <span class="hljs-keyword">return</span> self.sifftwo(root.left,root.right)
</code></pre><h5 id="521-最长不一样子串"><a name="521-最长不一样子串" href="#521-最长不一样子串"></a>521 最长不一样子串</h5><p>两个串，子串是去除其中几个后的串，求最长的不一样的子串<br>如果两个串不是一样的话直接返回长串即可。</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>class Solution(object):
    def findLUSlength(self, a, b):
        &quot;&quot;&quot;
        :type a: str
        :type b: str
        :rtype: int
        &quot;&quot;&quot;       
        if a!=b:
            return max(len(b),len(a))
        else:
            return -1
</code></pre>"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findLUSlength</span><span class="hljs-params">(self, a, b)</span>:</span>
        <span class="hljs-string">"""
        :type a: str
        :type b: str
        :rtype: int
        """</span>       
        <span class="hljs-keyword">if</span> a!=b:
            <span class="hljs-keyword">return</span> max(len(b),len(a))
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>
</code></pre><h5 id="171-excel-列名称"><a name="171-excel-列名称" href="#171-excel-列名称"></a>171 excel 列名称</h5><p>给定excel里某列名称，给定其是多少列。<br>26进制</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>class Solution(object):
    def charint(self,s):
        return ord(s)-ord('A')+1
    def titleToNumber(self, s):
        &quot;&quot;&quot;
        :type s: str
        :rtype: int
        &quot;&quot;&quot;
        zs = [1]
        start = 1
        for i in range(1,len(s)):
            start = start*26
            zs.append(start)
        zs.reverse()
        print(zs)
        res = 0
        for i in range(len(s)):
            res = res + zs[i]*self.charint(s[i])
        return res
</code></pre>"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">charint</span><span class="hljs-params">(self,s)</span>:</span>
        <span class="hljs-keyword">return</span> ord(s)-ord(<span class="hljs-string">'A'</span>)+<span class="hljs-number">1</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">titleToNumber</span><span class="hljs-params">(self, s)</span>:</span>
        <span class="hljs-string">"""
        :type s: str
        :rtype: int
        """</span>
        zs = [<span class="hljs-number">1</span>]
        start = <span class="hljs-number">1</span>
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>,len(s)):
            start = start*<span class="hljs-number">26</span>
            zs.append(start)
        zs.reverse()
        print(zs)
        res = <span class="hljs-number">0</span>
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(s)):
            res = res + zs[i]*self.charint(s[i])
        <span class="hljs-keyword">return</span> res
</code></pre><h5 id="168-excel将数字转换为字母"><a name="168-excel将数字转换为字母" href="#168-excel将数字转换为字母"></a>168 excel将数字转换为字母</h5><p>给定一个数字按照excel规律转换为字母串<br>需要注意的是这里不是简单的26进制，因为里面是没有0的，所以很多地方需要单独处理这种情况，包括有时候虽然可以整除但是一定要减1因为没有表示0的方法之类。</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>
class Solution(object):
    def intchar(self,i):
        return chr(ord('A')+i-1)
    def convertToTitle(self, n):
        &quot;&quot;&quot;
        :type n: int
        :rtype: str
        &quot;&quot;&quot;
        if n == 1:
            return 'A'
        zs = [1]
        start = 1
        while n&amp;gt;zs[-1]:
            #print('here')
            start = start*26
            zs.append(start)
        zs = zs[0:-1]
        zs.reverse()
        res = ''
        inx = 0
        print(zs)
        while n&amp;gt;0:
            print('e',n,zs[inx])
            now = n/zs[inx]
            n = n%zs[inx]
            if n==0 and inx!=len(zs)-1:
                now = now - 1
                n = zs[inx]
            if inx+1&amp;lt;=len(zs)-1 and n&amp;lt;=zs[inx+1] and n!=1:
                print(inx,n,now)
                n = now*zs[inx]+n
                inx = inx +1
                continue
            res = res + str(self.intchar(now))
            inx = inx + 1
        return res
</code></pre>">
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">intchar</span><span class="hljs-params">(self,i)</span>:</span>
        <span class="hljs-keyword">return</span> chr(ord(<span class="hljs-string">'A'</span>)+i-<span class="hljs-number">1</span>)
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">convertToTitle</span><span class="hljs-params">(self, n)</span>:</span>
        <span class="hljs-string">"""
        :type n: int
        :rtype: str
        """</span>
        <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-string">'A'</span>
        zs = [<span class="hljs-number">1</span>]
        start = <span class="hljs-number">1</span>
        <span class="hljs-keyword">while</span> n&gt;zs[-<span class="hljs-number">1</span>]:
            <span class="hljs-comment">#print('here')</span>
            start = start*<span class="hljs-number">26</span>
            zs.append(start)
        zs = zs[<span class="hljs-number">0</span>:-<span class="hljs-number">1</span>]
        zs.reverse()
        res = <span class="hljs-string">''</span>
        inx = <span class="hljs-number">0</span>
        print(zs)
        <span class="hljs-keyword">while</span> n&gt;<span class="hljs-number">0</span>:
            print(<span class="hljs-string">'e'</span>,n,zs[inx])
            now = n/zs[inx]
            n = n%zs[inx]
            <span class="hljs-keyword">if</span> n==<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> inx!=len(zs)-<span class="hljs-number">1</span>:
                now = now - <span class="hljs-number">1</span>
                n = zs[inx]
            <span class="hljs-keyword">if</span> inx+<span class="hljs-number">1</span>&lt;=len(zs)-<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> n&lt;=zs[inx+<span class="hljs-number">1</span>] <span class="hljs-keyword">and</span> n!=<span class="hljs-number">1</span>:
                print(inx,n,now)
                n = now*zs[inx]+n
                inx = inx +<span class="hljs-number">1</span>
                <span class="hljs-keyword">continue</span>
            res = res + str(self.intchar(now))
            inx = inx + <span class="hljs-number">1</span>
        <span class="hljs-keyword">return</span> res
</code></pre><h5 id="669-trim-bst"><a name="669-trim-bst" href="#669-trim-bst"></a>669 trim BST</h5><p>将BST里不包含在范围L，R里的都删除。<br>递归即可，如果在左边就只遍历右边反之依然。</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;># Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution(object):
    def lr(self,idx,L,R):
        if idx&amp;lt;L:
            return 0
        if idx&amp;gt;R:
            return 2
        return 1
    def dd(self,root,L,R):
        if root==None:
            return None
        if self.lr(root.val,L,R)==0:
            return self.dd(root.right,L,R)
        elif self.lr(root.val,L,R)==2:
            return self.dd(root.left,L,R)
        else:
            root.left = self.dd(root.left,L,R)
            root.right = self.dd(root.right,L,R)
        return root

    def trimBST(self, root, L, R):
        &quot;&quot;&quot;
        :type root: TreeNode
        :type L: int
        :type R: int
        :rtype: TreeNode
        &quot;&quot;&quot;
        root = self.dd(root,L,R)
        return root
</code></pre>"><span class="hljs-comment"># Definition for a binary tree node.</span>
<span class="hljs-comment"># class TreeNode(object):</span>
<span class="hljs-comment">#     def __init__(self, x):</span>
<span class="hljs-comment">#         self.val = x</span>
<span class="hljs-comment">#         self.left = None</span>
<span class="hljs-comment">#         self.right = None</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">lr</span><span class="hljs-params">(self,idx,L,R)</span>:</span>
        <span class="hljs-keyword">if</span> idx&lt;L:
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>
        <span class="hljs-keyword">if</span> idx&gt;R:
            <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>
        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dd</span><span class="hljs-params">(self,root,L,R)</span>:</span>
        <span class="hljs-keyword">if</span> root==<span class="hljs-keyword">None</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">None</span>
        <span class="hljs-keyword">if</span> self.lr(root.val,L,R)==<span class="hljs-number">0</span>:
            <span class="hljs-keyword">return</span> self.dd(root.right,L,R)
        <span class="hljs-keyword">elif</span> self.lr(root.val,L,R)==<span class="hljs-number">2</span>:
            <span class="hljs-keyword">return</span> self.dd(root.left,L,R)
        <span class="hljs-keyword">else</span>:
            root.left = self.dd(root.left,L,R)
            root.right = self.dd(root.right,L,R)
        <span class="hljs-keyword">return</span> root

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">trimBST</span><span class="hljs-params">(self, root, L, R)</span>:</span>
        <span class="hljs-string">"""
        :type root: TreeNode
        :type L: int
        :type R: int
        :rtype: TreeNode
        """</span>
        root = self.dd(root,L,R)
        <span class="hljs-keyword">return</span> root
</code></pre><h5 id="554-break-wall"><a name="554-break-wall" href="#554-break-wall"></a>554 break wall</h5><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>class Solution(object):
    def leastBricks(self, wall):
        &quot;&quot;&quot;
        :type wall: List[List[int]]
        :rtype: int
        &quot;&quot;&quot;
        if len(wall)==0:
            return 0
        res = []
        for row in wall:
            start = 0
            for i in range(len(row)-1):
                start = start + row[i]
                res.append(start)
        maxcount = 0
        d = {}
        for i in res:
            if i==0:
                continue
            if i in d:
                d[i] = d[i]+1
            else:
                d[i] = 1
        for i in d:
            maxcount = max(maxcount,d[i])
        return len(wall)-maxcount
</code></pre>"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">leastBricks</span><span class="hljs-params">(self, wall)</span>:</span>
        <span class="hljs-string">"""
        :type wall: List[List[int]]
        :rtype: int
        """</span>
        <span class="hljs-keyword">if</span> len(wall)==<span class="hljs-number">0</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>
        res = []
        <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> wall:
            start = <span class="hljs-number">0</span>
            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(row)-<span class="hljs-number">1</span>):
                start = start + row[i]
                res.append(start)
        maxcount = <span class="hljs-number">0</span>
        d = {}
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> res:
            <span class="hljs-keyword">if</span> i==<span class="hljs-number">0</span>:
                <span class="hljs-keyword">continue</span>
            <span class="hljs-keyword">if</span> i <span class="hljs-keyword">in</span> d:
                d[i] = d[i]+<span class="hljs-number">1</span>
            <span class="hljs-keyword">else</span>:
                d[i] = <span class="hljs-number">1</span>
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> d:
            maxcount = max(maxcount,d[i])
        <span class="hljs-keyword">return</span> len(wall)-maxcount
</code></pre><h5 id="594-最长和谐子串"><a name="594-最长和谐子串" href="#594-最长和谐子串"></a>594 最长和谐子串</h5><p>给定一个数组，子串是其中挑选一部分的串，要求和谐是指其中的最大和最小元素差值为1，求最长长度<br>直接统计个数而后统计即可。</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>class Solution(object):
    def findLHS(self, nums):
        &quot;&quot;&quot;
        :type nums: List[int]
        :rtype: int
        &quot;&quot;&quot;
        if len(nums)==0:
            return 0
        numset = set(nums)
        numss = sorted(numset)
        d = {}
        for i in nums:
            if i in d:
                d[i] = d[i]+1
            else:
                d[i] = 1
        maxr = 0
        #print(d,numss)
        for i in range(1,len(numss)):
            if numss[i]-numss[i-1]&amp;lt;=1:
                maxr = max(maxr,d[numss[i]]+d[numss[i-1]])
        return maxr
</code></pre>"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findLHS</span><span class="hljs-params">(self, nums)</span>:</span>
        <span class="hljs-string">"""
        :type nums: List[int]
        :rtype: int
        """</span>
        <span class="hljs-keyword">if</span> len(nums)==<span class="hljs-number">0</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>
        numset = set(nums)
        numss = sorted(numset)
        d = {}
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> nums:
            <span class="hljs-keyword">if</span> i <span class="hljs-keyword">in</span> d:
                d[i] = d[i]+<span class="hljs-number">1</span>
            <span class="hljs-keyword">else</span>:
                d[i] = <span class="hljs-number">1</span>
        maxr = <span class="hljs-number">0</span>
        <span class="hljs-comment">#print(d,numss)</span>
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>,len(numss)):
            <span class="hljs-keyword">if</span> numss[i]-numss[i-<span class="hljs-number">1</span>]&lt;=<span class="hljs-number">1</span>:
                maxr = max(maxr,d[numss[i]]+d[numss[i-<span class="hljs-number">1</span>]])
        <span class="hljs-keyword">return</span> maxr
</code></pre><h5 id="60-permutation-sequence"><a name="60-permutation-sequence" href="#60-permutation-sequence"></a>60 permutation sequence</h5><p>排列序列。给定n和k，求1-n的各种排列里第k个。<br>肯定不能dfs去求，那样复杂度可能比较高。那么采用找规律的方式，可以看到头一个是以几个一循环这样，第二位也是，第三位也是，并且第二位循环后第k个是1-n数组里去除了第一位已经选择的那个的第k个。所以可以用一个数组存下来所有备用的数字，而后按照循环，挨个抽取。</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>class Solution(object):
    def getPermutation(self, n, k):
        &quot;&quot;&quot;
        :type n: int
        :type k: int
        :rtype: str
        &quot;&quot;&quot;
        nn = [1]
        for i in range(1,n):
            nn.append(nn[-1]*i)
            #nn[i] =nn[i-1]*i
        nn = nn[1:]
        nn.reverse()
        res = []
        resbak = [i+1 for i in range(n)]#1,2,3,4
        idx = 0
        k = k -1
        while k!=0:
            nowidx = k/nn[idx]
            k = k % nn[idx]
            res.append(resbak[nowidx])
            resbak.remove(resbak[nowidx])
            idx = idx + 1
        res = res + resbak
        res = [str(i) for i in res]
        return ''.join(res)
</code></pre>"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getPermutation</span><span class="hljs-params">(self, n, k)</span>:</span>
        <span class="hljs-string">"""
        :type n: int
        :type k: int
        :rtype: str
        """</span>
        nn = [<span class="hljs-number">1</span>]
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>,n):
            nn.append(nn[-<span class="hljs-number">1</span>]*i)
            <span class="hljs-comment">#nn[i] =nn[i-1]*i</span>
        nn = nn[<span class="hljs-number">1</span>:]
        nn.reverse()
        res = []
        resbak = [i+<span class="hljs-number">1</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(n)]<span class="hljs-comment">#1,2,3,4</span>
        idx = <span class="hljs-number">0</span>
        k = k -<span class="hljs-number">1</span>
        <span class="hljs-keyword">while</span> k!=<span class="hljs-number">0</span>:
            nowidx = k/nn[idx]
            k = k % nn[idx]
            res.append(resbak[nowidx])
            resbak.remove(resbak[nowidx])
            idx = idx + <span class="hljs-number">1</span>
        res = res + resbak
        res = [str(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> res]
        <span class="hljs-keyword">return</span> <span class="hljs-string">''</span>.join(res)
</code></pre><h5 id="51-n皇后"><a name="51-n皇后" href="#51-n皇后"></a>51 N皇后</h5><p>直接bfs即可。重点在于如何根据之前的坐标判断后面某个坐标是否合法这样的。<br>观察规律可以。假如之前某个皇后坐标是x，y，那么后面的坐标p，q必须满足p+q!=x+y,p-q!=x-y。否则的话就会在斜对角上冲突，然后当前就是不能在同一列。</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>class Solution(object):
    def solveNQueens(self, n):
        &quot;&quot;&quot;
        :type n: int
        :rtype: List[List[str]]
        &quot;&quot;&quot;
        def dfs(queens,xy_dif,xy_sum):
            p = len(queens)
            if p==n:
                result.append(queens)
                return None
            for q in range(n):
                if q not in queens and p-q not in xy_dif and p+q not in xy_sum:
                    dfs(queens+[q],xy_dif+[p-q],xy_sum+[p+q])
        result = []
        dfs([],[],[])
        return [ [&quot;.&quot;*i + &quot;Q&quot; + &quot;.&quot;*(n-i-1) for i in sol] for sol in result]
</code></pre>"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">solveNQueens</span><span class="hljs-params">(self, n)</span>:</span>
        <span class="hljs-string">"""
        :type n: int
        :rtype: List[List[str]]
        """</span>
        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dfs</span><span class="hljs-params">(queens,xy_dif,xy_sum)</span>:</span>
            p = len(queens)
            <span class="hljs-keyword">if</span> p==n:
                result.append(queens)
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">None</span>
            <span class="hljs-keyword">for</span> q <span class="hljs-keyword">in</span> range(n):
                <span class="hljs-keyword">if</span> q <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> queens <span class="hljs-keyword">and</span> p-q <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> xy_dif <span class="hljs-keyword">and</span> p+q <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> xy_sum:
                    dfs(queens+[q],xy_dif+[p-q],xy_sum+[p+q])
        result = []
        dfs([],[],[])
        <span class="hljs-keyword">return</span> [ [<span class="hljs-string">"."</span>*i + <span class="hljs-string">"Q"</span> + <span class="hljs-string">"."</span>*(n-i-<span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> sol] <span class="hljs-keyword">for</span> sol <span class="hljs-keyword">in</span> result]
</code></pre><h5 id="503-next-great-element"><a name="503-next-great-element" href="#503-next-great-element"></a>503 next great element</h5><p>一个可以回环的数组，求每个元素从后遍历后第一个大于它的元素，没有则为-1.<br>这个可以通过两层遍历，不过复杂度会超时可能。这里采用一种比较巧妙的思路利用了栈结构。具体使用的方法是将未找到比它大的元素的坐标放入栈中，一旦碰到一个大于栈顶的元素，则进行赋值即可。因为这个入栈和出栈的操作是在循环过程里一直进行的，所以其中可以认为栈中的元素是按照下降的顺序排列的，因为如果是上升那么之前就已经出栈赋值了。</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>class Solution(object):
    def nextGreaterElements(self, nums):
        &quot;&quot;&quot;
        :type nums: List[int]
        :rtype: List[int]
        &quot;&quot;&quot;
        stack = []
        res = [-1]*len(nums)
        for i in range(len(nums))*2:
            while stack and nums[stack[-1]]&amp;lt;nums[i]:
                res[stack.pop()] = nums[i]
            stack.append(i)
        return res
</code></pre>"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">nextGreaterElements</span><span class="hljs-params">(self, nums)</span>:</span>
        <span class="hljs-string">"""
        :type nums: List[int]
        :rtype: List[int]
        """</span>
        stack = []
        res = [-<span class="hljs-number">1</span>]*len(nums)
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(nums))*<span class="hljs-number">2</span>:
            <span class="hljs-keyword">while</span> stack <span class="hljs-keyword">and</span> nums[stack[-<span class="hljs-number">1</span>]]&lt;nums[i]:
                res[stack.pop()] = nums[i]
            stack.append(i)
        <span class="hljs-keyword">return</span> res
</code></pre><h5 id="496-next-great-element"><a name="496-next-great-element" href="#496-next-great-element"></a>496 next great element</h5><p>给定两个unique数组，求nums1里的元素在num2里的nextgreat元素。思路和上面一样，先求nums2里所有的nextgreat，然后挑选出nums1里的即可。</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>class Solution(object):
    def nextGreaterElement(self, findNums,nums):
        &quot;&quot;&quot;
        :type nums: List[int]
        :rtype: List[int]
        &quot;&quot;&quot;
        d = {}
        for idx,i in enumerate(nums):
            d[i] = idx
        fs = set(findNums)
        stack = []
        res = [-1]*len(nums)
        for i in range(len(nums)):
            while stack and nums[stack[-1]]&amp;lt;nums[i]:
                res[stack.pop()] = nums[i]
            stack.append(i)
        r = []
        for i in findNums:
            r.append(res[d[i]])
        return r
</code></pre>"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">nextGreaterElement</span><span class="hljs-params">(self, findNums,nums)</span>:</span>
        <span class="hljs-string">"""
        :type nums: List[int]
        :rtype: List[int]
        """</span>
        d = {}
        <span class="hljs-keyword">for</span> idx,i <span class="hljs-keyword">in</span> enumerate(nums):
            d[i] = idx
        fs = set(findNums)
        stack = []
        res = [-<span class="hljs-number">1</span>]*len(nums)
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(nums)):
            <span class="hljs-keyword">while</span> stack <span class="hljs-keyword">and</span> nums[stack[-<span class="hljs-number">1</span>]]&lt;nums[i]:
                res[stack.pop()] = nums[i]
            stack.append(i)
        r = []
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> findNums:
            r.append(res[d[i]])
        <span class="hljs-keyword">return</span> r
</code></pre><h5 id="556-next-great-3"><a name="556-next-great-3" href="#556-next-great-3"></a>556 next great 3</h5><p>与前面两个不同。这里给一个n，求一个n内数字重组后最小的大于n的数字并且需要是32位整数。<br>思路的话就是从后往前找到第一次出现前面小于后面最大值的，然后再在后面找到一个可以替换的，然后将剩余的排序即可。</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>class Solution(object):
    def nextGreaterElement(self, n):
        &quot;&quot;&quot;
        :type n: int
        :rtype: int
        &quot;&quot;&quot;
        ns = [i for i in str(n)]
        maxnow = '0'
        for i in range(len(ns)-1,-1,-1):
            print(ns[i],maxnow,i)
            if ns[i]&amp;gt;=maxnow:
                maxnow = ns[i]
            else:
                tmp = ns[i+1:]
                tmp.sort()
                idx = 0
                if ns[i] not in tmp:
                    idx = -1
                else:
                    idx = tmp.index(ns[i])
                for k in range(idx+1,len(tmp)):
                    if tmp[k]&amp;gt;ns[i]:
                        idx = k
                        break
                here = tmp[idx]
                print('here',here)
                tmp = [ns[i]]+tmp[0:idx]+tmp[idx+1:]
                tmp.sort()
                print(tmp)
                ns = ns[0:i]+[here]+tmp
                break
        nsi = int(''.join(ns))
        if nsi == n or nsi&amp;gt;=2**31-1:
            return -1
        else:
            return nsi
</code></pre>"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">nextGreaterElement</span><span class="hljs-params">(self, n)</span>:</span>
        <span class="hljs-string">"""
        :type n: int
        :rtype: int
        """</span>
        ns = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> str(n)]
        maxnow = <span class="hljs-string">'0'</span>
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(ns)-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>):
            print(ns[i],maxnow,i)
            <span class="hljs-keyword">if</span> ns[i]&gt;=maxnow:
                maxnow = ns[i]
            <span class="hljs-keyword">else</span>:
                tmp = ns[i+<span class="hljs-number">1</span>:]
                tmp.sort()
                idx = <span class="hljs-number">0</span>
                <span class="hljs-keyword">if</span> ns[i] <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> tmp:
                    idx = -<span class="hljs-number">1</span>
                <span class="hljs-keyword">else</span>:
                    idx = tmp.index(ns[i])
                <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> range(idx+<span class="hljs-number">1</span>,len(tmp)):
                    <span class="hljs-keyword">if</span> tmp[k]&gt;ns[i]:
                        idx = k
                        <span class="hljs-keyword">break</span>
                here = tmp[idx]
                print(<span class="hljs-string">'here'</span>,here)
                tmp = [ns[i]]+tmp[<span class="hljs-number">0</span>:idx]+tmp[idx+<span class="hljs-number">1</span>:]
                tmp.sort()
                print(tmp)
                ns = ns[<span class="hljs-number">0</span>:i]+[here]+tmp
                <span class="hljs-keyword">break</span>
        nsi = int(<span class="hljs-string">''</span>.join(ns))
        <span class="hljs-keyword">if</span> nsi == n <span class="hljs-keyword">or</span> nsi&gt;=<span class="hljs-number">2</span>**<span class="hljs-number">31</span>-<span class="hljs-number">1</span>:
            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">return</span> nsi
</code></pre><h5 id="14-最长公共前缀"><a name="14-最长公共前缀" href="#14-最长公共前缀"></a>14 最长公共前缀</h5><p>给定几个字符串求最长公共前缀<br>直接挨个查看即可的。</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>class Solution(object):
    def longestCommonPrefix(self, strs):
        &quot;&quot;&quot;
        :type strs: List[str]
        :rtype: str
        &quot;&quot;&quot;
        if len(strs)==0:
            return ''
        lenmin = min([len(i) for i in strs])
        idx = 0
        for i in range(lenmin):
            tmpset = set([j[i] for j in strs])
            if len(tmpset)==1:
                idx = idx + 1
            else:
                break
        res = strs[0][0:idx]
        return res
</code></pre>"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">longestCommonPrefix</span><span class="hljs-params">(self, strs)</span>:</span>
        <span class="hljs-string">"""
        :type strs: List[str]
        :rtype: str
        """</span>
        <span class="hljs-keyword">if</span> len(strs)==<span class="hljs-number">0</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-string">''</span>
        lenmin = min([len(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> strs])
        idx = <span class="hljs-number">0</span>
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(lenmin):
            tmpset = set([j[i] <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> strs])
            <span class="hljs-keyword">if</span> len(tmpset)==<span class="hljs-number">1</span>:
                idx = idx + <span class="hljs-number">1</span>
            <span class="hljs-keyword">else</span>:
                <span class="hljs-keyword">break</span>
        res = strs[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>:idx]
        <span class="hljs-keyword">return</span> res
</code></pre><h5 id="600-二进制不包含连1的非负整数个数"><a name="600-二进制不包含连1的非负整数个数" href="#600-二进制不包含连1的非负整数个数"></a>600 二进制不包含连1的非负整数个数</h5><p>求小于n的不含连1的非负整数个数。<br>这道题目有两个点需要解决。一个是二进制长度为n的数字串里，里面不包含相连1的有多少个。这个可以通过迭代得知，分别以结尾是1还是0来计算，n=1时都是1，n=2时结尾是1的话可以加0，结尾是0的话可以加1也可以加0，这样形成一个迭代。具体参看文章 <code>http://www.geeksforgeeks.org/count-number-binary-strings-without-consecutive-1s/</code><br>然后还需要解决给定n后要求的是小于n的所有串，刚才求的是所有的串，那么需要减去哪些的。以二进制串里面遍历，从高到低遍历，如果碰到连续的1，，也就是11，那么可以得知后面所有的不连1串都小于目前，所以停止遍历。如果碰到101010.。。也没有什么，小于这样的也就是全部的了不需要减。如果碰到连0也就是00，那么原先所有的字符串里会有01的串大于目前的数字，就需要减去。减去的值是当前串的位置k决定的。总之就是1.。。这样的要去掉。而b[k]指的是以1结尾，其实放在这里可以认为是以1开头的个数。删去这个即可。</p><pre class="java hljs"><code class="java" data-origin="<pre><code class=&quot;java&quot;>public class Solution {
    public int findIntegers(int num) {
        StringBuilder sb = new StringBuilder(Integer.toBinaryString(num)).reverse();
        int n = sb.length();

        int a[] = new int[n];
        int b[] = new int[n];
        a[0] = b[0] = 1;
        for (int i = 1; i &amp;lt; n; i++) {
            a[i] = a[i - 1] + b[i - 1];
            b[i] = a[i - 1];
        }

        int result = a[n - 1] + b[n - 1];
        for (int i = n - 2; i &amp;gt;= 0; i--) {
            if (sb.charAt(i) == '1' &amp;amp;&amp;amp; sb.charAt(i + 1) == '1') break;
            if (sb.charAt(i) == '0' &amp;amp;&amp;amp; sb.charAt(i + 1) == '0') result -= b[i];
        }

        return result;
    }
}
</code></pre>"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findIntegers</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>{
        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder(Integer.toBinaryString(num)).reverse();
        <span class="hljs-keyword">int</span> n = sb.length();

        <span class="hljs-keyword">int</span> a[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];
        <span class="hljs-keyword">int</span> b[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];
        a[<span class="hljs-number">0</span>] = b[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) {
            a[i] = a[i - <span class="hljs-number">1</span>] + b[i - <span class="hljs-number">1</span>];
            b[i] = a[i - <span class="hljs-number">1</span>];
        }

        <span class="hljs-keyword">int</span> result = a[n - <span class="hljs-number">1</span>] + b[n - <span class="hljs-number">1</span>];
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) {
            <span class="hljs-keyword">if</span> (sb.charAt(i) == <span class="hljs-string">'1'</span> &amp;&amp; sb.charAt(i + <span class="hljs-number">1</span>) == <span class="hljs-string">'1'</span>) <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">if</span> (sb.charAt(i) == <span class="hljs-string">'0'</span> &amp;&amp; sb.charAt(i + <span class="hljs-number">1</span>) == <span class="hljs-string">'0'</span>) result -= b[i];
        }

        <span class="hljs-keyword">return</span> result;
    }
}
</code></pre><h5 id="139-wordbreak"><a name="139-wordbreak" href="#139-wordbreak"></a>139 wordbreak</h5><p>给定一个字符串和字符串字典，问字符串是否可以由字典里的组成。<br>dp，对应前i个字符，查看其是否可以以字典里组成。dp[i]的意思是字符串前i个是否可以以字典里代替。那么dp[i+1]就等于前i个依次遍历以某处分开后前半部分是否可以以字典和后半部分是否在字典进行与操作。</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>class Solution(object):
    def wordBreak(self, s, words):
        ok = [True]
        for i in range(1, len(s)+1):
            ok += any(ok[j] and s[j:i] in words for j in range(i)),
        return ok[-1]
</code></pre>"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wordBreak</span><span class="hljs-params">(self, s, words)</span>:</span>
        ok = [<span class="hljs-keyword">True</span>]
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, len(s)+<span class="hljs-number">1</span>):
            ok += any(ok[j] <span class="hljs-keyword">and</span> s[j:i] <span class="hljs-keyword">in</span> words <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(i)),
        <span class="hljs-keyword">return</span> ok[-<span class="hljs-number">1</span>]
</code></pre><h5 id="373-find-k-pairs-with-samllest-sum"><a name="373-find-k-pairs-with-samllest-sum" href="#373-find-k-pairs-with-samllest-sum"></a>373 find k pairs with samllest sum</h5><p>给定两个排序好的数组，从两个里调一个组成一对，合为sum，求和最小的情况。<br>这里使用了python的堆排序模块。import heapq。</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>#一些示例
h = []
heappush(h,5)
headpush(h,3)
#h = [3,5]
heappop(h)
#h = [5]删除最小的并返回该值
</code></pre>"><span class="hljs-comment">#一些示例</span>
h = []
heappush(h,<span class="hljs-number">5</span>)
headpush(h,<span class="hljs-number">3</span>)
<span class="hljs-comment">#h = [3,5]</span>
heappop(h)
<span class="hljs-comment">#h = [5]删除最小的并返回该值</span>
</code></pre><p>可以在遍历的过程中构建堆并实时进行判断是否需要将元素如堆，这样可以减少内存占用。</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>class Solution(object):
    def kSmallestPairs(self, nums1, nums2, k):
        &quot;&quot;&quot;
        :type nums1: List[int]
        :type nums2: List[int]
        :type k: int
        :rtype: List[List[int]]
        &quot;&quot;&quot;
        heap = []
        for n1 in nums1:
            for n2 in nums2:
                if len(heap) &amp;lt; k: heapq.heappush(heap, (-n1-n2, [n1, n2]))
                else:
                    if heap and -heap[0][0] &amp;gt; n1 + n2:
                        heapq.heappop(heap)
                        heapq.heappush(heap, (-n1-n2, [n1, n2]))
                    else: break
        return [heapq.heappop(heap)[1] for _ in range(k) if heap]
</code></pre>"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">kSmallestPairs</span><span class="hljs-params">(self, nums1, nums2, k)</span>:</span>
        <span class="hljs-string">"""
        :type nums1: List[int]
        :type nums2: List[int]
        :type k: int
        :rtype: List[List[int]]
        """</span>
        heap = []
        <span class="hljs-keyword">for</span> n1 <span class="hljs-keyword">in</span> nums1:
            <span class="hljs-keyword">for</span> n2 <span class="hljs-keyword">in</span> nums2:
                <span class="hljs-keyword">if</span> len(heap) &lt; k: heapq.heappush(heap, (-n1-n2, [n1, n2]))
                <span class="hljs-keyword">else</span>:
                    <span class="hljs-keyword">if</span> heap <span class="hljs-keyword">and</span> -heap[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] &gt; n1 + n2:
                        heapq.heappop(heap)
                        heapq.heappush(heap, (-n1-n2, [n1, n2]))
                    <span class="hljs-keyword">else</span>: <span class="hljs-keyword">break</span>
        <span class="hljs-keyword">return</span> [heapq.heappop(heap)[<span class="hljs-number">1</span>] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(k) <span class="hljs-keyword">if</span> heap]
</code></pre><h5 id="290-word-pattern"><a name="290-word-pattern" href="#290-word-pattern"></a>290 word pattern</h5><p>判断两个字符串模式是否相同<br>直接将两个串都编码后看编码是否一致即可。</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>class Solution(object):
    def wordPattern(self, pattern, s):
        &quot;&quot;&quot;
        :type pattern: str
        :type str: str
        :rtype: bool
        &quot;&quot;&quot;
        s = s
        paset = {}
        pa = ''
        idx = 0
        for i in pattern:
            if i in paset:
                pa = pa+str(paset[i])
            else:
                paset[i] = idx
                pa = pa +str(paset[i])
                idx = idx + 1
        stset = {}
        st = ''
        idx = 0
        strr = s.split()
        for i in strr:
            if i in stset:
                st = st+str(stset[i])
            else:
                stset[i] = idx
                st = st +str(stset[i])
                idx = idx + 1
        return st==pa
</code></pre>"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wordPattern</span><span class="hljs-params">(self, pattern, s)</span>:</span>
        <span class="hljs-string">"""
        :type pattern: str
        :type str: str
        :rtype: bool
        """</span>
        s = s
        paset = {}
        pa = <span class="hljs-string">''</span>
        idx = <span class="hljs-number">0</span>
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> pattern:
            <span class="hljs-keyword">if</span> i <span class="hljs-keyword">in</span> paset:
                pa = pa+str(paset[i])
            <span class="hljs-keyword">else</span>:
                paset[i] = idx
                pa = pa +str(paset[i])
                idx = idx + <span class="hljs-number">1</span>
        stset = {}
        st = <span class="hljs-string">''</span>
        idx = <span class="hljs-number">0</span>
        strr = s.split()
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> strr:
            <span class="hljs-keyword">if</span> i <span class="hljs-keyword">in</span> stset:
                st = st+str(stset[i])
            <span class="hljs-keyword">else</span>:
                stset[i] = idx
                st = st +str(stset[i])
                idx = idx + <span class="hljs-number">1</span>
        <span class="hljs-keyword">return</span> st==pa
</code></pre><h5 id="639-decode-ways-2"><a name="639-decode-ways-2" href="#639-decode-ways-2"></a>639 decode ways 2</h5><p>1-26对应到A到Z，给一串0-9加星号的字符串，问有几种解码方式。<br>通过多次观察后发现，可以找出规律。可以用三个变量存储以任意结尾的方法，以末尾为1的结尾方法，以末尾为2的结尾方法。如果当前遇到的是星号，则任意×9加上1<em>9加上2</em>6即可。然后如果碰到数字也是一样的类似。<br>python里新的用法（3&gt;2）×3=3</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>class Solution(object):
    def numDecodings(self, s):
        S = s
        MOD = 10**9 + 7
        e0, e1, e2 = 1, 0, 0
        for c in S:
            if c == '*':
                f0 = 9*e0 + 9*e1 + 6*e2
                f1 = e0
                f2 = e0
            else:
                f0 = (c &amp;gt; '0') * e0 + e1 + (c &amp;lt;= '6') * e2
                f1 = (c == '1') * e0
                f2 = (c == '2') * e0
            e0, e1, e2 = f0 % MOD, f1, f2
        return e0
</code></pre>"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">numDecodings</span><span class="hljs-params">(self, s)</span>:</span>
        S = s
        MOD = <span class="hljs-number">10</span>**<span class="hljs-number">9</span> + <span class="hljs-number">7</span>
        e0, e1, e2 = <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>
        <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> S:
            <span class="hljs-keyword">if</span> c == <span class="hljs-string">'*'</span>:
                f0 = <span class="hljs-number">9</span>*e0 + <span class="hljs-number">9</span>*e1 + <span class="hljs-number">6</span>*e2
                f1 = e0
                f2 = e0
            <span class="hljs-keyword">else</span>:
                f0 = (c &gt; <span class="hljs-string">'0'</span>) * e0 + e1 + (c &lt;= <span class="hljs-string">'6'</span>) * e2
                f1 = (c == <span class="hljs-string">'1'</span>) * e0
                f2 = (c == <span class="hljs-string">'2'</span>) * e0
            e0, e1, e2 = f0 % MOD, f1, f2
        <span class="hljs-keyword">return</span> e0
</code></pre><h5 id="658"><a name="658" href="#658"></a>658</h5><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>class Solution(object):
    def findClosestElements(self, arr, k, x):
        &quot;&quot;&quot;
        :type arr: List[int]
        :type k: int
        :type x: int
        :rtype: List[int]
        &quot;&quot;&quot;
        def bs(nums,k):
            left = 0
            right = len(nums)-1
            while left&amp;lt;=right:
                mid = (left+right)/2
                if nums[mid]==k:
                    return mid
                elif nums[mid]&amp;lt;k:
                    left = mid+1
                else:
                    right = mid-1
            return mid
        left = right = bs(arr, x)
        while right - left &amp;lt; k:
            if left == 0: return arr[:k]
            if right == len(arr): return arr[-k:]
            if x - arr[left - 1] &amp;lt;= arr[right] - x: left -= 1
            else: right += 1
        return arr[left:right]
</code></pre>"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findClosestElements</span><span class="hljs-params">(self, arr, k, x)</span>:</span>
        <span class="hljs-string">"""
        :type arr: List[int]
        :type k: int
        :type x: int
        :rtype: List[int]
        """</span>
        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bs</span><span class="hljs-params">(nums,k)</span>:</span>
            left = <span class="hljs-number">0</span>
            right = len(nums)-<span class="hljs-number">1</span>
            <span class="hljs-keyword">while</span> left&lt;=right:
                mid = (left+right)/<span class="hljs-number">2</span>
                <span class="hljs-keyword">if</span> nums[mid]==k:
                    <span class="hljs-keyword">return</span> mid
                <span class="hljs-keyword">elif</span> nums[mid]&lt;k:
                    left = mid+<span class="hljs-number">1</span>
                <span class="hljs-keyword">else</span>:
                    right = mid-<span class="hljs-number">1</span>
            <span class="hljs-keyword">return</span> mid
        left = right = bs(arr, x)
        <span class="hljs-keyword">while</span> right - left &lt; k:
            <span class="hljs-keyword">if</span> left == <span class="hljs-number">0</span>: <span class="hljs-keyword">return</span> arr[:k]
            <span class="hljs-keyword">if</span> right == len(arr): <span class="hljs-keyword">return</span> arr[-k:]
            <span class="hljs-keyword">if</span> x - arr[left - <span class="hljs-number">1</span>] &lt;= arr[right] - x: left -= <span class="hljs-number">1</span>
            <span class="hljs-keyword">else</span>: right += <span class="hljs-number">1</span>
        <span class="hljs-keyword">return</span> arr[left:right]
</code></pre><h6 id="19-remove-kth-node-in-list"><a name="19-remove-kth-node-in-list" href="#19-remove-kth-node-in-list"></a>19 remove kth node in list</h6><p>删除链表里第k个</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;># Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution(object):
    def removeNthFromEnd(self, head, n):
        &quot;&quot;&quot;
        :type head: ListNode
        :type n: int
        :rtype: ListNode
        &quot;&quot;&quot;
        if head==None:
            return head
        nn = 0
        headbak = head
        while headbak!=None:
            nn = nn + 1
            headbak = headbak.next
        nns = 0
        if nn==n:
            return head.next
        headbak = head
        while headbak!=None and nns&amp;lt;nn-n-1:
            nns = nns + 1
            headbak = headbak.next
        tmp = headbak.next.next
        headbak.next = tmp
        return head
</code></pre>"><span class="hljs-comment"># Definition for singly-linked list.</span>
<span class="hljs-comment"># class ListNode(object):</span>
<span class="hljs-comment">#     def __init__(self, x):</span>
<span class="hljs-comment">#         self.val = x</span>
<span class="hljs-comment">#         self.next = None</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(self, head, n)</span>:</span>
        <span class="hljs-string">"""
        :type head: ListNode
        :type n: int
        :rtype: ListNode
        """</span>
        <span class="hljs-keyword">if</span> head==<span class="hljs-keyword">None</span>:
            <span class="hljs-keyword">return</span> head
        nn = <span class="hljs-number">0</span>
        headbak = head
        <span class="hljs-keyword">while</span> headbak!=<span class="hljs-keyword">None</span>:
            nn = nn + <span class="hljs-number">1</span>
            headbak = headbak.next
        nns = <span class="hljs-number">0</span>
        <span class="hljs-keyword">if</span> nn==n:
            <span class="hljs-keyword">return</span> head.next
        headbak = head
        <span class="hljs-keyword">while</span> headbak!=<span class="hljs-keyword">None</span> <span class="hljs-keyword">and</span> nns&lt;nn-n-<span class="hljs-number">1</span>:
            nns = nns + <span class="hljs-number">1</span>
            headbak = headbak.next
        tmp = headbak.next.next
        headbak.next = tmp
        <span class="hljs-keyword">return</span> head
</code></pre><h5 id="16-3sum-closest"><a name="16-3sum-closest" href="#16-3sum-closest"></a>16 3sum closest</h5><p>数组里选3个元素使得他们的和最接近于给定k值(尽量小)<br>将原数组排序，这样在第二层遍历里就可以通过两指针进行一次遍历了。<br>第一层遍历，第二层遍历该元素后面的所有元素，每次挑两个判断值。</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>class Solution(object):

    def threeSumClosest(self, num, target):
        num.sort()
        result = num[0] + num[1] + num[2]
        for i in range(len(num) - 2):
            j, k = i+1, len(num) - 1
            while j &amp;lt; k:
                sum = num[i] + num[j] + num[k]
                if sum == target:
                    return sum

                if abs(sum - target) &amp;lt; abs(result - target):
                    result = sum

                if sum &amp;lt; target:
                    j += 1
                elif sum &amp;gt; target:
                    k -= 1

        return result
</code></pre>"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">threeSumClosest</span><span class="hljs-params">(self, num, target)</span>:</span>
        num.sort()
        result = num[<span class="hljs-number">0</span>] + num[<span class="hljs-number">1</span>] + num[<span class="hljs-number">2</span>]
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(num) - <span class="hljs-number">2</span>):
            j, k = i+<span class="hljs-number">1</span>, len(num) - <span class="hljs-number">1</span>
            <span class="hljs-keyword">while</span> j &lt; k:
                sum = num[i] + num[j] + num[k]
                <span class="hljs-keyword">if</span> sum == target:
                    <span class="hljs-keyword">return</span> sum

                <span class="hljs-keyword">if</span> abs(sum - target) &lt; abs(result - target):
                    result = sum

                <span class="hljs-keyword">if</span> sum &lt; target:
                    j += <span class="hljs-number">1</span>
                <span class="hljs-keyword">elif</span> sum &gt; target:
                    k -= <span class="hljs-number">1</span>

        <span class="hljs-keyword">return</span> result
</code></pre><h5 id="86-partion-list"><a name="86-partion-list" href="#86-partion-list"></a>86 partion list</h5><p>将一个链表按照大于x的在前面小于的在后面重组<br>直接新申请两个即可。</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;># Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution(object):
    def partition(self, head, x):
        &quot;&quot;&quot;
        :type head: ListNode
        :type x: int
        :rtype: ListNode
        &quot;&quot;&quot;
        root1 = ListNode(0)
        root1bak = root1
        root2 = ListNode(0)
        root2bak = root2
        mid = ''
        while head!=None:
            if head.val&amp;lt;x:
                root1.next = head
                root1 = root1.next
            elif head.val&amp;gt;=x:
                root2.next =head
                root2 = root2.next
            head = head.next
        root2.next = None
        root1.next = root2bak.next
        return root1bak.next
</code></pre>"><span class="hljs-comment"># Definition for singly-linked list.</span>
<span class="hljs-comment"># class ListNode(object):</span>
<span class="hljs-comment">#     def __init__(self, x):</span>
<span class="hljs-comment">#         self.val = x</span>
<span class="hljs-comment">#         self.next = None</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">partition</span><span class="hljs-params">(self, head, x)</span>:</span>
        <span class="hljs-string">"""
        :type head: ListNode
        :type x: int
        :rtype: ListNode
        """</span>
        root1 = ListNode(<span class="hljs-number">0</span>)
        root1bak = root1
        root2 = ListNode(<span class="hljs-number">0</span>)
        root2bak = root2
        mid = <span class="hljs-string">''</span>
        <span class="hljs-keyword">while</span> head!=<span class="hljs-keyword">None</span>:
            <span class="hljs-keyword">if</span> head.val&lt;x:
                root1.next = head
                root1 = root1.next
            <span class="hljs-keyword">elif</span> head.val&gt;=x:
                root2.next =head
                root2 = root2.next
            head = head.next
        root2.next = <span class="hljs-keyword">None</span>
        root1.next = root2bak.next
        <span class="hljs-keyword">return</span> root1bak.next
</code></pre><h5 id="148-链表排序"><a name="148-链表排序" href="#148-链表排序"></a>148 链表排序</h5><p>基本思路就是归并排序。使用快慢指针进行二分然后递归，并且merge</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;># Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution(object):
    def sortList(self, head):
        if not head or not head.next:
            return head
        # divide list into two parts
        fast, slow = head.next, head
        while fast and fast.next:
            fast = fast.next.next
            slow = slow.next
        second = slow.next
         # cut down the first part
        slow.next = None
        l = self.sortList(head)
        r = self.sortList(second)
        return self.merge(l, r)

# merge in-place without dummy node        
    def merge(self, l, r):
        if not l or not r:
            return l or r
        if l.val &amp;gt; r.val:
            l, r = r, l
        # get the return node &quot;head&quot;
        head = pre = l
        l = l.next
        while l and r:
            if l.val &amp;lt; r.val:
                l = l.next
            else:
                nxt = pre.next
                pre.next = r
                tmp = r.next
                r.next = nxt
                r = tmp
            pre = pre.next
    # l and r at least one is None
        pre.next = l or r
        return head
</code></pre>"><span class="hljs-comment"># Definition for singly-linked list.</span>
<span class="hljs-comment"># class ListNode(object):</span>
<span class="hljs-comment">#     def __init__(self, x):</span>
<span class="hljs-comment">#         self.val = x</span>
<span class="hljs-comment">#         self.next = None</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sortList</span><span class="hljs-params">(self, head)</span>:</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> head <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> head.next:
            <span class="hljs-keyword">return</span> head
        <span class="hljs-comment"># divide list into two parts</span>
        fast, slow = head.next, head
        <span class="hljs-keyword">while</span> fast <span class="hljs-keyword">and</span> fast.next:
            fast = fast.next.next
            slow = slow.next
        second = slow.next
         <span class="hljs-comment"># cut down the first part</span>
        slow.next = <span class="hljs-keyword">None</span>
        l = self.sortList(head)
        r = self.sortList(second)
        <span class="hljs-keyword">return</span> self.merge(l, r)

<span class="hljs-comment"># merge in-place without dummy node        </span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">merge</span><span class="hljs-params">(self, l, r)</span>:</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> l <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> r:
            <span class="hljs-keyword">return</span> l <span class="hljs-keyword">or</span> r
        <span class="hljs-keyword">if</span> l.val &gt; r.val:
            l, r = r, l
        <span class="hljs-comment"># get the return node "head"</span>
        head = pre = l
        l = l.next
        <span class="hljs-keyword">while</span> l <span class="hljs-keyword">and</span> r:
            <span class="hljs-keyword">if</span> l.val &lt; r.val:
                l = l.next
            <span class="hljs-keyword">else</span>:
                nxt = pre.next
                pre.next = r
                tmp = r.next
                r.next = nxt
                r = tmp
            pre = pre.next
    <span class="hljs-comment"># l and r at least one is None</span>
        pre.next = l <span class="hljs-keyword">or</span> r
        <span class="hljs-keyword">return</span> head
</code></pre><h5 id="322-coin-changes"><a name="322-coin-changes" href="#322-coin-changes"></a>322 coin changes</h5><p>给定硬币面值和钱数目，求最少硬币数目，不行则返回-1.<br>dp，使用dp[i]存储钱数目为i时最少的硬币数目。则dp[i] = min(dp[i-c] for c in coins)+1<br>之所以加1是因为肯定是前面的循环里肯定是从中选取了一个硬币后的结果，所以后面要加上1。</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>class Solution(object):
    def coinChange(self, coins, amount):
        &quot;&quot;&quot;
        :type coins: List[int]
        :type amount: int
        :rtype: int
        &quot;&quot;&quot;
        MAX = float('inf')
        n = len(coins)
        dp = [0]+[MAX]*amount
        for i in range(1,amount+1):
            dp[i] = min([dp[i-c] if i-c&amp;gt;=0 else MAX for c in coins])+1
        return [dp[amount],-1][dp[amount]==MAX]
</code></pre>"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">coinChange</span><span class="hljs-params">(self, coins, amount)</span>:</span>
        <span class="hljs-string">"""
        :type coins: List[int]
        :type amount: int
        :rtype: int
        """</span>
        MAX = float(<span class="hljs-string">'inf'</span>)
        n = len(coins)
        dp = [<span class="hljs-number">0</span>]+[MAX]*amount
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>,amount+<span class="hljs-number">1</span>):
            dp[i] = min([dp[i-c] <span class="hljs-keyword">if</span> i-c&gt;=<span class="hljs-number">0</span> <span class="hljs-keyword">else</span> MAX <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> coins])+<span class="hljs-number">1</span>
        <span class="hljs-keyword">return</span> [dp[amount],-<span class="hljs-number">1</span>][dp[amount]==MAX]
</code></pre><h5 id="673-number-of-longest-sequence"><a name="673-number-of-longest-sequence" href="#673-number-of-longest-sequence"></a>673 number Of longest sequence</h5><p>给定一个串，最长不降低子串个数。<br>初步思路就是dp来求最长，并且同时还用另一个数组记录到达本点可有的路径数目。<br>不过可惜的是在最后几个例子上超时，看了下其实大家复杂度都一样，n×n这样的。</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>class Solution(object):
    def findNumberOfLIS(self, nums):
        &quot;&quot;&quot;
        :type nums: List[int]
        :rtype: int
        &quot;&quot;&quot;
        # Time: O(n^2)
        # Space: O(n)
        dp, longest = [[1, 1] for i in range(len(nums))], 1
        for i, num in enumerate(nums):
            curr_longest, count = 1, 0
            for j in range(i):
                if nums[j] &amp;lt; num:
                    curr_longest = max(curr_longest, dp[j][0] + 1)
            for j in range(i):
                if dp[j][0] == curr_longest - 1 and nums[j] &amp;lt; num:
                    count += dp[j][1]
            dp[i] = [curr_longest, max(count, dp[i][1])]
            longest = max(curr_longest, longest)
        return sum([item[1] for item in dp if item[0] == longest])
</code></pre>"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findNumberOfLIS</span><span class="hljs-params">(self, nums)</span>:</span>
        <span class="hljs-string">"""
        :type nums: List[int]
        :rtype: int
        """</span>
        <span class="hljs-comment"># Time: O(n^2)</span>
        <span class="hljs-comment"># Space: O(n)</span>
        dp, longest = [[<span class="hljs-number">1</span>, <span class="hljs-number">1</span>] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(nums))], <span class="hljs-number">1</span>
        <span class="hljs-keyword">for</span> i, num <span class="hljs-keyword">in</span> enumerate(nums):
            curr_longest, count = <span class="hljs-number">1</span>, <span class="hljs-number">0</span>
            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(i):
                <span class="hljs-keyword">if</span> nums[j] &lt; num:
                    curr_longest = max(curr_longest, dp[j][<span class="hljs-number">0</span>] + <span class="hljs-number">1</span>)
            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(i):
                <span class="hljs-keyword">if</span> dp[j][<span class="hljs-number">0</span>] == curr_longest - <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> nums[j] &lt; num:
                    count += dp[j][<span class="hljs-number">1</span>]
            dp[i] = [curr_longest, max(count, dp[i][<span class="hljs-number">1</span>])]
            longest = max(curr_longest, longest)
        <span class="hljs-keyword">return</span> sum([item[<span class="hljs-number">1</span>] <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> dp <span class="hljs-keyword">if</span> item[<span class="hljs-number">0</span>] == longest])
</code></pre><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>class Solution(object):
    def findNumberOfLIS(self, nums):
        &quot;&quot;&quot;
        :type nums: List[int]
        :rtype: int
        &quot;&quot;&quot;
        n = len(nums)
        if n==0:
            return 0
        dp = [0 for _ in range(n+1)]
        dp[1] = 1
        res = [1 for _ in range(n+1)]
        for i in range(2,n+1):
            tmp = 0
            for k in range(1,i):
                if nums[i-1-k]&amp;lt;nums[i-1]:
                    tmp = max(dp[i-k],tmp)
            #bj = [dp[i-k] for k in range(1,i) if nums[i-1-k]&amp;lt;nums[i-1]]
            #tmp = 0 if len(bj)==0 else max(bj)
            #print(tmp,bj,i,nums)
            here = 0
            for k in range(1,i):
                if nums[i-1-k]&amp;lt;nums[i-1] and dp[i-k]==tmp:
                    here = here + res[i-k]
            #here = sum([res[i-k] for k in range(1,i) if (nums[i-1-k]&amp;lt;nums[i-1] and dp[i-k]==tmp)])
            dp[i] = tmp+1
            res[i] = here if here&amp;gt;1 else 1
        dp = dp[1:]
        res = res[1:]
        #print(dp)
        #print(res)
        maxl = max(dp)
        r = 0
        for idx,i in enumerate(dp):
            if dp[idx]==maxl:
                r = r + res[idx]
        return r

a = Solution()
print(a.findNumberOfLIS([1,2,4,3,5,4,7,2]))
</code></pre>"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findNumberOfLIS</span><span class="hljs-params">(self, nums)</span>:</span>
        <span class="hljs-string">"""
        :type nums: List[int]
        :rtype: int
        """</span>
        n = len(nums)
        <span class="hljs-keyword">if</span> n==<span class="hljs-number">0</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>
        dp = [<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(n+<span class="hljs-number">1</span>)]
        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>
        res = [<span class="hljs-number">1</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(n+<span class="hljs-number">1</span>)]
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>,n+<span class="hljs-number">1</span>):
            tmp = <span class="hljs-number">0</span>
            <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>,i):
                <span class="hljs-keyword">if</span> nums[i-<span class="hljs-number">1</span>-k]&lt;nums[i-<span class="hljs-number">1</span>]:
                    tmp = max(dp[i-k],tmp)
            <span class="hljs-comment">#bj = [dp[i-k] for k in range(1,i) if nums[i-1-k]&lt;nums[i-1]]</span>
            <span class="hljs-comment">#tmp = 0 if len(bj)==0 else max(bj)</span>
            <span class="hljs-comment">#print(tmp,bj,i,nums)</span>
            here = <span class="hljs-number">0</span>
            <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>,i):
                <span class="hljs-keyword">if</span> nums[i-<span class="hljs-number">1</span>-k]&lt;nums[i-<span class="hljs-number">1</span>] <span class="hljs-keyword">and</span> dp[i-k]==tmp:
                    here = here + res[i-k]
            <span class="hljs-comment">#here = sum([res[i-k] for k in range(1,i) if (nums[i-1-k]&lt;nums[i-1] and dp[i-k]==tmp)])</span>
            dp[i] = tmp+<span class="hljs-number">1</span>
            res[i] = here <span class="hljs-keyword">if</span> here&gt;<span class="hljs-number">1</span> <span class="hljs-keyword">else</span> <span class="hljs-number">1</span>
        dp = dp[<span class="hljs-number">1</span>:]
        res = res[<span class="hljs-number">1</span>:]
        <span class="hljs-comment">#print(dp)</span>
        <span class="hljs-comment">#print(res)</span>
        maxl = max(dp)
        r = <span class="hljs-number">0</span>
        <span class="hljs-keyword">for</span> idx,i <span class="hljs-keyword">in</span> enumerate(dp):
            <span class="hljs-keyword">if</span> dp[idx]==maxl:
                r = r + res[idx]
        <span class="hljs-keyword">return</span> r

a = Solution()
print(a.findNumberOfLIS([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">7</span>,<span class="hljs-number">2</span>]))
</code></pre><h5 id="525-二进制数组最长等量1和0"><a name="525-二进制数组最长等量1和0" href="#525-二进制数组最长等量1和0"></a>525 二进制数组最长等量1和0</h5><p>求二进制数组里最长子串，里面包含等量的0和1.<br>从头开始统计，count，碰到0减1碰到1加1，并且每次都判断此count值是否已经出现过，出现过说明当时的坐标和现在坐标之间是等量的，更新最大值，否则将当前count和坐标存到字典里即可。</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>class Solution(object):
    def findMaxLength(self, nums):
        count = 0
        max_length=0
        table = {0: 0}
        for index, num in enumerate(nums, 1):
            if num == 0:
                count -= 1
            else:
                count += 1

            if count in table:
                max_length = max(max_length, index - table[count])
            else:
                table[count] = index

        return max_length
</code></pre>"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findMaxLength</span><span class="hljs-params">(self, nums)</span>:</span>
        count = <span class="hljs-number">0</span>
        max_length=<span class="hljs-number">0</span>
        table = {<span class="hljs-number">0</span>: <span class="hljs-number">0</span>}
        <span class="hljs-keyword">for</span> index, num <span class="hljs-keyword">in</span> enumerate(nums, <span class="hljs-number">1</span>):
            <span class="hljs-keyword">if</span> num == <span class="hljs-number">0</span>:
                count -= <span class="hljs-number">1</span>
            <span class="hljs-keyword">else</span>:
                count += <span class="hljs-number">1</span>

            <span class="hljs-keyword">if</span> count <span class="hljs-keyword">in</span> table:
                max_length = max(max_length, index - table[count])
            <span class="hljs-keyword">else</span>:
                table[count] = index

        <span class="hljs-keyword">return</span> max_length
</code></pre><h5 id="357"><a name="357" href="#357"></a>357</h5><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>class Solution(object):
    def countNumbersWithUniqueDigits(self, n):
        &quot;&quot;&quot;
        :type n: int
        :rtype: int
        &quot;&quot;&quot;
        res = 0
        if n==1:
            return 10
        if n==0:
            return 1
        for i in range(n,1,-1):
            tmp = 1
            start = 10
            j = i#2
            while j&amp;gt;0:
                tmp = tmp*start
                start = start-1
                j = j -1
            tmp = tmp/10*9
            res = res + tmp
        return res+10
</code></pre>"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">countNumbersWithUniqueDigits</span><span class="hljs-params">(self, n)</span>:</span>
        <span class="hljs-string">"""
        :type n: int
        :rtype: int
        """</span>
        res = <span class="hljs-number">0</span>
        <span class="hljs-keyword">if</span> n==<span class="hljs-number">1</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-number">10</span>
        <span class="hljs-keyword">if</span> n==<span class="hljs-number">0</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(n,<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>):
            tmp = <span class="hljs-number">1</span>
            start = <span class="hljs-number">10</span>
            j = i<span class="hljs-comment">#2</span>
            <span class="hljs-keyword">while</span> j&gt;<span class="hljs-number">0</span>:
                tmp = tmp*start
                start = start-<span class="hljs-number">1</span>
                j = j -<span class="hljs-number">1</span>
            tmp = tmp/<span class="hljs-number">10</span>*<span class="hljs-number">9</span>
            res = res + tmp
        <span class="hljs-keyword">return</span> res+<span class="hljs-number">10</span>
</code></pre><h5 id="300-最长增长子串"><a name="300-最长增长子串" href="#300-最长增长子串"></a>300 最长增长子串</h5><p>dp思路，dp[i]存储当前最长，那么dp[i]=max(dp[i-k] for k in range(1,i) if nums[i-1-k]小于nums[i-1]).也就是当前的最长是要遍历前面已经有过的所有的长度的。当然遍历的时候要确定前面的加上当前是增长的。</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>class Solution(object):
    def lengthOfLIS(self, nums):
        &quot;&quot;&quot;
        :type nums: List[int]
        :rtype: int
        &quot;&quot;&quot;
        n = len(nums)
        if n==0:
            return 0
        dp = [0 for _ in range(n+1)]
        dp[1] = 1
        res = [1 for _ in range(n+1)]
        for i in range(2,n+1):
            tmp = 0
            for k in range(1,i):
                if nums[i-1-k]&amp;lt;nums[i-1]:
                    tmp = max(dp[i-k],tmp)
            dp[i] = tmp+1
        dp = dp[1:]
        maxl = max(dp)
        return maxl
</code></pre>"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(self, nums)</span>:</span>
        <span class="hljs-string">"""
        :type nums: List[int]
        :rtype: int
        """</span>
        n = len(nums)
        <span class="hljs-keyword">if</span> n==<span class="hljs-number">0</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>
        dp = [<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(n+<span class="hljs-number">1</span>)]
        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>
        res = [<span class="hljs-number">1</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(n+<span class="hljs-number">1</span>)]
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>,n+<span class="hljs-number">1</span>):
            tmp = <span class="hljs-number">0</span>
            <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>,i):
                <span class="hljs-keyword">if</span> nums[i-<span class="hljs-number">1</span>-k]&lt;nums[i-<span class="hljs-number">1</span>]:
                    tmp = max(dp[i-k],tmp)
            dp[i] = tmp+<span class="hljs-number">1</span>
        dp = dp[<span class="hljs-number">1</span>:]
        maxl = max(dp)
        <span class="hljs-keyword">return</span> maxl
</code></pre><h5 id="421-最大的亦或值"><a name="421-最大的亦或值" href="#421-最大的亦或值"></a>421 最大的亦或值</h5><p>对数组里两个元素亦或，求最大值是多少，要求N的时间。<br>使用bit的思想，直接判断最后结果。从32位开始向后遍历，依次查看某一位是否有可能为1，有的话则置位1，否则为0.也就是说，对于answer，左移一位后，如果加1后的结果可以由原数组里的元素亦或得到（也就是answer与其中元素亦或等于其中的元素），那么这一位就可以为1.否则为0.也就是可以看做是dp，answer里保持着当前前k位的话最大的亦或值。那么自然dp到最后一位就是答案。<br>Build the answer bit by bit from left to right. For each bit try if it can be set. For example, let’s say the answer so far is 0x10. Assume the next bit to the right is 1 - 0x101. Make a set S of all 3-bit prefixes of nums. If p1 and p2 are two prefixes from S and p1 ^ p2 = 0x101, then 0x101 ^ p1 = p2. By iterating over p1, we can check if 0x101 ^ p1 is also a prefix. If it is - then the rightmost bit can be 1, otherwise it is 0.</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>Build the answer bit by bit from left to right. For each bit try if it can be set. For example, let's say the answer so far is 0x10. Assume the next bit to the right is 1 - 0x101. Make a set S of all 3-bit prefixes of nums. If p1 and p2 are two prefixes from S and p1 ^ p2 = 0x101, then 0x101 ^ p1 = p2. By iterating over p1, we can check if 0x101 ^ p1 is also a prefix. If it is - then the rightmost bit can be 1, otherwise it is 0.
</code></pre>">Build the answer bit by bit from left to right. For each bit try if it can be set. For example, let's say the answer so far is 0x10. Assume the next bit to the right is 1 - 0x101. Make a set S of all 3-bit prefixes of nums. If p1 and p2 are two prefixes from S and p1 ^ p2 = 0x101, then 0x101 ^ p1 = p2. By iterating over p1, we can check if 0x101 ^ p1 is also a prefix. If it is - then the rightmost bit can be 1, otherwise it is 0.
</code></pre><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>class Solution(object):
    def findMaximumXOR(self, nums):
        &quot;&quot;&quot;
        :type nums: List[int]
        :rtype: int
        &quot;&quot;&quot;
        answer = 0
        for i in range(32)[::-1]:
            answer &amp;lt;&amp;lt;= 1
            prefixes = {num &amp;gt;&amp;gt; i for num in nums}
            if i&amp;lt;=6:
                print(answer,prefixes)
            answer += any(answer^1 ^ p in prefixes for p in prefixes)
        return answer
a = Solution()
print(a.findMaximumXOR([3,5,10,25,2,8]))
</code></pre>"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findMaximumXOR</span><span class="hljs-params">(self, nums)</span>:</span>
        <span class="hljs-string">"""
        :type nums: List[int]
        :rtype: int
        """</span>
        answer = <span class="hljs-number">0</span>
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">32</span>)[::-<span class="hljs-number">1</span>]:
            answer &lt;&lt;= <span class="hljs-number">1</span>
            prefixes = {num &gt;&gt; i <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> nums}
            <span class="hljs-keyword">if</span> i&lt;=<span class="hljs-number">6</span>:
                print(answer,prefixes)
            answer += any(answer^<span class="hljs-number">1</span> ^ p <span class="hljs-keyword">in</span> prefixes <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> prefixes)
        <span class="hljs-keyword">return</span> answer
a = Solution()
print(a.findMaximumXOR([<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">10</span>,<span class="hljs-number">25</span>,<span class="hljs-number">2</span>,<span class="hljs-number">8</span>]))
</code></pre><h5 id="423-等长连续增长子序列个数"><a name="423-等长连续增长子序列个数" href="#423-等长连续增长子序列个数"></a>423 等长连续增长子序列个数</h5><p>dp，然后统计即可</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>class Solution(object):
    def numberOfArithmeticSlices(self, A):
        &quot;&quot;&quot;
        :type A: List[int]
        :rtype: int
        &quot;&quot;&quot;
        longgest = 0
        n = len(A)
        dp = [1 for _ in range(n)]
        ori = A[1]-A[0]
        for i in range(1,n):
            if A[i]-A[i-1]==ori:
                dp[i] = dp[i-1]+1
            else:
                dp[i] = 2
                ori = A[i]-A[i-1]
        dp.append(1)
        res = []
        for i in range(n):
            if dp[i]&amp;gt;dp[i+1] and dp[i]&amp;gt;=3:
                res.append(dp[i])
        r = 0
        for i in res:
            if i&amp;gt;3:
                r = r+(i-1)*(i-2)/2
            else:
                r = r+1
        return r
</code></pre>"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">numberOfArithmeticSlices</span><span class="hljs-params">(self, A)</span>:</span>
        <span class="hljs-string">"""
        :type A: List[int]
        :rtype: int
        """</span>
        longgest = <span class="hljs-number">0</span>
        n = len(A)
        dp = [<span class="hljs-number">1</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(n)]
        ori = A[<span class="hljs-number">1</span>]-A[<span class="hljs-number">0</span>]
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>,n):
            <span class="hljs-keyword">if</span> A[i]-A[i-<span class="hljs-number">1</span>]==ori:
                dp[i] = dp[i-<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>
            <span class="hljs-keyword">else</span>:
                dp[i] = <span class="hljs-number">2</span>
                ori = A[i]-A[i-<span class="hljs-number">1</span>]
        dp.append(<span class="hljs-number">1</span>)
        res = []
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(n):
            <span class="hljs-keyword">if</span> dp[i]&gt;dp[i+<span class="hljs-number">1</span>] <span class="hljs-keyword">and</span> dp[i]&gt;=<span class="hljs-number">3</span>:
                res.append(dp[i])
        r = <span class="hljs-number">0</span>
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> res:
            <span class="hljs-keyword">if</span> i&gt;<span class="hljs-number">3</span>:
                r = r+(i-<span class="hljs-number">1</span>)*(i-<span class="hljs-number">2</span>)/<span class="hljs-number">2</span>
            <span class="hljs-keyword">else</span>:
                r = r+<span class="hljs-number">1</span>
        <span class="hljs-keyword">return</span> r
</code></pre><h5 id="507-完美数"><a name="507-完美数" href="#507-完美数"></a>507 完美数</h5><p>其所有约数加起来(不算自己)和为自己的数字。<br>需要注意的是遍历的时候只需要遍历到sqrt(n)就行了。<br>其实完美数总共也没几个，也可以列举出来。</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>class Solution(object):
    def solve(self,n):
        res = set()
        for i in range(1,int(n**0.5+1)):
            if i not in res:
                if n%i==0:
                    res.add(i)
                    res.add(n/i)
            else:
                break
        print(res)
        return res
    def checkPerfectNumber(self, num):
        &quot;&quot;&quot;
        :type num: int
        :rtype: bool
        &quot;&quot;&quot;
        if num&amp;lt;=0:
            return False
        return sum(self.solve(num))==num*2
</code></pre>"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">solve</span><span class="hljs-params">(self,n)</span>:</span>
        res = set()
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>,int(n**<span class="hljs-number">0.5</span>+<span class="hljs-number">1</span>)):
            <span class="hljs-keyword">if</span> i <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> res:
                <span class="hljs-keyword">if</span> n%i==<span class="hljs-number">0</span>:
                    res.add(i)
                    res.add(n/i)
            <span class="hljs-keyword">else</span>:
                <span class="hljs-keyword">break</span>
        print(res)
        <span class="hljs-keyword">return</span> res
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">checkPerfectNumber</span><span class="hljs-params">(self, num)</span>:</span>
        <span class="hljs-string">"""
        :type num: int
        :rtype: bool
        """</span>
        <span class="hljs-keyword">if</span> num&lt;=<span class="hljs-number">0</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">False</span>
        <span class="hljs-keyword">return</span> sum(self.solve(num))==num*<span class="hljs-number">2</span>
</code></pre><h5 id="372-super-pow"><a name="372-super-pow" href="#372-super-pow"></a>372 super pow</h5><p>给定一个数，求它的k次指数，k是以数组给出的，最后结果模上1337.<br>这个从末尾遍历即可，迭代记录下每一位的数字和当前未应该指数的值(2<sup>10,2</sup>100)的指数值。记住每一步都模1337就行。</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>class Solution(object):
    def superPow(self, a, b):
        &quot;&quot;&quot;
        :type a: int
        :type b: List[int]
        :rtype: int
        &quot;&quot;&quot;
        nowres = 1
        nowc = a
        for i in range(len(b)-1,-1,-1):
            nowres = (nowres*(nowc**b[i]%1337))%1337
            nowc = nowc**10%1337
        return nowres
</code></pre>"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">superPow</span><span class="hljs-params">(self, a, b)</span>:</span>
        <span class="hljs-string">"""
        :type a: int
        :type b: List[int]
        :rtype: int
        """</span>
        nowres = <span class="hljs-number">1</span>
        nowc = a
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(b)-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>):
            nowres = (nowres*(nowc**b[i]%<span class="hljs-number">1337</span>))%<span class="hljs-number">1337</span>
            nowc = nowc**<span class="hljs-number">10</span>%<span class="hljs-number">1337</span>
        <span class="hljs-keyword">return</span> nowres
</code></pre><h5 id="129-从根到叶子的和"><a name="129-从根到叶子的和" href="#129-从根到叶子的和"></a>129 从根到叶子的和</h5><p>递归遍历即可</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;># Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution(object):
    def dd(self,root,res):
        if root==None:
            return
        if root.left==None and root.right==None:
            res.append(root.val)
            return
        if root.left!=None:
            root.left.val = root.val*10+root.left.val
            self.dd(root.left,res)
        if root.right!=None:
            root.right.val = root.val*10+root.right.val
            self.dd(root.right,res)


    def sumNumbers(self, root):
        &quot;&quot;&quot;
        :type root: TreeNode
        :rtype: int
        &quot;&quot;&quot;
        res = []
        self.dd(root,res)
        print(res)
        return sum(res)
</code></pre>"><span class="hljs-comment"># Definition for a binary tree node.</span>
<span class="hljs-comment"># class TreeNode(object):</span>
<span class="hljs-comment">#     def __init__(self, x):</span>
<span class="hljs-comment">#         self.val = x</span>
<span class="hljs-comment">#         self.left = None</span>
<span class="hljs-comment">#         self.right = None</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dd</span><span class="hljs-params">(self,root,res)</span>:</span>
        <span class="hljs-keyword">if</span> root==<span class="hljs-keyword">None</span>:
            <span class="hljs-keyword">return</span>
        <span class="hljs-keyword">if</span> root.left==<span class="hljs-keyword">None</span> <span class="hljs-keyword">and</span> root.right==<span class="hljs-keyword">None</span>:
            res.append(root.val)
            <span class="hljs-keyword">return</span>
        <span class="hljs-keyword">if</span> root.left!=<span class="hljs-keyword">None</span>:
            root.left.val = root.val*<span class="hljs-number">10</span>+root.left.val
            self.dd(root.left,res)
        <span class="hljs-keyword">if</span> root.right!=<span class="hljs-keyword">None</span>:
            root.right.val = root.val*<span class="hljs-number">10</span>+root.right.val
            self.dd(root.right,res)


    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sumNumbers</span><span class="hljs-params">(self, root)</span>:</span>
        <span class="hljs-string">"""
        :type root: TreeNode
        :rtype: int
        """</span>
        res = []
        self.dd(root,res)
        print(res)
        <span class="hljs-keyword">return</span> sum(res)
</code></pre><h5 id="481-magic-string"><a name="481-magic-string" href="#481-magic-string"></a>481 magic string</h5><p>给定1和2串，’122112122…’,其中假如从前向后统计重复元素的话数组也是这个数组。<br>求前n个元素里1的个数。<br>以‘122’为初始状态。idx里存储下一个应该重复的次数，初始的时候idx=2，表示下一次应该重复两个。应该重复的元素的值是3-nums[-1].<br>这里比较难想的是初始状态和每次增加的方式。因为我们要依赖原数组里值来判断下一次增加几个，所以这样的方式是比较自然的。如果以‘1’作为初始状态则就没办法向下简单的增加了，那样涉及到数量数组和原始数组里面会有交叠。而一旦通过了这个第一次，则后面的就不会出现交叠，问题也就简单许多。</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>class Solution(object):
    def magicalString(self, n):
        &quot;&quot;&quot;
        :type n: int
        :rtype: int
        &quot;&quot;&quot;
        ori = [1,2,2]
        idx = 2
        while len(ori)&amp;lt;n:
            ori+=ori[idx]*[3-ori[-1]]
            idx += 1
        return ori[0:n].count(1)
</code></pre>"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">magicalString</span><span class="hljs-params">(self, n)</span>:</span>
        <span class="hljs-string">"""
        :type n: int
        :rtype: int
        """</span>
        ori = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>]
        idx = <span class="hljs-number">2</span>
        <span class="hljs-keyword">while</span> len(ori)&lt;n:
            ori+=ori[idx]*[<span class="hljs-number">3</span>-ori[-<span class="hljs-number">1</span>]]
            idx += <span class="hljs-number">1</span>
        <span class="hljs-keyword">return</span> ori[<span class="hljs-number">0</span>:n].count(<span class="hljs-number">1</span>)
</code></pre><h5 id="477-total-hamming-distance"><a name="477-total-hamming-distance" href="#477-total-hamming-distance"></a>477 total hamming distance</h5><p>给定一个数组，求其中两两元素的汉明距离之和。<br>N方的复杂度肯定不行。所以想到使用bit操作。在每一个bit上，该bit位所造成的汉明距离是互不相干的。并且该bit上的距离为0的个数乘1的个数这样(因为是两两组合嘛)。</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>class Solution(object):
    def totalHammingDistance(self, nums):
        &quot;&quot;&quot;
        :type nums: List[int]
        :rtype: int
        &quot;&quot;&quot;
        res = 0
        for i in range(32):
            tmp0 = 0
            tmp1 = 0
            for j in range(len(nums)):
                if nums[j]%2==0:
                    tmp0 = tmp0+1
                else:
                    tmp1 = tmp1 + 1
                nums[j] = nums[j]/2
            res = res + tmp1*tmp0
        return res
</code></pre>"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">totalHammingDistance</span><span class="hljs-params">(self, nums)</span>:</span>
        <span class="hljs-string">"""
        :type nums: List[int]
        :rtype: int
        """</span>
        res = <span class="hljs-number">0</span>
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">32</span>):
            tmp0 = <span class="hljs-number">0</span>
            tmp1 = <span class="hljs-number">0</span>
            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(len(nums)):
                <span class="hljs-keyword">if</span> nums[j]%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>:
                    tmp0 = tmp0+<span class="hljs-number">1</span>
                <span class="hljs-keyword">else</span>:
                    tmp1 = tmp1 + <span class="hljs-number">1</span>
                nums[j] = nums[j]/<span class="hljs-number">2</span>
            res = res + tmp1*tmp0
        <span class="hljs-keyword">return</span> res
</code></pre><h5 id="337-house-rober-3"><a name="337-house-rober-3" href="#337-house-rober-3"></a>337 house rober 3</h5><p>这次偷的是一颗二叉树，要求直接相连的两个点不允许同时偷，问最多偷多少。<br>一开始错误的认为相邻两层不能同时偷其实是错误的，只要被偷的两个点之间不连即可。<br>思考使用dp的思路来递归二叉树。<br>f1(node)表示以node节点的最大偷数目(其中包括了node节点偷和不偷两种),f2则表示node节点不偷的情况。<br>那么，f2（node)=f1(node.left)+f1(node.right)<br>f1(node) = max(f2(node),f1(node.left)+f1(node.right)+node.val)<br>迭代的方式是从根依次向下迭代。<br>二叉树的问题一般都是用递归，这道题使用dp的思路，还要想到如何在二叉树的递归里去使用dp的思路。一般只要相应root节点需要分偷和不偷分情况递归就好了。那样的话就能想到dp[root]=max(root.val+不偷左+不偷右，dp[左]+dp[右]),其中不偷的情况使用另外一个dp变量存储即可，那么考虑在每一层都递归两个值即当前节点偷和不偷两种情况的值，其中偷的情况是通过max计算的。</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;># Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution(object):
    def dd(self,root):
        if root==None:
            return (0,0)
        l = self.dd(root.left)
        r = self.dd(root.right)
        return (l[1]+r[1],max(l[1]+r[1],l[0]+r[0]+root.val))

    def rob(self, root):
        &quot;&quot;&quot;
        :type root: TreeNode
        :rtype: int
        &quot;&quot;&quot;
        return self.dd(root)[1]
</code></pre>"><span class="hljs-comment"># Definition for a binary tree node.</span>
<span class="hljs-comment"># class TreeNode(object):</span>
<span class="hljs-comment">#     def __init__(self, x):</span>
<span class="hljs-comment">#         self.val = x</span>
<span class="hljs-comment">#         self.left = None</span>
<span class="hljs-comment">#         self.right = None</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dd</span><span class="hljs-params">(self,root)</span>:</span>
        <span class="hljs-keyword">if</span> root==<span class="hljs-keyword">None</span>:
            <span class="hljs-keyword">return</span> (<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)
        l = self.dd(root.left)
        r = self.dd(root.right)
        <span class="hljs-keyword">return</span> (l[<span class="hljs-number">1</span>]+r[<span class="hljs-number">1</span>],max(l[<span class="hljs-number">1</span>]+r[<span class="hljs-number">1</span>],l[<span class="hljs-number">0</span>]+r[<span class="hljs-number">0</span>]+root.val))

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">rob</span><span class="hljs-params">(self, root)</span>:</span>
        <span class="hljs-string">"""
        :type root: TreeNode
        :rtype: int
        """</span>
        <span class="hljs-keyword">return</span> self.dd(root)[<span class="hljs-number">1</span>]
</code></pre><h5 id="213-house-rober-2"><a name="213-house-rober-2" href="#213-house-rober-2"></a>213 house rober 2</h5><p>与原始的问题多了一点是头和尾不能同时偷。<br>那么直接将原数组拆成两个不让头和尾都在就行了。</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>class Solution(object):
    def rob1(self,nums):
        if len(nums)==0:
            return 0
        if len(nums)==1:
            return nums[0]
        dp = [0 for i in range(len(nums)+1)]
        dp[0] = 0
        dp[1] = nums[0]
        for i in range(2,len(nums)+1):
            print(i,dp)
            dp[i] = nums[i-1]+max([dp[k] for k in range(0,i-1)])
        print(dp)
        return max(dp)
    def rob(self, nums):
        &quot;&quot;&quot;
        :type nums: List[int]
        :rtype: int
        &quot;&quot;&quot;
        if len(nums)==1:
            return nums[0]
        return max(self.rob1(nums[1:]),self.rob1(nums[0:-1]))
</code></pre>"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">rob1</span><span class="hljs-params">(self,nums)</span>:</span>
        <span class="hljs-keyword">if</span> len(nums)==<span class="hljs-number">0</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>
        <span class="hljs-keyword">if</span> len(nums)==<span class="hljs-number">1</span>:
            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>]
        dp = [<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(nums)+<span class="hljs-number">1</span>)]
        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>
        dp[<span class="hljs-number">1</span>] = nums[<span class="hljs-number">0</span>]
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>,len(nums)+<span class="hljs-number">1</span>):
            print(i,dp)
            dp[i] = nums[i-<span class="hljs-number">1</span>]+max([dp[k] <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>,i-<span class="hljs-number">1</span>)])
        print(dp)
        <span class="hljs-keyword">return</span> max(dp)
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">rob</span><span class="hljs-params">(self, nums)</span>:</span>
        <span class="hljs-string">"""
        :type nums: List[int]
        :rtype: int
        """</span>
        <span class="hljs-keyword">if</span> len(nums)==<span class="hljs-number">1</span>:
            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>]
        <span class="hljs-keyword">return</span> max(self.rob1(nums[<span class="hljs-number">1</span>:]),self.rob1(nums[<span class="hljs-number">0</span>:-<span class="hljs-number">1</span>]))
</code></pre><h5 id="93-重组ip"><a name="93-重组ip" href="#93-重组ip"></a>93 重组ip</h5><p>给定一个ip地址组成的字符串，求解所有可能的ip地址<br>直接遍历可能的第一个ip结尾的位置，第二个ip结尾的位置，第三个ip结尾的位置即可。然后判断是否合法即可。N三次方的复杂度，不过由于ip字符串本身就不会多长，所以还好。<br>合法的要求是长度小于等于3，数值小于255之类和不能以0开头。</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>        def isvaild(s):
            if len(s)&amp;gt;3 or len(s)==0 or s[0]=='0' and len(s)&amp;gt;1 or int(s)&amp;gt;255:
                return False
            return True
        res = []
        n = len(s)
        for i in range(1,min(4,n-2)):
            for j in range(i+1,min(i+4,n-1)):
                for k in range(j+1,min(j+4,n)):
                    s1,s2,s3,s4 = s[0:i],s[i:j],s[j:k],s[k:]
                    if isvaild(s1) and isvaild(s2) and isvaild(s3) and isvaild(s4):
                        res.append('.'.join([s1,s2,s3,s4]))
        return res
</code></pre>">        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isvaild</span><span class="hljs-params">(s)</span>:</span>
            <span class="hljs-keyword">if</span> len(s)&gt;<span class="hljs-number">3</span> <span class="hljs-keyword">or</span> len(s)==<span class="hljs-number">0</span> <span class="hljs-keyword">or</span> s[<span class="hljs-number">0</span>]==<span class="hljs-string">'0'</span> <span class="hljs-keyword">and</span> len(s)&gt;<span class="hljs-number">1</span> <span class="hljs-keyword">or</span> int(s)&gt;<span class="hljs-number">255</span>:
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">False</span>
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">True</span>
        res = []
        n = len(s)
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>,min(<span class="hljs-number">4</span>,n-<span class="hljs-number">2</span>)):
            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(i+<span class="hljs-number">1</span>,min(i+<span class="hljs-number">4</span>,n-<span class="hljs-number">1</span>)):
                <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> range(j+<span class="hljs-number">1</span>,min(j+<span class="hljs-number">4</span>,n)):
                    s1,s2,s3,s4 = s[<span class="hljs-number">0</span>:i],s[i:j],s[j:k],s[k:]
                    <span class="hljs-keyword">if</span> isvaild(s1) <span class="hljs-keyword">and</span> isvaild(s2) <span class="hljs-keyword">and</span> isvaild(s3) <span class="hljs-keyword">and</span> isvaild(s4):
                        res.append(<span class="hljs-string">'.'</span>.join([s1,s2,s3,s4]))
        <span class="hljs-keyword">return</span> res
</code></pre><h5 id="124-二叉树最大和路径"><a name="124-二叉树最大和路径" href="#124-二叉树最大和路径"></a>124 二叉树最大和路径</h5><p>求二叉树任意两个可以连通的节点路径上的和，并且和最大是多少。<br>这个问题和之前一道题类似，都是dp加二叉树递归结合的思路。这次的话递归函数返回两个值f1，f2，其中f1 means the max value can get from this root,the f2 means the max value can get from this point and only have left or right or none path.when point is leaf or half leaf,it should be handdled.</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;># Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution(object):
    def dd(self,root):
        if root.left==None and root.right==None:
            return root.val,root.val
        if root.left==None:
            r = self.dd(root.right)
            return max(root.val+r[1],r[0],root.val),max(root.val,r[1]+root.val,root.val)
        if root.right==None:
            r = self.dd(root.left)
            return max(root.val+r[1],r[0],root.val),max(root.val,r[1]+root.val,root.val)
        if root.left!=None and root.right!=None:
            l = self.dd(root.left)#f2,f1,l,r--f2 not root
            r = self.dd(root.right)
            return max(root.val+l[1],root.val+r[1],root.val+l[1]+r[1],max(l[0],r[0]),root.val),max(l[1]+root.val,r[1]+root.val,root.val)

    def maxPathSum(self, root):
        &quot;&quot;&quot;
        :type root: TreeNode
        :rtype: int
        &quot;&quot;&quot;
        d = self.dd(root)
        print(d)
        return max(d)
</code></pre>"><span class="hljs-comment"># Definition for a binary tree node.</span>
<span class="hljs-comment"># class TreeNode(object):</span>
<span class="hljs-comment">#     def __init__(self, x):</span>
<span class="hljs-comment">#         self.val = x</span>
<span class="hljs-comment">#         self.left = None</span>
<span class="hljs-comment">#         self.right = None</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dd</span><span class="hljs-params">(self,root)</span>:</span>
        <span class="hljs-keyword">if</span> root.left==<span class="hljs-keyword">None</span> <span class="hljs-keyword">and</span> root.right==<span class="hljs-keyword">None</span>:
            <span class="hljs-keyword">return</span> root.val,root.val
        <span class="hljs-keyword">if</span> root.left==<span class="hljs-keyword">None</span>:
            r = self.dd(root.right)
            <span class="hljs-keyword">return</span> max(root.val+r[<span class="hljs-number">1</span>],r[<span class="hljs-number">0</span>],root.val),max(root.val,r[<span class="hljs-number">1</span>]+root.val,root.val)
        <span class="hljs-keyword">if</span> root.right==<span class="hljs-keyword">None</span>:
            r = self.dd(root.left)
            <span class="hljs-keyword">return</span> max(root.val+r[<span class="hljs-number">1</span>],r[<span class="hljs-number">0</span>],root.val),max(root.val,r[<span class="hljs-number">1</span>]+root.val,root.val)
        <span class="hljs-keyword">if</span> root.left!=<span class="hljs-keyword">None</span> <span class="hljs-keyword">and</span> root.right!=<span class="hljs-keyword">None</span>:
            l = self.dd(root.left)<span class="hljs-comment">#f2,f1,l,r--f2 not root</span>
            r = self.dd(root.right)
            <span class="hljs-keyword">return</span> max(root.val+l[<span class="hljs-number">1</span>],root.val+r[<span class="hljs-number">1</span>],root.val+l[<span class="hljs-number">1</span>]+r[<span class="hljs-number">1</span>],max(l[<span class="hljs-number">0</span>],r[<span class="hljs-number">0</span>]),root.val),max(l[<span class="hljs-number">1</span>]+root.val,r[<span class="hljs-number">1</span>]+root.val,root.val)

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maxPathSum</span><span class="hljs-params">(self, root)</span>:</span>
        <span class="hljs-string">"""
        :type root: TreeNode
        :rtype: int
        """</span>
        d = self.dd(root)
        print(d)
        <span class="hljs-keyword">return</span> max(d)
</code></pre><h5 id="224-basic-calculator"><a name="224-basic-calculator" href="#224-basic-calculator"></a>224 basic calculator</h5><p>给定一个包含数字加减括号的字符串求值。<br>使用栈来做，里面需要注意的数字长度可能不是1这个需要单独处理，其他的按照对应下一个输入是什么来对栈进行相关操作即可。</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>class Solution(object):
    def calculate(self, s):
        &quot;&quot;&quot;
        :type s: str
        :rtype: int
        &quot;&quot;&quot;
        s = s.replace(' ','')
        shuziset = {'1','2','3','4','5','6','7','8','9','0'}
        n = len(s)
        stack = []
        start = 0
        while start&amp;lt;len(s) and s[start] in shuziset:
            start = start + 1
        if s[0] in shuziset:
            start = max(start,1)
            stack.append(int(s[0:start]))
        else:
            start = max(start,1)
            stack.append(s[0:start])
        idx = 1
        def zenjia(nowshuzi,s):
            if len(stack)==0:
                stack.append(nowshuzi)
                return
            if s:
                if stack[-1] in {'+','-'}:
                    fuhao = stack.pop()
                    shuzi = stack.pop()
                    res = 0
                    if fuhao=='+':
                        res = shuzi+nowshuzi
                    else:
                        res = shuzi-nowshuzi
                    zenjia(res,True)
                else:
                    #print('e',stack)
                    stack.append(nowshuzi)
            elif nowshuzi in {'+','-','('}:
                stack.append(nowshuzi)
            else:
                value = stack.pop()
                stack.pop()
                zenjia(value,True)
        while len(stack)!=0 and idx&amp;lt;len(s):
            #print(idx,stack)
            if s[idx] in shuziset:
                start = idx
                end = start
                while idx&amp;lt;len(s) and s[idx] in shuziset:
                    idx = idx + 1
                idx = max(idx,start+1)
                nowshuzi = int(s[start:idx])
                #print('w',idx,'g',nowshuzi)
                zenjia(nowshuzi,True)
            else:
                zenjia(s[idx],False)
                idx = idx + 1
        return stack[0]
</code></pre>"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">calculate</span><span class="hljs-params">(self, s)</span>:</span>
        <span class="hljs-string">"""
        :type s: str
        :rtype: int
        """</span>
        s = s.replace(<span class="hljs-string">' '</span>,<span class="hljs-string">''</span>)
        shuziset = {<span class="hljs-string">'1'</span>,<span class="hljs-string">'2'</span>,<span class="hljs-string">'3'</span>,<span class="hljs-string">'4'</span>,<span class="hljs-string">'5'</span>,<span class="hljs-string">'6'</span>,<span class="hljs-string">'7'</span>,<span class="hljs-string">'8'</span>,<span class="hljs-string">'9'</span>,<span class="hljs-string">'0'</span>}
        n = len(s)
        stack = []
        start = <span class="hljs-number">0</span>
        <span class="hljs-keyword">while</span> start&lt;len(s) <span class="hljs-keyword">and</span> s[start] <span class="hljs-keyword">in</span> shuziset:
            start = start + <span class="hljs-number">1</span>
        <span class="hljs-keyword">if</span> s[<span class="hljs-number">0</span>] <span class="hljs-keyword">in</span> shuziset:
            start = max(start,<span class="hljs-number">1</span>)
            stack.append(int(s[<span class="hljs-number">0</span>:start]))
        <span class="hljs-keyword">else</span>:
            start = max(start,<span class="hljs-number">1</span>)
            stack.append(s[<span class="hljs-number">0</span>:start])
        idx = <span class="hljs-number">1</span>
        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">zenjia</span><span class="hljs-params">(nowshuzi,s)</span>:</span>
            <span class="hljs-keyword">if</span> len(stack)==<span class="hljs-number">0</span>:
                stack.append(nowshuzi)
                <span class="hljs-keyword">return</span>
            <span class="hljs-keyword">if</span> s:
                <span class="hljs-keyword">if</span> stack[-<span class="hljs-number">1</span>] <span class="hljs-keyword">in</span> {<span class="hljs-string">'+'</span>,<span class="hljs-string">'-'</span>}:
                    fuhao = stack.pop()
                    shuzi = stack.pop()
                    res = <span class="hljs-number">0</span>
                    <span class="hljs-keyword">if</span> fuhao==<span class="hljs-string">'+'</span>:
                        res = shuzi+nowshuzi
                    <span class="hljs-keyword">else</span>:
                        res = shuzi-nowshuzi
                    zenjia(res,<span class="hljs-keyword">True</span>)
                <span class="hljs-keyword">else</span>:
                    <span class="hljs-comment">#print('e',stack)</span>
                    stack.append(nowshuzi)
            <span class="hljs-keyword">elif</span> nowshuzi <span class="hljs-keyword">in</span> {<span class="hljs-string">'+'</span>,<span class="hljs-string">'-'</span>,<span class="hljs-string">'('</span>}:
                stack.append(nowshuzi)
            <span class="hljs-keyword">else</span>:
                value = stack.pop()
                stack.pop()
                zenjia(value,<span class="hljs-keyword">True</span>)
        <span class="hljs-keyword">while</span> len(stack)!=<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> idx&lt;len(s):
            <span class="hljs-comment">#print(idx,stack)</span>
            <span class="hljs-keyword">if</span> s[idx] <span class="hljs-keyword">in</span> shuziset:
                start = idx
                end = start
                <span class="hljs-keyword">while</span> idx&lt;len(s) <span class="hljs-keyword">and</span> s[idx] <span class="hljs-keyword">in</span> shuziset:
                    idx = idx + <span class="hljs-number">1</span>
                idx = max(idx,start+<span class="hljs-number">1</span>)
                nowshuzi = int(s[start:idx])
                <span class="hljs-comment">#print('w',idx,'g',nowshuzi)</span>
                zenjia(nowshuzi,<span class="hljs-keyword">True</span>)
            <span class="hljs-keyword">else</span>:
                zenjia(s[idx],<span class="hljs-keyword">False</span>)
                idx = idx + <span class="hljs-number">1</span>
        <span class="hljs-keyword">return</span> stack[<span class="hljs-number">0</span>]
</code></pre><h5 id="377-combination-sum-4"><a name="377-combination-sum-4" href="#377-combination-sum-4"></a>377 combination sum 4</h5><p>数组和target，求数组里元素可以组成target的方式的数目，元素可以重复使用。<br>使用dp的思路。dp[i]为target为i时的思路，为了方便break将原数组进行排序。</p><pre><code data-origin="<pre><code>class Solution(object):
    def combinationSum4(self, nums, target):
        nums, combs = sorted(nums), [1] + [0] * (target)
        for i in range(target + 1):
            for num in nums:
                if num  &amp;gt; i: break
                if num == i: combs[i] += 1
                if num  &amp;lt; i: combs[i] += combs[i - num]
        return combs[target]
</code></pre>">class Solution(object):
    def combinationSum4(self, nums, target):
        nums, combs = sorted(nums), [1] + [0] * (target)
        for i in range(target + 1):
            for num in nums:
                if num  &gt; i: break
                if num == i: combs[i] += 1
                if num  &lt; i: combs[i] += combs[i - num]
        return combs[target]
</code></pre><h5 id="222-统计完全二叉树节点个数"><a name="222-统计完全二叉树节点个数" href="#222-统计完全二叉树节点个数"></a>222 统计完全二叉树节点个数</h5><p>显然通过一次遍历即可，但是那样复杂度是N,而完全二叉树的特点使得有可能更快求出。<br>主要是根据二叉树最后一个节点是在哪里为分，在左子树说明右子树是满的，反之已然。<br>The height of a tree can be found by just going left. Let a single node tree have height 0. Find the height h of the whole tree. If the whole tree is empty, i.e., has height -1, there are 0 nodes.</p><p>Otherwise check whether the height of the right subtree is just one less than that of the whole tree, meaning left and right subtree have the same height.</p><p>If yes, then the last node on the last tree row is in the right subtree and the left subtree is a full tree of height h-1. So we take the 2^h-1 nodes of the left subtree plus the 1 root node plus recursively the number of nodes in the right subtree.<br>If no, then the last node on the last tree row is in the left subtree and the right subtree is a full tree of height h-2. So we take the 2^(h-1)-1 nodes of the right subtree plus the 1 root node plus recursively the number of nodes in the left subtree.<br>Since I halve the tree in every recursive step, I have O(log(n)) steps. Finding a height costs O(log(n)). So overall O(log(n)^2).</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;># Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def height(self,root):
        return -1 if root==None else 1+self.height(root.left)
    def countNodes(self,root):
        h = self.height(root)
        return 0 if h&amp;lt;0 else (1&amp;lt;&amp;lt;h)+self.countNodes(root.right) if self.height(root.right)==h-1 else (1&amp;lt;&amp;lt;h-1)+self.countNodes(root.left)
</code></pre>"><span class="hljs-comment"># Definition for a binary tree node.</span>
<span class="hljs-comment"># class TreeNode(object):</span>
<span class="hljs-comment">#     def __init__(self, x):</span>
<span class="hljs-comment">#         self.val = x</span>
<span class="hljs-comment">#         self.left = None</span>
<span class="hljs-comment">#         self.right = None</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">height</span><span class="hljs-params">(self,root)</span>:</span>
        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span> <span class="hljs-keyword">if</span> root==<span class="hljs-keyword">None</span> <span class="hljs-keyword">else</span> <span class="hljs-number">1</span>+self.height(root.left)
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">countNodes</span><span class="hljs-params">(self,root)</span>:</span>
        h = self.height(root)
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> h&lt;<span class="hljs-number">0</span> <span class="hljs-keyword">else</span> (<span class="hljs-number">1</span>&lt;&lt;h)+self.countNodes(root.right) <span class="hljs-keyword">if</span> self.height(root.right)==h-<span class="hljs-number">1</span> <span class="hljs-keyword">else</span> (<span class="hljs-number">1</span>&lt;&lt;h-<span class="hljs-number">1</span>)+self.countNodes(root.left)
</code></pre><h5 id="445-add-two-numbers-2"><a name="445-add-two-numbers-2" href="#445-add-two-numbers-2"></a>445 add two numbers 2</h5><p>给定两个以链表形式给出的数字求和。<br>利用栈存储下链表的内容然后按照数组求和方式求即可。</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;># Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution(object):
    def addTwoNumbers(self, l1, l2):
        &quot;&quot;&quot;
        :type l1: ListNode
        :type l2: ListNode
        :rtype: ListNode
        &quot;&quot;&quot;
        if l1==None or l2==None:
            return l1 if l1!=None else l2
        stack1 = []
        stack2 = []
        while l1!=None:
            stack1.append(l1.val)
            l1 = l1.next
        while l2!=None:
            stack2.append(l2.val)
            l2 = l2.next
        nowout = 0
        res = []
        while len(stack1)+len(stack2)&amp;gt;0:
            n1 = 0
            n2 = 0
            if len(stack1)!=0:
                n1 = stack1.pop()
            if len(stack2)!=0:
                n2 = stack2.pop()
            r = (n1+n2+nowout)%10
            nowout = (n1+n2+nowout)/10
            res.append(r)
        if nowout!=0:
            res.append(nowout)
        print(res)
        head = ListNode(res[-1])
        ttt = head
        for i in range(len(res)-2,-1,-1):
            head.next = ListNode(res[i])
            head = head.next
        return ttt
</code></pre>"><span class="hljs-comment"># Definition for singly-linked list.</span>
<span class="hljs-comment"># class ListNode(object):</span>
<span class="hljs-comment">#     def __init__(self, x):</span>
<span class="hljs-comment">#         self.val = x</span>
<span class="hljs-comment">#         self.next = None</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(self, l1, l2)</span>:</span>
        <span class="hljs-string">"""
        :type l1: ListNode
        :type l2: ListNode
        :rtype: ListNode
        """</span>
        <span class="hljs-keyword">if</span> l1==<span class="hljs-keyword">None</span> <span class="hljs-keyword">or</span> l2==<span class="hljs-keyword">None</span>:
            <span class="hljs-keyword">return</span> l1 <span class="hljs-keyword">if</span> l1!=<span class="hljs-keyword">None</span> <span class="hljs-keyword">else</span> l2
        stack1 = []
        stack2 = []
        <span class="hljs-keyword">while</span> l1!=<span class="hljs-keyword">None</span>:
            stack1.append(l1.val)
            l1 = l1.next
        <span class="hljs-keyword">while</span> l2!=<span class="hljs-keyword">None</span>:
            stack2.append(l2.val)
            l2 = l2.next
        nowout = <span class="hljs-number">0</span>
        res = []
        <span class="hljs-keyword">while</span> len(stack1)+len(stack2)&gt;<span class="hljs-number">0</span>:
            n1 = <span class="hljs-number">0</span>
            n2 = <span class="hljs-number">0</span>
            <span class="hljs-keyword">if</span> len(stack1)!=<span class="hljs-number">0</span>:
                n1 = stack1.pop()
            <span class="hljs-keyword">if</span> len(stack2)!=<span class="hljs-number">0</span>:
                n2 = stack2.pop()
            r = (n1+n2+nowout)%<span class="hljs-number">10</span>
            nowout = (n1+n2+nowout)/<span class="hljs-number">10</span>
            res.append(r)
        <span class="hljs-keyword">if</span> nowout!=<span class="hljs-number">0</span>:
            res.append(nowout)
        print(res)
        head = ListNode(res[-<span class="hljs-number">1</span>])
        ttt = head
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(res)-<span class="hljs-number">2</span>,-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>):
            head.next = ListNode(res[i])
            head = head.next
        <span class="hljs-keyword">return</span> ttt
</code></pre><h5 id="138-deepcopy一个带有随机指针的链表"><a name="138-deepcopy一个带有随机指针的链表" href="#138-deepcopy一个带有随机指针的链表"></a>138 deepcopy一个带有随机指针的链表</h5><p>copy链表简单，但是这个有随机指针，开始的时候没想到，后来想到可以在建立链表的时候对每个节点都编一个号，而后第二次遍历看原链表的random对应的标号即可。</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;># Definition for singly-linked list with a random pointer.
# class RandomListNode(object):
#     def __init__(self, x):
#         self.label = x
#         self.next = None
#         self.random = None

class Solution(object):
    def copyRandomList(self, head):
        &quot;&quot;&quot;
        :type head: RandomListNode
        :rtype: RandomListNode
        &quot;&quot;&quot;
        if head == None:
            return None
        d = {}
        d1 = {}
        newhead = RandomListNode(0)
        newheadbak = newhead
        headbak = head
        idx = 1
        while head!=None:
            tmp = RandomListNode(head.label)
            newhead.next = tmp
            d[idx] = tmp
            d1[head] = idx
            head = head.next
            newhead = newhead.next
            idx = idx + 1
        newheadbakbak = newheadbak
        newheadbak = newheadbak.next
        while headbak!=None:
            if headbak.random == None:
                headbak = headbak.next
                newheadbak = newheadbak.next
            else:
                nidx = d1[headbak.random]
                newheadbak.random = d[nidx]
                headbak = headbak.next
                newheadbak = newheadbak.next
        return newheadbakbak.next
</code></pre>"><span class="hljs-comment"># Definition for singly-linked list with a random pointer.</span>
<span class="hljs-comment"># class RandomListNode(object):</span>
<span class="hljs-comment">#     def __init__(self, x):</span>
<span class="hljs-comment">#         self.label = x</span>
<span class="hljs-comment">#         self.next = None</span>
<span class="hljs-comment">#         self.random = None</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">copyRandomList</span><span class="hljs-params">(self, head)</span>:</span>
        <span class="hljs-string">"""
        :type head: RandomListNode
        :rtype: RandomListNode
        """</span>
        <span class="hljs-keyword">if</span> head == <span class="hljs-keyword">None</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">None</span>
        d = {}
        d1 = {}
        newhead = RandomListNode(<span class="hljs-number">0</span>)
        newheadbak = newhead
        headbak = head
        idx = <span class="hljs-number">1</span>
        <span class="hljs-keyword">while</span> head!=<span class="hljs-keyword">None</span>:
            tmp = RandomListNode(head.label)
            newhead.next = tmp
            d[idx] = tmp
            d1[head] = idx
            head = head.next
            newhead = newhead.next
            idx = idx + <span class="hljs-number">1</span>
        newheadbakbak = newheadbak
        newheadbak = newheadbak.next
        <span class="hljs-keyword">while</span> headbak!=<span class="hljs-keyword">None</span>:
            <span class="hljs-keyword">if</span> headbak.random == <span class="hljs-keyword">None</span>:
                headbak = headbak.next
                newheadbak = newheadbak.next
            <span class="hljs-keyword">else</span>:
                nidx = d1[headbak.random]
                newheadbak.random = d[nidx]
                headbak = headbak.next
                newheadbak = newheadbak.next
        <span class="hljs-keyword">return</span> newheadbakbak.next
</code></pre><h5 id="475-heaters"><a name="475-heaters" href="#475-heaters"></a>475 heaters</h5><p>给定两个坐标数组，一个是房子一个是火炉，要求火炉辐射半径最小使得所有房子都被温暖。<br>这个很直觉，求解每个房子里的最近的火炉有多远，而后所有房子取最大值即可。</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>class Solution(object):
    def findRadius(self, houses, heaters):
        &quot;&quot;&quot;
        :type houses: List[int]
        :type heaters: List[int]
        :rtype: int
        &quot;&quot;&quot;
        heaters.sort()
        import bisect
        res = []
        if len(heaters)==1:
            return max([abs(i-heaters[0]) for i in houses])
        for i in houses:
            idx = bisect.bisect(heaters,i)
            #print(heaters,i,idx)
            if idx==0:
                res.append(abs(heaters[0]-i))
            elif idx==len(heaters):
                res.append(abs(i-heaters[-1]))
            else:
                res.append(min(i-heaters[idx-1],heaters[idx]-i))
        print(res)
        return max(res)
</code></pre>"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findRadius</span><span class="hljs-params">(self, houses, heaters)</span>:</span>
        <span class="hljs-string">"""
        :type houses: List[int]
        :type heaters: List[int]
        :rtype: int
        """</span>
        heaters.sort()
        <span class="hljs-keyword">import</span> bisect
        res = []
        <span class="hljs-keyword">if</span> len(heaters)==<span class="hljs-number">1</span>:
            <span class="hljs-keyword">return</span> max([abs(i-heaters[<span class="hljs-number">0</span>]) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> houses])
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> houses:
            idx = bisect.bisect(heaters,i)
            <span class="hljs-comment">#print(heaters,i,idx)</span>
            <span class="hljs-keyword">if</span> idx==<span class="hljs-number">0</span>:
                res.append(abs(heaters[<span class="hljs-number">0</span>]-i))
            <span class="hljs-keyword">elif</span> idx==len(heaters):
                res.append(abs(i-heaters[-<span class="hljs-number">1</span>]))
            <span class="hljs-keyword">else</span>:
                res.append(min(i-heaters[idx-<span class="hljs-number">1</span>],heaters[idx]-i))
        print(res)
        <span class="hljs-keyword">return</span> max(res)
</code></pre><h5 id="236-最低公共父节点"><a name="236-最低公共父节点" href="#236-最低公共父节点"></a>236 最低公共父节点</h5><p>给定一颗二叉树和两个节点，求最低公共父节点。<br>首先想到肯定还是使用递归去做。递归函数返回值就直接返回结果，那么对于某个递归过程，如果其下面根本找不到这两个节点，返回None就是了。如果该节点是这两个值之一就返回这个节点。<br>如此这样的话，对于root节点，left和right的返回值去确定返回值。如果left和right都不是None说明两边各自有一个这时候返回root，否则必定有一边是None返回另一个即可。</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>class Solution(object):
    def lowestCommonAncestor(self, root, p, q):
        &quot;&quot;&quot;
        :type root: TreeNode
        :type p: TreeNode
        :type q: TreeNode
        :rtype: TreeNode
        &quot;&quot;&quot;
        if root in (None, p, q): return root
        left, right = (self.lowestCommonAncestor(kid, p, q)
                   for kid in (root.left, root.right))
        return root if left and right else left or right
</code></pre>"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(self, root, p, q)</span>:</span>
        <span class="hljs-string">"""
        :type root: TreeNode
        :type p: TreeNode
        :type q: TreeNode
        :rtype: TreeNode
        """</span>
        <span class="hljs-keyword">if</span> root <span class="hljs-keyword">in</span> (<span class="hljs-keyword">None</span>, p, q): <span class="hljs-keyword">return</span> root
        left, right = (self.lowestCommonAncestor(kid, p, q)
                   <span class="hljs-keyword">for</span> kid <span class="hljs-keyword">in</span> (root.left, root.right))
        <span class="hljs-keyword">return</span> root <span class="hljs-keyword">if</span> left <span class="hljs-keyword">and</span> right <span class="hljs-keyword">else</span> left <span class="hljs-keyword">or</span> right
</code></pre><h5 id="334-连续增长3个元素"><a name="334-连续增长3个元素" href="#334-连续增长3个元素"></a>334 连续增长3个元素</h5><p>给定数组，问里面有没有三个元素按照原坐标顺序来说是增长的。<br>这个问题一开始觉得可能要求出最长增长序列，后来想到其实既然已经确定是3个了，就简单了，min来存储目前为止最小的数，max存储目前为止仅仅比min大的数。后续如果元素小于min则更新min，大于max则认为已经有了3个，小于max但是大于min则更新max。初始化max为一个极大值。相当于初始的min和max就是max排在min后面，那么后续碰到比min更小的，也可以更新min，因为反正我们返回true是靠判断是不是有大于max的，如果碰到大于max的，那么肯定是够3个了，如果碰到中间的，说明还是两个，并且可以降低下maxn值。</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>class Solution(object):
    def increasingTriplet(self, nums):
        &quot;&quot;&quot;
        :type nums: List[int]
        :rtype: bool
        &quot;&quot;&quot;
        if len(nums)&amp;lt;=3:
            return False
        maxn = float('inf')
        minn = nums[0]
        for i in range(len(nums)):
            if nums[i]&amp;lt;minn:
                minn = nums[i]
            elif nums[i]&amp;gt;maxn:
                return True
            elif nums[i]&amp;gt;minn:
                maxn = nums[i]
        return False
</code></pre>"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">increasingTriplet</span><span class="hljs-params">(self, nums)</span>:</span>
        <span class="hljs-string">"""
        :type nums: List[int]
        :rtype: bool
        """</span>
        <span class="hljs-keyword">if</span> len(nums)&lt;=<span class="hljs-number">3</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">False</span>
        maxn = float(<span class="hljs-string">'inf'</span>)
        minn = nums[<span class="hljs-number">0</span>]
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(nums)):
            <span class="hljs-keyword">if</span> nums[i]&lt;minn:
                minn = nums[i]
            <span class="hljs-keyword">elif</span> nums[i]&gt;maxn:
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">True</span>
            <span class="hljs-keyword">elif</span> nums[i]&gt;minn:
                maxn = nums[i]
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">False</span>
</code></pre><h5 id="605-can-place-flower"><a name="605-can-place-flower" href="#605-can-place-flower"></a>605 can place flower</h5><p>给定一个数组0,1,1代表已经种了花0表示没有，问还需要种n棵花能种下嘛。其中不允许两颗花挨着。<br>分析下，每一株原来已经有的花的位置和两边位置不允许再种。那么剩下的位置，连续可种的长度为1，可种1，为2可种1，为3可种2，之类。</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>class Solution(object):
    def canPlaceFlowers(self, flowerbed, n):
        &quot;&quot;&quot;
        :type flowerbed: List[int]
        :type n: int
        :rtype: bool
        &quot;&quot;&quot;
        lll = n
        n = len(flowerbed)
        def isvalid(idx):
            if idx&amp;gt;=0 and idx&amp;lt;n:
                return True
            return False
        a = [0 for i in range(len(flowerbed))]
        for i in range(len(flowerbed)):
            if flowerbed[i]==1:
                left,now,right = i-1,i,i+1
                if isvalid(left):
                    a[left] = 1
                if isvalid(now):
                    a[now] = 1
                if isvalid(right):
                    a[right] = 1
        if sum(a)==n:
            return 0&amp;gt;=lll
        res = 0
        start = 0
        while a[start]!=0:
            start = start + 1
        print(a,start)
        while start&amp;lt;len(flowerbed):
            end = start+1
            if end&amp;gt;=len(flowerbed):
                res = res + 1
                break
            while end&amp;lt;n and a[end]==0:
                end = end + 1
            print(start,end)
            jv = end - start
            res = res + (jv+1)/2
            while end&amp;lt;n and a[end]!=0:
                end = end + 1
            if end==n-1 and a[end]!=0:
                break
            start = end
        print(res)
        return res&amp;gt;=lll
</code></pre>"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">canPlaceFlowers</span><span class="hljs-params">(self, flowerbed, n)</span>:</span>
        <span class="hljs-string">"""
        :type flowerbed: List[int]
        :type n: int
        :rtype: bool
        """</span>
        lll = n
        n = len(flowerbed)
        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isvalid</span><span class="hljs-params">(idx)</span>:</span>
            <span class="hljs-keyword">if</span> idx&gt;=<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> idx&lt;n:
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">True</span>
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">False</span>
        a = [<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(flowerbed))]
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(flowerbed)):
            <span class="hljs-keyword">if</span> flowerbed[i]==<span class="hljs-number">1</span>:
                left,now,right = i-<span class="hljs-number">1</span>,i,i+<span class="hljs-number">1</span>
                <span class="hljs-keyword">if</span> isvalid(left):
                    a[left] = <span class="hljs-number">1</span>
                <span class="hljs-keyword">if</span> isvalid(now):
                    a[now] = <span class="hljs-number">1</span>
                <span class="hljs-keyword">if</span> isvalid(right):
                    a[right] = <span class="hljs-number">1</span>
        <span class="hljs-keyword">if</span> sum(a)==n:
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>&gt;=lll
        res = <span class="hljs-number">0</span>
        start = <span class="hljs-number">0</span>
        <span class="hljs-keyword">while</span> a[start]!=<span class="hljs-number">0</span>:
            start = start + <span class="hljs-number">1</span>
        print(a,start)
        <span class="hljs-keyword">while</span> start&lt;len(flowerbed):
            end = start+<span class="hljs-number">1</span>
            <span class="hljs-keyword">if</span> end&gt;=len(flowerbed):
                res = res + <span class="hljs-number">1</span>
                <span class="hljs-keyword">break</span>
            <span class="hljs-keyword">while</span> end&lt;n <span class="hljs-keyword">and</span> a[end]==<span class="hljs-number">0</span>:
                end = end + <span class="hljs-number">1</span>
            print(start,end)
            jv = end - start
            res = res + (jv+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>
            <span class="hljs-keyword">while</span> end&lt;n <span class="hljs-keyword">and</span> a[end]!=<span class="hljs-number">0</span>:
                end = end + <span class="hljs-number">1</span>
            <span class="hljs-keyword">if</span> end==n-<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> a[end]!=<span class="hljs-number">0</span>:
                <span class="hljs-keyword">break</span>
            start = end
        print(res)
        <span class="hljs-keyword">return</span> res&gt;=lll
</code></pre><h5 id="72-编辑距离"><a name="72-编辑距离" href="#72-编辑距离"></a>72 编辑距离</h5><p>直接考虑dp。do(i)(j)表示word1第1位前和word2第j位前距离，那么主要看word1(i)与word2(j)是否相同，相同的话则dp(i)(j)=dp(i-1)(j-1)，否则的话dp(i)(j)=min(dp(i-1)(j-1),dp(i-1)(j),dp(i)(j-1))+1.<br>这里有一个点就是当当前位相同的时候直接取左上角而不是在做minl，这个是因为当前位相同则可以直接忽略当前位，不这样做就会错误。如”a”和”aa”,碰到第二个位置如果还是按照min的话就会出现错误。</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>class Solution(object):
    def minDistance(self, word1, word2):
        &quot;&quot;&quot;
        :type word1: str
        :type word2: str
        :rtype: int
        &quot;&quot;&quot;
        m = len(word1)
        n = len(word2)
        dp = [[0]*(n+1) for i in range(m+1)]
        for i in range(n+1):
            dp[0][i] = i
        for i in range(m+1):
            dp[i][0] = i
        for i in range(1,m+1):
            for j in range(1,n+1):
                now = 0 if word1[i-1]==word2[j-1] else 1
                if now ==1:
                    dp[i][j] = min(dp[i-1][j-1],dp[i-1][j],dp[i][j-1])+now
                else:
                    dp[i][j] = dp[i-1][j-1]
        #print(dp)
        return dp[m][n]
</code></pre>"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">minDistance</span><span class="hljs-params">(self, word1, word2)</span>:</span>
        <span class="hljs-string">"""
        :type word1: str
        :type word2: str
        :rtype: int
        """</span>
        m = len(word1)
        n = len(word2)
        dp = [[<span class="hljs-number">0</span>]*(n+<span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(m+<span class="hljs-number">1</span>)]
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(n+<span class="hljs-number">1</span>):
            dp[<span class="hljs-number">0</span>][i] = i
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(m+<span class="hljs-number">1</span>):
            dp[i][<span class="hljs-number">0</span>] = i
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>,m+<span class="hljs-number">1</span>):
            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>,n+<span class="hljs-number">1</span>):
                now = <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> word1[i-<span class="hljs-number">1</span>]==word2[j-<span class="hljs-number">1</span>] <span class="hljs-keyword">else</span> <span class="hljs-number">1</span>
                <span class="hljs-keyword">if</span> now ==<span class="hljs-number">1</span>:
                    dp[i][j] = min(dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>],dp[i-<span class="hljs-number">1</span>][j],dp[i][j-<span class="hljs-number">1</span>])+now
                <span class="hljs-keyword">else</span>:
                    dp[i][j] = dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>]
        <span class="hljs-comment">#print(dp)</span>
        <span class="hljs-keyword">return</span> dp[m][n]
</code></pre><h5 id="54-spiral-matrix"><a name="54-spiral-matrix" href="#54-spiral-matrix"></a>54 spiral matrix</h5><p>螺旋遍历方阵。<br>对于一个元素遍历完后就不要了所以可以想到使用pop来做这样四个的遍历。每次遍历前检查是否为空或者是否允许当前状态的遍历。</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>class Solution:
    def spiralOrder(self,matrix):
        ret = []
        while matrix:
            ret = ret + matrix.pop(0)
            if matrix and matrix[0]:
                for row in matrix:
                    ret.append(row.pop())
            if matrix:
                ret = ret + matrix.pop(0)[::-1]
            if matrix and matrix[0]:
                for row in matrix[::-1]:
                    ret.append(row.pop(0))
        return ret
</code></pre>"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">spiralOrder</span><span class="hljs-params">(self,matrix)</span>:</span>
        ret = []
        <span class="hljs-keyword">while</span> matrix:
            ret = ret + matrix.pop(<span class="hljs-number">0</span>)
            <span class="hljs-keyword">if</span> matrix <span class="hljs-keyword">and</span> matrix[<span class="hljs-number">0</span>]:
                <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> matrix:
                    ret.append(row.pop())
            <span class="hljs-keyword">if</span> matrix:
                ret = ret + matrix.pop(<span class="hljs-number">0</span>)[::-<span class="hljs-number">1</span>]
            <span class="hljs-keyword">if</span> matrix <span class="hljs-keyword">and</span> matrix[<span class="hljs-number">0</span>]:
                <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> matrix[::-<span class="hljs-number">1</span>]:
                    ret.append(row.pop(<span class="hljs-number">0</span>))
        <span class="hljs-keyword">return</span> ret
</code></pre><h5 id="652-find-duplicate-subtree"><a name="652-find-duplicate-subtree" href="#652-find-duplicate-subtree"></a>652 find duplicate subtree</h5><p>给定一颗二叉树，查看里面是否有两颗完全相同的子树，有的话，返回其中一个即可。求一颗二叉树里所有的相同子树。<br>这个题目刚开始想的是遍历所有节点两层，分别比较两个树是否相同，后来发现超时。那么就想到只能遍历一次，那么就需要在遍历的时候记录下当前树的状态，当前树的状态用字符串表示，然后存储到字典里。字典长度超过2的那个即为重复的。</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;># Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution(object):
    def postorder(self,root,d):
        if root == None:
            return 'null'
        nowstr = str(root.val)+','+self.postorder(root.left,d)+','+self.postorder(root.right,d)
        if nowstr in d:
            d[nowstr].append(root)
        else:
            d[nowstr]=[root]
        return nowstr
    def findDuplicateSubtrees(self, root):
        &quot;&quot;&quot;
        :type root: TreeNode
        :rtype: List[TreeNode]
        &quot;&quot;&quot;
        d = {}
        self.postorder(root,d)
        res = []
        for i in d:
            if len(d[i])&amp;gt;=2:
                res.append(d[i][0])
        return res
</code></pre>"><span class="hljs-comment"># Definition for a binary tree node.</span>
<span class="hljs-comment"># class TreeNode(object):</span>
<span class="hljs-comment">#     def __init__(self, x):</span>
<span class="hljs-comment">#         self.val = x</span>
<span class="hljs-comment">#         self.left = None</span>
<span class="hljs-comment">#         self.right = None</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">postorder</span><span class="hljs-params">(self,root,d)</span>:</span>
        <span class="hljs-keyword">if</span> root == <span class="hljs-keyword">None</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-string">'null'</span>
        nowstr = str(root.val)+<span class="hljs-string">','</span>+self.postorder(root.left,d)+<span class="hljs-string">','</span>+self.postorder(root.right,d)
        <span class="hljs-keyword">if</span> nowstr <span class="hljs-keyword">in</span> d:
            d[nowstr].append(root)
        <span class="hljs-keyword">else</span>:
            d[nowstr]=[root]
        <span class="hljs-keyword">return</span> nowstr
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findDuplicateSubtrees</span><span class="hljs-params">(self, root)</span>:</span>
        <span class="hljs-string">"""
        :type root: TreeNode
        :rtype: List[TreeNode]
        """</span>
        d = {}
        self.postorder(root,d)
        res = []
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> d:
            <span class="hljs-keyword">if</span> len(d[i])&gt;=<span class="hljs-number">2</span>:
                res.append(d[i][<span class="hljs-number">0</span>])
        <span class="hljs-keyword">return</span> res
</code></pre><h5 id="665-no-decreasing-array"><a name="665-no-decreasing-array" href="#665-no-decreasing-array"></a>665 no decreasing array</h5><p>给定一个数组，问是否可以通过修改其中一个元素使得整个数组是非减的。<br>思路的话就是模拟这个过程，统计下最少修改次数。<br>递增的话不用管，碰到小于的，分情况，总之目的是希望修改后目前最大值最小这样。所以如果目前的值是第一个元素出现了反转，那么将数组头改为第一个即可。如果是后面的，则分如果该元素大于等于i-2位置上的，则将i-1的改为该元素i，否则将该i改为i-1.</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>class Solution(object):
    def checkPossibility(self, nums):
        &quot;&quot;&quot;
        :type nums: List[int]
        :rtype: bool
        &quot;&quot;&quot;
        if len(nums)&amp;lt;=1:
            return True
        change = 0
        for i in range(1,len(nums)):
            if nums[i]&amp;gt;=nums[i-1]:
                pass
            else:
                if i==1:
                    nums[i-1]=nums[i]
                    change = change + 1
                elif nums[i]&amp;gt;=nums[i-2]:
                    nums[i-1] = nums[i]
                    change = change + 1
                else:
                    nums[i]=nums[i-1]
                    change = change + 1
        return change&amp;lt;=1
</code></pre>"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">checkPossibility</span><span class="hljs-params">(self, nums)</span>:</span>
        <span class="hljs-string">"""
        :type nums: List[int]
        :rtype: bool
        """</span>
        <span class="hljs-keyword">if</span> len(nums)&lt;=<span class="hljs-number">1</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">True</span>
        change = <span class="hljs-number">0</span>
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>,len(nums)):
            <span class="hljs-keyword">if</span> nums[i]&gt;=nums[i-<span class="hljs-number">1</span>]:
                <span class="hljs-keyword">pass</span>
            <span class="hljs-keyword">else</span>:
                <span class="hljs-keyword">if</span> i==<span class="hljs-number">1</span>:
                    nums[i-<span class="hljs-number">1</span>]=nums[i]
                    change = change + <span class="hljs-number">1</span>
                <span class="hljs-keyword">elif</span> nums[i]&gt;=nums[i-<span class="hljs-number">2</span>]:
                    nums[i-<span class="hljs-number">1</span>] = nums[i]
                    change = change + <span class="hljs-number">1</span>
                <span class="hljs-keyword">else</span>:
                    nums[i]=nums[i-<span class="hljs-number">1</span>]
                    change = change + <span class="hljs-number">1</span>
        <span class="hljs-keyword">return</span> change&lt;=<span class="hljs-number">1</span>
</code></pre><h5 id="258-add-digits"><a name="258-add-digits" href="#258-add-digits"></a>258 add digits</h5><p>258-15-6.这样各个位相加直到只剩一个值。<br>循环的话很好解决，题目中说可否O(1)解决。想到所有的一位数都是小于等于9的，那么%9试下，确实是对的。两个特殊情况一个是0一个是1.单独考虑即可。</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>class Solution(object):
    def addDigits(self, num):
        &quot;&quot;&quot;
        :type num: int
        :rtype: int
        &quot;&quot;&quot;
        if num ==0:
            return 0
        else:
            return (num-1)%9+1
</code></pre>"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">addDigits</span><span class="hljs-params">(self, num)</span>:</span>
        <span class="hljs-string">"""
        :type num: int
        :rtype: int
        """</span>
        <span class="hljs-keyword">if</span> num ==<span class="hljs-number">0</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">return</span> (num-<span class="hljs-number">1</span>)%<span class="hljs-number">9</span>+<span class="hljs-number">1</span>
</code></pre><h5 id="intersection-of-two-linked-list链表是否交叉"><a name="intersection-of-two-linked-list链表是否交叉" href="#intersection-of-two-linked-list链表是否交叉"></a>intersection of two linked list链表是否交叉</h5><p>基本的思路就是先将b连接在a后面，如果两个有交叉那么必定形成环，那么就可以按照环来做了。<br>那么如何判断有环，自然是快慢指针，那么如何确定环的起点呢，当快慢指针第一次相遇后，根据一些数学计算可以知道，此时头指针到环起点的距离等于相遇点离环起点的距离，那么这时候头和慢指针同时移动，当两者相遇那么相遇点就是环起点。<br>还有一种问题是问环长度，这个还是和上面类似。快慢指针第一次相遇后，再次继续走，第二次相遇时经过的路径即为环长度。</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;># Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution(object):
    def getIntersectionNode(self, headA, headB):
        &quot;&quot;&quot;
        :type head1, head1: ListNode
        :rtype: ListNode
        &quot;&quot;&quot;
        if headA==None or headB==None:
            return None
        headAbak = headA
        headBbak = headB
        while headAbak.next!=None:
            headAbak = headAbak.next
        headAbak.next = headBbak
        slow = headA
        fast = headA
        hashuan = False
        while fast.next!=None and fast.next.next!=None:
            fast = fast.next.next
            slow = slow.next
            if fast==slow:
                hashuan = True
                break
        if hashuan==False:
            headAbak.next = None
            return None
        nowheadA = headA
        while nowheadA!=slow:
            nowheadA = nowheadA.next
            slow = slow.next
        headAbak.next = None
        return nowheadA
</code></pre>"><span class="hljs-comment"># Definition for singly-linked list.</span>
<span class="hljs-comment"># class ListNode(object):</span>
<span class="hljs-comment">#     def __init__(self, x):</span>
<span class="hljs-comment">#         self.val = x</span>
<span class="hljs-comment">#         self.next = None</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(self, headA, headB)</span>:</span>
        <span class="hljs-string">"""
        :type head1, head1: ListNode
        :rtype: ListNode
        """</span>
        <span class="hljs-keyword">if</span> headA==<span class="hljs-keyword">None</span> <span class="hljs-keyword">or</span> headB==<span class="hljs-keyword">None</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">None</span>
        headAbak = headA
        headBbak = headB
        <span class="hljs-keyword">while</span> headAbak.next!=<span class="hljs-keyword">None</span>:
            headAbak = headAbak.next
        headAbak.next = headBbak
        slow = headA
        fast = headA
        hashuan = <span class="hljs-keyword">False</span>
        <span class="hljs-keyword">while</span> fast.next!=<span class="hljs-keyword">None</span> <span class="hljs-keyword">and</span> fast.next.next!=<span class="hljs-keyword">None</span>:
            fast = fast.next.next
            slow = slow.next
            <span class="hljs-keyword">if</span> fast==slow:
                hashuan = <span class="hljs-keyword">True</span>
                <span class="hljs-keyword">break</span>
        <span class="hljs-keyword">if</span> hashuan==<span class="hljs-keyword">False</span>:
            headAbak.next = <span class="hljs-keyword">None</span>
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">None</span>
        nowheadA = headA
        <span class="hljs-keyword">while</span> nowheadA!=slow:
            nowheadA = nowheadA.next
            slow = slow.next
        headAbak.next = <span class="hljs-keyword">None</span>
        <span class="hljs-keyword">return</span> nowheadA
</code></pre><h5 id="207-课表"><a name="207-课表" href="#207-课表"></a>207 课表</h5><p>这里使用一个数组记录每节课是否访问过了，而后遍历每节课为入口进行dfs，dfs里面首先将入口课的标记为-1然后递归其前导课程，所以dfs前面要判断是否为-1，如果是-1说明该课程已经访问过了那么显然就是出现了问题。遍历完其前导课程都没错后就需要将其标记标记为1表示从这个入口进去不会出现问题。所以dfs一开始也会判断是不是等于1，等于1就直接返回没问题。</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>class Solution:
    def canFinish(self, numCourses, prerequisites):
        graph = [[] for _ in xrange(numCourses)]
        visit = [0 for _ in xrange(numCourses)]
        for x, y in prerequisites:
            graph[x].append(y)
        def dfs(i):
            if visit[i] == -1:
                return False
            if visit[i] == 1:
                return True
            visit[i] = -1
            for j in graph[i]:
                if not dfs(j):
                    return False
            visit[i] = 1
            return True
        for i in xrange(numCourses):
            if not dfs(i):
                return False
        return True
</code></pre>"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">canFinish</span><span class="hljs-params">(self, numCourses, prerequisites)</span>:</span>
        graph = [[] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> xrange(numCourses)]
        visit = [<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> xrange(numCourses)]
        <span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> prerequisites:
            graph[x].append(y)
        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dfs</span><span class="hljs-params">(i)</span>:</span>
            <span class="hljs-keyword">if</span> visit[i] == -<span class="hljs-number">1</span>:
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">False</span>
            <span class="hljs-keyword">if</span> visit[i] == <span class="hljs-number">1</span>:
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">True</span>
            visit[i] = -<span class="hljs-number">1</span>
            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> graph[i]:
                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> dfs(j):
                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">False</span>
            visit[i] = <span class="hljs-number">1</span>
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">True</span>
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> xrange(numCourses):
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> dfs(i):
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">False</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">True</span>
</code></pre><h5 id="11-包含最多水量的容器"><a name="11-包含最多水量的容器" href="#11-包含最多水量的容器"></a>11 包含最多水量的容器</h5><p>给定一系列高度值，代表在相应坐标上的木板，求两个木板使得其中水最多。<br>首先可以确定0和j-1是一个初始值，而后结果必定是这两个边界内的两个木板。那么就是如何迭代的问题了。如何选择从左还是从右呢，首先水位是按照最低的那个来说的，那么如果左右分别是3,5，那么必定是左边向前走，因为右边走的话无论多高都不会比原先盛水更多。</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>class Solution(object):
    def maxArea(self, height):
        &quot;&quot;&quot;
        :type height: List[int]
        :rtype: int
        &quot;&quot;&quot;
        i,j = 0,len(height)-1
        water = 0
        while i&amp;lt;j:
            water = max(water,(j-i)*min(height[i],height[j]))
            if height[i]&amp;lt;height[j]:
                i = i + 1
            else:
                j = j -1
        return water
</code></pre>"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maxArea</span><span class="hljs-params">(self, height)</span>:</span>
        <span class="hljs-string">"""
        :type height: List[int]
        :rtype: int
        """</span>
        i,j = <span class="hljs-number">0</span>,len(height)-<span class="hljs-number">1</span>
        water = <span class="hljs-number">0</span>
        <span class="hljs-keyword">while</span> i&lt;j:
            water = max(water,(j-i)*min(height[i],height[j]))
            <span class="hljs-keyword">if</span> height[i]&lt;height[j]:
                i = i + <span class="hljs-number">1</span>
            <span class="hljs-keyword">else</span>:
                j = j -<span class="hljs-number">1</span>
        <span class="hljs-keyword">return</span> water
</code></pre><h5 id="338-counts-bits"><a name="338-counts-bits" href="#338-counts-bits"></a>338 counts bits</h5><p>给定一个数n，求0-n各个数字二进制含有的1的数量。<br>对于每个数单独去1的数字很好但是复杂度稍微高。这里采用了dp的思路。也就是当前数字的1的个数等于不包含最后一位的个数加上最后一位是否为1.</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>class Solution(object):
    def countBits(self, num):
        &quot;&quot;&quot;
        :type num: int
        :rtype: List[int]
        &quot;&quot;&quot;
        dp = [0 for _ in range(num+1)]
        for i in range(1,num+1):
            #print(i,'w',dp[i&amp;gt;&amp;gt;1],i&amp;amp;1,dp[i&amp;gt;&amp;gt;1]+i&amp;amp;1)
            dp[i] = dp[i&amp;gt;&amp;gt;1]+(i&amp;amp;1)
            #print(i,dp[i&amp;gt;&amp;gt;1],dp[i])
        return dp
</code></pre>"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">countBits</span><span class="hljs-params">(self, num)</span>:</span>
        <span class="hljs-string">"""
        :type num: int
        :rtype: List[int]
        """</span>
        dp = [<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(num+<span class="hljs-number">1</span>)]
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>,num+<span class="hljs-number">1</span>):
            <span class="hljs-comment">#print(i,'w',dp[i&gt;&gt;1],i&amp;1,dp[i&gt;&gt;1]+i&amp;1)</span>
            dp[i] = dp[i&gt;&gt;<span class="hljs-number">1</span>]+(i&amp;<span class="hljs-number">1</span>)
            <span class="hljs-comment">#print(i,dp[i&gt;&gt;1],dp[i])</span>
        <span class="hljs-keyword">return</span> dp
</code></pre><h5 id="240-search-a-2d-matrix"><a name="240-search-a-2d-matrix" href="#240-search-a-2d-matrix"></a>240 search a 2d matrix</h5><p>给定一个2d矩阵，求里面是否包含某特定值。其中2d矩阵每行已经排序，每列已经排序。<br>肯定是二分查找，但是从左上角看来，似乎没有办法完成二分。那么如何呢，看下其他四角，右下显然也不行。左上角可以，大于的肯定可以去掉本行，小于的可以去掉本列。当然对应的左下也是可以的。</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>class Solution(object):
    def searchMatrix(self, matrix, target):
        &quot;&quot;&quot;
        :type matrix: List[List[int]]
        :type target: int
        :rtype: bool
        &quot;&quot;&quot;
        if matrix == None or len(matrix)&amp;lt;1 or len(matrix[0])&amp;lt;1:
            return False
        col = len(matrix[0])-1
        row = 0
        while col&amp;gt;=0 and row&amp;lt;=len(matrix)-1:
            if target==matrix[row][col]:
                return True
            elif target&amp;lt;matrix[row][col]:
                col = col -1
            else:
                row = row + 1
        return False
</code></pre>"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">searchMatrix</span><span class="hljs-params">(self, matrix, target)</span>:</span>
        <span class="hljs-string">"""
        :type matrix: List[List[int]]
        :type target: int
        :rtype: bool
        """</span>
        <span class="hljs-keyword">if</span> matrix == <span class="hljs-keyword">None</span> <span class="hljs-keyword">or</span> len(matrix)&lt;<span class="hljs-number">1</span> <span class="hljs-keyword">or</span> len(matrix[<span class="hljs-number">0</span>])&lt;<span class="hljs-number">1</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">False</span>
        col = len(matrix[<span class="hljs-number">0</span>])-<span class="hljs-number">1</span>
        row = <span class="hljs-number">0</span>
        <span class="hljs-keyword">while</span> col&gt;=<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> row&lt;=len(matrix)-<span class="hljs-number">1</span>:
            <span class="hljs-keyword">if</span> target==matrix[row][col]:
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">True</span>
            <span class="hljs-keyword">elif</span> target&lt;matrix[row][col]:
                col = col -<span class="hljs-number">1</span>
            <span class="hljs-keyword">else</span>:
                row = row + <span class="hljs-number">1</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">False</span>
</code></pre><h5 id="678-vaild-parenthesis-string"><a name="678-vaild-parenthesis-string" href="#678-vaild-parenthesis-string"></a>678 vaild parenthesis string</h5><p>合法括号序列，难点在于其中包含星号，而星号可以解释为左，右，空。<br>这样的话其实还是类似于栈的思路。碰到左加1右减1，不同的在于碰到星号后要分为三种情况，一种加1一种减1一种不变。<br>这样的话使用一个set包含目前所有可能的栈深度即可，最后查看是否有为0的，当前，过程中也要检查栈最大值是否小于0小于则返回False。<br>那么又想到其实可以不把所有情况包含起来而是只留下边界两个值即可。<br>碰到左都加1，碰到右high减1，low的话则取0和减1最大值，为什么呢，因为在上面所说的正常情况下在遍历过程里如果栈集合里出现负数的话也是要删除掉的，因为已经发生了错误，所以这里取一个max。不用担心会出错，因为每轮要检查high。在碰到星号时也是类似。最后检查最低值是否为0不是的话则表明错误。<br>下面两种解法都给出，都可以通过</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>class Solution(object):
    def checkValidString(self, s):
        &quot;&quot;&quot;
        :type s: str
        :rtype: bool
        &quot;&quot;&quot;
        low,high = 0,0
        for i in range(len(s)):
            if s[i]=='(':
                low = low + 1
                high = high + 1
            elif s[i]==')':
                low = max(low - 1,0)
                high = high - 1
            else:
                low = max(0,low-1)
                high = high + 1
            if high&amp;lt;0:
                return False
        return low==0
    def ss(self,s):
        stack = []
        for i in range(len(s)):
            if s[i]=='(':
                stack = [i+1 for i in stack if i+1&amp;gt;=0]
            elif s[i]==')':
                stack = [i-1 for i in stack if i-1&amp;gt;=0]
            else:
                tmp = []
                for i in stack:
                    tmp.append(i)
                    tmp.append(i+1)
                    if i-1&amp;gt;=0:
                        tmp.append(i-1)
                stack = list(set(tmp))
        return min(stack)==0
</code></pre>"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">checkValidString</span><span class="hljs-params">(self, s)</span>:</span>
        <span class="hljs-string">"""
        :type s: str
        :rtype: bool
        """</span>
        low,high = <span class="hljs-number">0</span>,<span class="hljs-number">0</span>
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(s)):
            <span class="hljs-keyword">if</span> s[i]==<span class="hljs-string">'('</span>:
                low = low + <span class="hljs-number">1</span>
                high = high + <span class="hljs-number">1</span>
            <span class="hljs-keyword">elif</span> s[i]==<span class="hljs-string">')'</span>:
                low = max(low - <span class="hljs-number">1</span>,<span class="hljs-number">0</span>)
                high = high - <span class="hljs-number">1</span>
            <span class="hljs-keyword">else</span>:
                low = max(<span class="hljs-number">0</span>,low-<span class="hljs-number">1</span>)
                high = high + <span class="hljs-number">1</span>
            <span class="hljs-keyword">if</span> high&lt;<span class="hljs-number">0</span>:
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">False</span>
        <span class="hljs-keyword">return</span> low==<span class="hljs-number">0</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">ss</span><span class="hljs-params">(self,s)</span>:</span>
        stack = []
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(s)):
            <span class="hljs-keyword">if</span> s[i]==<span class="hljs-string">'('</span>:
                stack = [i+<span class="hljs-number">1</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> stack <span class="hljs-keyword">if</span> i+<span class="hljs-number">1</span>&gt;=<span class="hljs-number">0</span>]
            <span class="hljs-keyword">elif</span> s[i]==<span class="hljs-string">')'</span>:
                stack = [i-<span class="hljs-number">1</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> stack <span class="hljs-keyword">if</span> i-<span class="hljs-number">1</span>&gt;=<span class="hljs-number">0</span>]
            <span class="hljs-keyword">else</span>:
                tmp = []
                <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> stack:
                    tmp.append(i)
                    tmp.append(i+<span class="hljs-number">1</span>)
                    <span class="hljs-keyword">if</span> i-<span class="hljs-number">1</span>&gt;=<span class="hljs-number">0</span>:
                        tmp.append(i-<span class="hljs-number">1</span>)
                stack = list(set(tmp))
        <span class="hljs-keyword">return</span> min(stack)==<span class="hljs-number">0</span>
</code></pre><h5 id="274-h-index"><a name="274-h-index" href="#274-h-index"></a>274 h-index</h5><p>这个h-index的概念本身就很复杂，将坐标和值联系在了一起。N偏paper，其中有h偏大于h的，剩下N-h偏小于等于h。<br>没有排序的话就挨个统计，然后遍历。<br>已经排过序的自然是使用二分查找。</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>class Solution(object):
    def hIndex(self, citations):
        &quot;&quot;&quot;
        :type citations: List[int]
        :rtype: int
        &quot;&quot;&quot;
        n = len(citations)
        tot = 0
        arr = [0 for _ in range(n+1)]
        for i in citations:
            if i&amp;gt;=n:
                arr[n] = arr[n]+1
            else:
                arr[i] = arr[i]+1
        for i in range(n,-1,-1):
            tot = tot + arr[i]
            if tot&amp;gt;=i:
                return i
        return 0
    def hIndex(self, citations):
        n = len(citations)
        l, r = 0, n-1
        while l &amp;lt;= r:
            mid = (l+r)/2
            if citations[mid] &amp;gt;= n-mid:
                r = mid - 1
            else:
                l = mid + 1
        return n-l
</code></pre>"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hIndex</span><span class="hljs-params">(self, citations)</span>:</span>
        <span class="hljs-string">"""
        :type citations: List[int]
        :rtype: int
        """</span>
        n = len(citations)
        tot = <span class="hljs-number">0</span>
        arr = [<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(n+<span class="hljs-number">1</span>)]
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> citations:
            <span class="hljs-keyword">if</span> i&gt;=n:
                arr[n] = arr[n]+<span class="hljs-number">1</span>
            <span class="hljs-keyword">else</span>:
                arr[i] = arr[i]+<span class="hljs-number">1</span>
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(n,-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>):
            tot = tot + arr[i]
            <span class="hljs-keyword">if</span> tot&gt;=i:
                <span class="hljs-keyword">return</span> i
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hIndex</span><span class="hljs-params">(self, citations)</span>:</span>
        n = len(citations)
        l, r = <span class="hljs-number">0</span>, n-<span class="hljs-number">1</span>
        <span class="hljs-keyword">while</span> l &lt;= r:
            mid = (l+r)/<span class="hljs-number">2</span>
            <span class="hljs-keyword">if</span> citations[mid] &gt;= n-mid:
                r = mid - <span class="hljs-number">1</span>
            <span class="hljs-keyword">else</span>:
                l = mid + <span class="hljs-number">1</span>
        <span class="hljs-keyword">return</span> n-l
</code></pre><h5 id="145-二叉树的迭代遍历"><a name="145-二叉树的迭代遍历" href="#145-二叉树的迭代遍历"></a>145 二叉树的迭代遍历</h5><p>递归遍历比较简单，下面给出一些迭代遍历。<br>前序后续迭代遍历也还比较容易，因为这两种遍历根都是在两端的，不会影响栈的操作。</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>    def postorderTraversal(self, root):
        &quot;&quot;&quot;
        :type root: TreeNode
        :rtype: List[int]
        &quot;&quot;&quot;
        res = []
        stack = [root]
        while stack:
            now = stack.pop()
            res.add(now.val)
            if now.left!=None:
                stack.append(now.left)
            if now.right!=None:
                stack.append(now.right)
        res.reverse()
        return res
</code></pre>">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(self, root)</span>:</span>
        <span class="hljs-string">"""
        :type root: TreeNode
        :rtype: List[int]
        """</span>
        res = []
        stack = [root]
        <span class="hljs-keyword">while</span> stack:
            now = stack.pop()
            res.add(now.val)
            <span class="hljs-keyword">if</span> now.left!=<span class="hljs-keyword">None</span>:
                stack.append(now.left)
            <span class="hljs-keyword">if</span> now.right!=<span class="hljs-keyword">None</span>:
                stack.append(now.right)
        res.reverse()
        <span class="hljs-keyword">return</span> res
</code></pre><p>中序遍历就比较麻烦，首先想下我们中序遍历是要一直走到最左边，然后将元素值记录下，然后再看中间，然后在转右边这样。<br>所以每碰到一个节点都要尽量向左走遍地，然后从栈中pop出元素后记录，然后下一步就是该pop元素的right。</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>    def inorder(self,root):
        res = []
        if root==None:
            return []
        stack = []
        while True:
            while root:
                stack.append(root)
                root = root.left
            if not stack:
                return res
            tmp = stack.pop()
            res.append(tmp.val)
            root = tmp.right
        return res
</code></pre>">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">inorder</span><span class="hljs-params">(self,root)</span>:</span>
        res = []
        <span class="hljs-keyword">if</span> root==<span class="hljs-keyword">None</span>:
            <span class="hljs-keyword">return</span> []
        stack = []
        <span class="hljs-keyword">while</span> <span class="hljs-keyword">True</span>:
            <span class="hljs-keyword">while</span> root:
                stack.append(root)
                root = root.left
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> stack:
                <span class="hljs-keyword">return</span> res
            tmp = stack.pop()
            res.append(tmp.val)
            root = tmp.right
        <span class="hljs-keyword">return</span> res
</code></pre><h5 id="permutations"><a name="permutations" href="#permutations"></a>permutations</h5><p>给定一个数组其所有排列组合结果。<br>如果里面不包含重复元素那么直接dfs或者回溯遍历即可。<br>如果里面有重复元素并且认定重复的排列不算不同的排列那么就需要简化。首先将数组排序，在回溯的过程遍历时检查当前元素如果和前一个一样并且前一个元素没有被使用那么就跳过。如果前一个正被使用则正常。为什么呢，因为上一个没有被使用说明当前遍历的重复了，因为既然不认定重复排列那么任何元素开头都一样。当前面在使用则说明其是遍历到当前位置了不是重复。</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>class Solution(object):
    def back(self,res,tmpres,nums,tag,nowlen,alllen):
        import copy
        if nowlen==alllen:
            res.add(tuple(tmpres))
            return
        else:
            i = 0
            while i&amp;lt;alllen:
                if i&amp;gt;0 and nums[i-1]==nums[i] and tag[i-1]==False:
                    i = i + 1
                    continue
                if tag[i]==0:
                    tmpresbak = copy.deepcopy(tmpres)
                    tmpresbak.append(nums[i])
                    tag[i]=1
                    self.back(res,tmpresbak,nums,tag,nowlen+1,alllen)
                    tag[i]=0
                #while i&amp;lt;alllen-1 and nums[i+1]==nums[i]:
                #    i = i + 1
                i = i + 1

    def permuteUnique(self, nums):
        &quot;&quot;&quot;
        :type nums: List[int]
        :rtype: List[List[int]]
        &quot;&quot;&quot;
        nums.sort()
        res = set()
        tmpres = []
        tag = [0 for i in range(len(nums))]
        self.back(res,tmpres,nums,tag,0,len(nums))
        #print(res)
        res = [list(i) for i in res]
        return len(res)
</code></pre>"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">back</span><span class="hljs-params">(self,res,tmpres,nums,tag,nowlen,alllen)</span>:</span>
        <span class="hljs-keyword">import</span> copy
        <span class="hljs-keyword">if</span> nowlen==alllen:
            res.add(tuple(tmpres))
            <span class="hljs-keyword">return</span>
        <span class="hljs-keyword">else</span>:
            i = <span class="hljs-number">0</span>
            <span class="hljs-keyword">while</span> i&lt;alllen:
                <span class="hljs-keyword">if</span> i&gt;<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> nums[i-<span class="hljs-number">1</span>]==nums[i] <span class="hljs-keyword">and</span> tag[i-<span class="hljs-number">1</span>]==<span class="hljs-keyword">False</span>:
                    i = i + <span class="hljs-number">1</span>
                    <span class="hljs-keyword">continue</span>
                <span class="hljs-keyword">if</span> tag[i]==<span class="hljs-number">0</span>:
                    tmpresbak = copy.deepcopy(tmpres)
                    tmpresbak.append(nums[i])
                    tag[i]=<span class="hljs-number">1</span>
                    self.back(res,tmpresbak,nums,tag,nowlen+<span class="hljs-number">1</span>,alllen)
                    tag[i]=<span class="hljs-number">0</span>
                <span class="hljs-comment">#while i&lt;alllen-1 and nums[i+1]==nums[i]:</span>
                <span class="hljs-comment">#    i = i + 1</span>
                i = i + <span class="hljs-number">1</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">permuteUnique</span><span class="hljs-params">(self, nums)</span>:</span>
        <span class="hljs-string">"""
        :type nums: List[int]
        :rtype: List[List[int]]
        """</span>
        nums.sort()
        res = set()
        tmpres = []
        tag = [<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(nums))]
        self.back(res,tmpres,nums,tag,<span class="hljs-number">0</span>,len(nums))
        <span class="hljs-comment">#print(res)</span>
        res = [list(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> res]
        <span class="hljs-keyword">return</span> len(res)
</code></pre><h5 id="239滑动窗口最大值"><a name="239滑动窗口最大值" href="#239滑动窗口最大值"></a>239滑动窗口最大值</h5><p>一个数组以k为窗口滑动，求每个窗口最大值。<br>降低复杂度，记录下前次最大值的值和坐标，每次滑动时，如果前面的最大值仍然能够影响到这里，那么只比较窗口最后的值和当前最大值。如果前面的最大值影响不到这里了，那么就只能去重新比较窗口了。</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>class Solution(object):
    def maxSlidingWindow(self, nums, k):
        n = len(nums)
        if k&amp;lt;=1:
            return nums
        if k==n:
            return [max(nums)]
        maxidx = -3
        maxn = float('-inf')
        res = []
        for i in range(n-k+1):
            start = i
            end = i+k-1
            #print('w',i,start,end,maxidx)
            if i&amp;gt;n:
                pass
            else:
                if maxidx+(k-1)&amp;gt;=end:
                     if nums[end]&amp;gt;=maxn:
                         maxn = nums[end]
                         maxidx = end
                else:
                    maxn = max(nums[start:end+1])
                    for j in range(start,end+1,1):
                        if maxn == nums[j]:
                            maxidx = j
                            break
            #print('now',maxidx,maxn)
            res.append(maxn)
        return res
</code></pre>"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maxSlidingWindow</span><span class="hljs-params">(self, nums, k)</span>:</span>
        n = len(nums)
        <span class="hljs-keyword">if</span> k&lt;=<span class="hljs-number">1</span>:
            <span class="hljs-keyword">return</span> nums
        <span class="hljs-keyword">if</span> k==n:
            <span class="hljs-keyword">return</span> [max(nums)]
        maxidx = -<span class="hljs-number">3</span>
        maxn = float(<span class="hljs-string">'-inf'</span>)
        res = []
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(n-k+<span class="hljs-number">1</span>):
            start = i
            end = i+k-<span class="hljs-number">1</span>
            <span class="hljs-comment">#print('w',i,start,end,maxidx)</span>
            <span class="hljs-keyword">if</span> i&gt;n:
                <span class="hljs-keyword">pass</span>
            <span class="hljs-keyword">else</span>:
                <span class="hljs-keyword">if</span> maxidx+(k-<span class="hljs-number">1</span>)&gt;=end:
                     <span class="hljs-keyword">if</span> nums[end]&gt;=maxn:
                         maxn = nums[end]
                         maxidx = end
                <span class="hljs-keyword">else</span>:
                    maxn = max(nums[start:end+<span class="hljs-number">1</span>])
                    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(start,end+<span class="hljs-number">1</span>,<span class="hljs-number">1</span>):
                        <span class="hljs-keyword">if</span> maxn == nums[j]:
                            maxidx = j
                            <span class="hljs-keyword">break</span>
            <span class="hljs-comment">#print('now',maxidx,maxn)</span>
            res.append(maxn)
        <span class="hljs-keyword">return</span> res
</code></pre><h5 id="155-min-stack"><a name="155-min-stack" href="#155-min-stack"></a>155 min stack</h5><p>自己实现一个栈，要求能够以常数时间返回最小值。<br>这个其实唯一需要思考的地方就是这个最小值。那么考虑也是栈存储一个最小值，每当进入一个元素时，查看其在与最小栈顶部比较，如果小，则将该数入最小栈，否则这个位置还是最小栈顶部元素。这样就保留了下来栈的每个深度上对应的最小值。在出栈时记得最小栈也要出栈就行。</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>class MinStack(object):
    def __init__(self):
        self.minn = []
        self.stack = []
    def push(self, x):
        self.stack.append(x)
        if len(self.minn)==0:
            self.minn.append(x)
        else:
            if self.minn[-1]&amp;gt;x:
                self.minn.append(x)
            else:
                self.minn.append(self.minn[-1])
    def pop(self):
        self.stack.pop()
        self.minn.pop()
    def top(self):
        return self.stack[-1]
    def getMin(self):
        return self.minn[-1]
</code></pre>"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MinStack</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span>
        self.minn = []
        self.stack = []
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">push</span><span class="hljs-params">(self, x)</span>:</span>
        self.stack.append(x)
        <span class="hljs-keyword">if</span> len(self.minn)==<span class="hljs-number">0</span>:
            self.minn.append(x)
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">if</span> self.minn[-<span class="hljs-number">1</span>]&gt;x:
                self.minn.append(x)
            <span class="hljs-keyword">else</span>:
                self.minn.append(self.minn[-<span class="hljs-number">1</span>])
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pop</span><span class="hljs-params">(self)</span>:</span>
        self.stack.pop()
        self.minn.pop()
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">top</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-keyword">return</span> self.stack[-<span class="hljs-number">1</span>]
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getMin</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-keyword">return</span> self.minn[-<span class="hljs-number">1</span>]
</code></pre><h5 id="583-最少删除操作"><a name="583-最少删除操作" href="#583-最少删除操作"></a>583 最少删除操作</h5><p>两个字符串，只能进行删除操作，问想两个一样的最少操作。<br>与编辑距离很想，那么采取类似的方法，也是dp。不同之处在于在编辑距离的那里判断当前位是否相同，相同则左上角这个一样，不相同的话编辑距离是左上角，左，上取最小的然后加1这样，而这里的话因为只有删除操作，故而左，上还是加1，但是左上角的话需要加2.</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>class Solution(object):
    def minDistance(self, word1, word2):
        &quot;&quot;&quot;
        :type word1: str
        :type word2: str
        :rtype: int
        &quot;&quot;&quot;
        if len(word1)==len(word2) and len(word1)==1:
            return 2 if word1!=word2 else 0
        m = len(word1)
        n = len(word2)
        dp = [[0]*(n+1) for i in range(m+1)]
        for i in range(n+1):
            dp[0][i] = i
        for i in range(m+1):
            dp[i][0] = i
        for i in range(1,m+1):
            for j in range(1,n+1):
                if word1[i-1]==word2[j-1]:
                    dp[i][j] = dp[i-1][j-1]
                else:
                    dp[i][j] = min(dp[i-1][j-1]+2,dp[i-1][j]+1,dp[i][j-1]+1)
        #print(dp)
        return dp[m][n]
</code></pre>"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">minDistance</span><span class="hljs-params">(self, word1, word2)</span>:</span>
        <span class="hljs-string">"""
        :type word1: str
        :type word2: str
        :rtype: int
        """</span>
        <span class="hljs-keyword">if</span> len(word1)==len(word2) <span class="hljs-keyword">and</span> len(word1)==<span class="hljs-number">1</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> <span class="hljs-keyword">if</span> word1!=word2 <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>
        m = len(word1)
        n = len(word2)
        dp = [[<span class="hljs-number">0</span>]*(n+<span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(m+<span class="hljs-number">1</span>)]
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(n+<span class="hljs-number">1</span>):
            dp[<span class="hljs-number">0</span>][i] = i
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(m+<span class="hljs-number">1</span>):
            dp[i][<span class="hljs-number">0</span>] = i
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>,m+<span class="hljs-number">1</span>):
            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>,n+<span class="hljs-number">1</span>):
                <span class="hljs-keyword">if</span> word1[i-<span class="hljs-number">1</span>]==word2[j-<span class="hljs-number">1</span>]:
                    dp[i][j] = dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>]
                <span class="hljs-keyword">else</span>:
                    dp[i][j] = min(dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>]+<span class="hljs-number">2</span>,dp[i-<span class="hljs-number">1</span>][j]+<span class="hljs-number">1</span>,dp[i][j-<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>)
        <span class="hljs-comment">#print(dp)</span>
        <span class="hljs-keyword">return</span> dp[m][n]
</code></pre><h5 id="丑数"><a name="丑数" href="#丑数"></a>丑数</h5><p>丑数定义，质数约数只有2,3,5.其实也就相当于是由2××m3××n5××k这样的形式组成的数，问判断一个数是不是丑数。那么很容易判断，如果能够被2整除则除以2,3和5也是。如果最后剩下了1说明是丑数。<br>第二个问题是如何求解第k个丑数。<br>这个问题肯定不能枚举数然后判断是不是丑数，这样复杂度高。那么如何遍历呢，想到肯定还是依据丑数的性质来做文章。既然其一定是2指数3指数5指数这样，那么我们就遍历这三个指数。具体来说初始这三个指数都是0，初始的话自然是1，然后第一次计算值，计算的时候是2,3,5乘以ugly数组里其指数值对应的坐标的值，得到2,3,5，那么2最小，所以本次ugly是2，并且2的指数这里要加1，然后第二次遍历的时候也是。这里难理解的地方是为什么指数值要去ugly数组里取相应坐标值的值呢。其实这个可以从指数值是如何被增加看出来。比如上面的2，第一次取用了之后加1，那么其以后计算的时候势必也就是以那个坐标的值为基础进行×2的然后与其他两个比较的，如果比较胜出，那么也意味着其在ugly里第一次指数值增加了，那么×2后的值自然是ugly不题，那么下一个基准自然是仅仅比刚才大一点的数也就是相当于指数加了1，下一次基准数在ugly里是下一位这样。<br>第三个问题说不仅仅是2,3,5了还可能包含其他数，这个没什么类似推导即可。</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>class Solution(object):
    def isUgly(self, num):
        &quot;&quot;&quot;
        :type num: int
        :rtype: bool
        &quot;&quot;&quot;
        while num%2==0:
            num = num&amp;gt;&amp;gt;1
        while num%3==0:
            num = num/3
        while num%5==0:
            num = num/5
        return num==1
    def nthUglyNumber(self, n):
        &quot;&quot;&quot;
        :type n: int
        :rtype: int
        &quot;&quot;&quot;
        #&quot;1, 2, 3, 4, 5, 6, 8, 9, 10, 12&quot;
        ugly = [1]
        u2,u3,u5 = 0,0,0
        while n&amp;gt;1:
            n2,n3,n5 = 2*ugly[u2],3*ugly[u3],5*ugly[u5]
            print(n2,n3,n5)
            minn = min((n2,n3,n5))
            if minn == n2:
                u2 = u2 + 1
            if minn == n3:
                u3 = u3 + 1
            if minn == n5:
                u5 = u5 + 1
            ugly.append(minn)
            n = n - 1
        print(ugly)
        return ugly[-1]

    def nthSuperUglyNumber(self, n, primes):
        &quot;&quot;&quot;
        :type n: int
        :type primes: List[int]
        :rtype: int
        &quot;&quot;&quot;
        ugly = [1]
        chushi = [0 for i in range(len(primes))]
        while n&amp;gt;1:
            res = [primes[i]*ugly[chushi[i]] for i in range(len(primes))]
            minn = min(res)
            for i in range(len(primes)):
                if minn ==res[i]:
                    chushi[i]+=1
            ugly.append(minn)
            n = n -1
        return ugly[-1]
</code></pre>"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isUgly</span><span class="hljs-params">(self, num)</span>:</span>
        <span class="hljs-string">"""
        :type num: int
        :rtype: bool
        """</span>
        <span class="hljs-keyword">while</span> num%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>:
            num = num&gt;&gt;<span class="hljs-number">1</span>
        <span class="hljs-keyword">while</span> num%<span class="hljs-number">3</span>==<span class="hljs-number">0</span>:
            num = num/<span class="hljs-number">3</span>
        <span class="hljs-keyword">while</span> num%<span class="hljs-number">5</span>==<span class="hljs-number">0</span>:
            num = num/<span class="hljs-number">5</span>
        <span class="hljs-keyword">return</span> num==<span class="hljs-number">1</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">nthUglyNumber</span><span class="hljs-params">(self, n)</span>:</span>
        <span class="hljs-string">"""
        :type n: int
        :rtype: int
        """</span>
        <span class="hljs-comment">#"1, 2, 3, 4, 5, 6, 8, 9, 10, 12"</span>
        ugly = [<span class="hljs-number">1</span>]
        u2,u3,u5 = <span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>
        <span class="hljs-keyword">while</span> n&gt;<span class="hljs-number">1</span>:
            n2,n3,n5 = <span class="hljs-number">2</span>*ugly[u2],<span class="hljs-number">3</span>*ugly[u3],<span class="hljs-number">5</span>*ugly[u5]
            print(n2,n3,n5)
            minn = min((n2,n3,n5))
            <span class="hljs-keyword">if</span> minn == n2:
                u2 = u2 + <span class="hljs-number">1</span>
            <span class="hljs-keyword">if</span> minn == n3:
                u3 = u3 + <span class="hljs-number">1</span>
            <span class="hljs-keyword">if</span> minn == n5:
                u5 = u5 + <span class="hljs-number">1</span>
            ugly.append(minn)
            n = n - <span class="hljs-number">1</span>
        print(ugly)
        <span class="hljs-keyword">return</span> ugly[-<span class="hljs-number">1</span>]

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">nthSuperUglyNumber</span><span class="hljs-params">(self, n, primes)</span>:</span>
        <span class="hljs-string">"""
        :type n: int
        :type primes: List[int]
        :rtype: int
        """</span>
        ugly = [<span class="hljs-number">1</span>]
        chushi = [<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(primes))]
        <span class="hljs-keyword">while</span> n&gt;<span class="hljs-number">1</span>:
            res = [primes[i]*ugly[chushi[i]] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(primes))]
            minn = min(res)
            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(primes)):
                <span class="hljs-keyword">if</span> minn ==res[i]:
                    chushi[i]+=<span class="hljs-number">1</span>
            ugly.append(minn)
            n = n -<span class="hljs-number">1</span>
        <span class="hljs-keyword">return</span> ugly[-<span class="hljs-number">1</span>]
</code></pre>

<footer style="position:fixed; font-size:.8em; text-align:right; bottom:0px; margin-left:-25px; height:20px; width:100%;">generated by <a href="http://pad.haroopress.com" target="_blank">haroopad</a></footer>
</body>
</html>
