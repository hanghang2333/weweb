<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>20170911.html</title>
  <meta name="generator" content="Haroopad 0.13.1" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <style>div.oembedall-githubrepos{border:1px solid #DDD;border-radius:4px;list-style-type:none;margin:0 0 10px;padding:8px 10px 0;font:13.34px/1.4 helvetica,arial,freesans,clean,sans-serif;width:452px;background-color:#fff}div.oembedall-githubrepos .oembedall-body{background:-moz-linear-gradient(center top,#FAFAFA,#EFEFEF);background:-webkit-gradient(linear,left top,left bottom,from(#FAFAFA),to(#EFEFEF));border-bottom-left-radius:4px;border-bottom-right-radius:4px;border-top:1px solid #EEE;margin-left:-10px;margin-top:8px;padding:5px 10px;width:100%}div.oembedall-githubrepos h3{font-size:14px;margin:0;padding-left:18px;white-space:nowrap}div.oembedall-githubrepos p.oembedall-description{color:#444;font-size:12px;margin:0 0 3px}div.oembedall-githubrepos p.oembedall-updated-at{color:#888;font-size:11px;margin:0}div.oembedall-githubrepos ul.oembedall-repo-stats{border:none;float:right;font-size:11px;font-weight:700;padding-left:15px;position:relative;z-index:5;margin:0}div.oembedall-githubrepos ul.oembedall-repo-stats li{border:none;color:#666;display:inline-block;list-style-type:none;margin:0!important}div.oembedall-githubrepos ul.oembedall-repo-stats li a{background-color:transparent;border:none;color:#666!important;background-position:5px -2px;background-repeat:no-repeat;border-left:1px solid #DDD;display:inline-block;height:21px;line-height:21px;padding:0 5px 0 23px}div.oembedall-githubrepos ul.oembedall-repo-stats li:first-child a{border-left:medium none;margin-right:-3px}div.oembedall-githubrepos ul.oembedall-repo-stats li a:hover{background:5px -27px no-repeat #4183C4;color:#FFF!important;text-decoration:none}div.oembedall-githubrepos ul.oembedall-repo-stats li:first-child a:hover{border-bottom-left-radius:3px;border-top-left-radius:3px}ul.oembedall-repo-stats li:last-child a:hover{border-bottom-right-radius:3px;border-top-right-radius:3px}span.oembedall-closehide{background-color:#aaa;border-radius:2px;cursor:pointer;margin-right:3px}div.oembedall-container{margin-top:5px;text-align:left}.oembedall-ljuser{font-weight:700}.oembedall-ljuser img{vertical-align:bottom;border:0;padding-right:1px}.oembedall-stoqembed{border-bottom:1px dotted #999;float:left;overflow:hidden;width:730px;line-height:1;background:#FFF;color:#000;font-family:Arial,Liberation Sans,DejaVu Sans,sans-serif;font-size:80%;text-align:left;margin:0;padding:0}.oembedall-stoqembed a{color:#07C;text-decoration:none;margin:0;padding:0}.oembedall-stoqembed a:hover{text-decoration:underline}.oembedall-stoqembed a:visited{color:#4A6B82}.oembedall-stoqembed h3{font-family:Trebuchet MS,Liberation Sans,DejaVu Sans,sans-serif;font-size:130%;font-weight:700;margin:0;padding:0}.oembedall-stoqembed .oembedall-reputation-score{color:#444;font-size:120%;font-weight:700;margin-right:2px}.oembedall-stoqembed .oembedall-user-info{height:35px;width:185px}.oembedall-stoqembed .oembedall-user-info .oembedall-user-gravatar32{float:left;height:32px;width:32px}.oembedall-stoqembed .oembedall-user-info .oembedall-user-details{float:left;margin-left:5px;overflow:hidden;white-space:nowrap;width:145px}.oembedall-stoqembed .oembedall-question-hyperlink{font-weight:700}.oembedall-stoqembed .oembedall-stats{background:#EEE;margin:0 0 0 7px;padding:4px 7px 6px;width:58px}.oembedall-stoqembed .oembedall-statscontainer{float:left;margin-right:8px;width:86px}.oembedall-stoqembed .oembedall-votes{color:#555;padding:0 0 7px;text-align:center}.oembedall-stoqembed .oembedall-vote-count-post{font-size:240%;color:#808185;display:block;font-weight:700}.oembedall-stoqembed .oembedall-views{color:#999;padding-top:4px;text-align:center}.oembedall-stoqembed .oembedall-status{margin-top:-3px;padding:4px 0;text-align:center;background:#75845C;color:#FFF}.oembedall-stoqembed .oembedall-status strong{color:#FFF;display:block;font-size:140%}.oembedall-stoqembed .oembedall-summary{float:left;width:635px}.oembedall-stoqembed .oembedall-excerpt{line-height:1.2;margin:0;padding:0 0 5px}.oembedall-stoqembed .oembedall-tags{float:left;line-height:18px}.oembedall-stoqembed .oembedall-tags a:hover{text-decoration:none}.oembedall-stoqembed .oembedall-post-tag{background-color:#E0EAF1;border-bottom:1px solid #3E6D8E;border-right:1px solid #7F9FB6;color:#3E6D8E;font-size:90%;line-height:2.4;margin:2px 2px 2px 0;padding:3px 4px;text-decoration:none;white-space:nowrap}.oembedall-stoqembed .oembedall-post-tag:hover{background-color:#3E6D8E;border-bottom:1px solid #37607D;border-right:1px solid #37607D;color:#E0EAF1}.oembedall-stoqembed .oembedall-fr{float:right}.oembedall-stoqembed .oembedall-statsarrow{background-image:url(http://cdn.sstatic.net/stackoverflow/img/sprites.png?v=3);background-repeat:no-repeat;overflow:hidden;background-position:0 -435px;float:right;height:13px;margin-top:12px;width:7px}.oembedall-facebook1{border:1px solid #1A3C6C;padding:0;font:13.34px/1.4 verdana;width:500px}.oembedall-facebook2{background-color:#627add}.oembedall-facebook2 a{color:#e8e8e8;text-decoration:none}.oembedall-facebookBody{background-color:#fff;vertical-align:top;padding:5px}.oembedall-facebookBody .contents{display:inline-block;width:100%}.oembedall-facebookBody div img{float:left;margin-right:5px}div.oembedall-lanyard{-webkit-box-shadow:none;-webkit-transition-delay:0s;-webkit-transition-duration:.4000000059604645s;-webkit-transition-property:width;-webkit-transition-timing-function:cubic-bezier(0.42,0,.58,1);background-attachment:scroll;background-clip:border-box;background-color:transparent;background-image:none;background-origin:padding-box;border-width:0;box-shadow:none;color:#112644;display:block;float:left;font-family:'Trebuchet MS',Trebuchet,sans-serif;font-size:16px;height:253px;line-height:19px;margin:0;max-width:none;min-height:0;outline:#112644 0;overflow-x:visible;overflow-y:visible;padding:0;position:relative;text-align:left;vertical-align:baseline;width:804px}div.oembedall-lanyard .tagline{font-size:1.5em}div.oembedall-lanyard .wrapper{overflow:hidden;clear:both}div.oembedall-lanyard .split{float:left;display:inline}div.oembedall-lanyard .prominent-place .flag:active,div.oembedall-lanyard .prominent-place .flag:focus,div.oembedall-lanyard .prominent-place .flag:hover,div.oembedall-lanyard .prominent-place .flag:link,div.oembedall-lanyard .prominent-place .flag:visited{float:left;display:block;width:48px;height:48px;position:relative;top:-5px;margin-right:10px}div.oembedall-lanyard .place-context{font-size:.889em}div.oembedall-lanyard .prominent-place .sub-place{display:block}div.oembedall-lanyard .prominent-place{font-size:1.125em;line-height:1.1em;font-weight:400}div.oembedall-lanyard .main-date{color:#8CB4E0;font-weight:700;line-height:1.1}div.oembedall-lanyard .first{width:48.57%;margin:0 0 0 2.857%}.mermaid .label{color:#333}.node circle,.node polygon,.node rect{fill:#cde498;stroke:#13540c;stroke-width:1px}.edgePath .path{stroke:green;stroke-width:1.5px}.cluster rect{fill:#cdffb2;rx:40;stroke:#6eaa49;stroke-width:1px}.cluster text{fill:#333}.actor{stroke:#13540c;fill:#cde498}text.actor{fill:#000;stroke:none}.actor-line{stroke:grey}.messageLine0{stroke-width:1.5;stroke-dasharray:"2 2";marker-end:"url(#arrowhead)";stroke:#333}.messageLine1{stroke-width:1.5;stroke-dasharray:"2 2";stroke:#333}#arrowhead{fill:#333}#crosshead path{fill:#333!important;stroke:#333!important}.messageText{fill:#333;stroke:none}.labelBox{stroke:#326932;fill:#cde498}.labelText,.loopText{fill:#000;stroke:none}.loopLine{stroke-width:2;stroke-dasharray:"2 2";marker-end:"url(#arrowhead)";stroke:#326932}.note{stroke:#6eaa49;fill:#fff5ad}.noteText{fill:#000;stroke:none;font-family:'trebuchet ms',verdana,arial;font-size:14px}.section{stroke:none;opacity:.2}.section0,.section2{fill:#6eaa49}.section1,.section3{fill:#fff;opacity:.2}.sectionTitle0,.sectionTitle1,.sectionTitle2,.sectionTitle3{fill:#333}.sectionTitle{text-anchor:start;font-size:11px;text-height:14px}.grid .tick{stroke:lightgrey;opacity:.3;shape-rendering:crispEdges}.grid path{stroke-width:0}.today{fill:none;stroke:red;stroke-width:2px}.task{stroke-width:2}.taskText{text-anchor:middle;font-size:11px}.taskTextOutsideRight{fill:#000;text-anchor:start;font-size:11px}.taskTextOutsideLeft{fill:#000;text-anchor:end;font-size:11px}.taskText0,.taskText1,.taskText2,.taskText3{fill:#fff}.task0,.task1,.task2,.task3{fill:#487e3a;stroke:#13540c}.taskTextOutside0,.taskTextOutside1,.taskTextOutside2,.taskTextOutside3{fill:#000}.active0,.active1,.active2,.active3{fill:#cde498;stroke:#13540c}.activeText0,.activeText1,.activeText2,.activeText3{fill:#000!important}.done0,.done1,.done2,.done3{stroke:grey;fill:lightgrey;stroke-width:2}.doneText0,.doneText1,.doneText2,.doneText3{fill:#000!important}.crit0,.crit1,.crit2,.crit3{stroke:#f88;fill:red;stroke-width:2}.activeCrit0,.activeCrit1,.activeCrit2,.activeCrit3{stroke:#f88;fill:#cde498;stroke-width:2}.doneCrit0,.doneCrit1,.doneCrit2,.doneCrit3{stroke:#f88;fill:lightgrey;stroke-width:2;cursor:pointer;shape-rendering:crispEdges}.activeCritText0,.activeCritText1,.activeCritText2,.activeCritText3,.doneCritText0,.doneCritText1,.doneCritText2,.doneCritText3{fill:#000!important}.titleText{text-anchor:middle;font-size:18px;fill:#000}text{font-family:'trebuchet ms',verdana,arial;font-size:14px}html{height:100%}body{margin:0!important;padding:5px 20px 26px!important;background-color:#fff;font-family:"Lucida Grande","Segoe UI","Apple SD Gothic Neo","Malgun Gothic","Lucida Sans Unicode",Helvetica,Arial,sans-serif;font-size:.9em;overflow-x:hidden;overflow-y:auto}br,h1,h2,h3,h4,h5,h6{clear:both}hr.page{background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAECAYAAACtBE5DAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBNYWNpbnRvc2giIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OENDRjNBN0E2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OENDRjNBN0I2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo4Q0NGM0E3ODY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo4Q0NGM0E3OTY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PqqezsUAAAAfSURBVHjaYmRABcYwBiM2QSA4y4hNEKYDQxAEAAIMAHNGAzhkPOlYAAAAAElFTkSuQmCC) repeat-x;border:0;height:3px;padding:0}hr.underscore{border-top-style:dashed!important}body >:first-child{margin-top:0!important}img.plugin{box-shadow:0 1px 3px rgba(0,0,0,.1);border-radius:3px}iframe{border:0}figure{-webkit-margin-before:0;-webkit-margin-after:0;-webkit-margin-start:0;-webkit-margin-end:0}kbd{border:1px solid #aaa;-moz-border-radius:2px;-webkit-border-radius:2px;border-radius:2px;-moz-box-shadow:1px 2px 2px #ddd;-webkit-box-shadow:1px 2px 2px #ddd;box-shadow:1px 2px 2px #ddd;background-color:#f9f9f9;background-image:-moz-linear-gradient(top,#eee,#f9f9f9,#eee);background-image:-o-linear-gradient(top,#eee,#f9f9f9,#eee);background-image:-webkit-linear-gradient(top,#eee,#f9f9f9,#eee);background-image:linear-gradient(top,#eee,#f9f9f9,#eee);padding:1px 3px;font-family:inherit;font-size:.85em}.oembeded .oembed_photo{display:inline-block}img[data-echo]{margin:25px 0;width:100px;height:100px;background:url(../img/ajax.gif) center center no-repeat #fff}.spinner{display:inline-block;width:10px;height:10px;margin-bottom:-.1em;border:2px solid rgba(0,0,0,.5);border-top-color:transparent;border-radius:100%;-webkit-animation:spin 1s infinite linear;animation:spin 1s infinite linear}.spinner:after{content:'';display:block;width:0;height:0;position:absolute;top:-6px;left:0;border:4px solid transparent;border-bottom-color:rgba(0,0,0,.5);-webkit-transform:rotate(45deg);transform:rotate(45deg)}@-webkit-keyframes spin{to{-webkit-transform:rotate(360deg)}}@keyframes spin{to{transform:rotate(360deg)}}p.toc{margin:0!important}p.toc ul{padding-left:10px}p.toc>ul{padding:10px;margin:0 10px;display:inline-block;border:1px solid #ededed;border-radius:5px}p.toc li,p.toc ul{list-style-type:none}p.toc li{width:100%;padding:0;overflow:hidden}p.toc li a::after{content:"."}p.toc li a:before{content:"• "}p.toc h5{text-transform:uppercase}p.toc .title{float:left;padding-right:3px}p.toc .number{margin:0;float:right;padding-left:3px;background:#fff;display:none}input.task-list-item{margin-left:-1.62em}.markdown{font-family:"Hiragino Sans GB","Microsoft YaHei",STHeiti,SimSun,"Lucida Grande","Lucida Sans Unicode","Lucida Sans",'Segoe UI',AppleSDGothicNeo-Medium,'Malgun Gothic',Verdana,Tahoma,sans-serif;padding:20px}.markdown a{text-decoration:none;vertical-align:baseline}.markdown a:hover{text-decoration:underline}.markdown h1{font-size:2.2em;font-weight:700;margin:1.5em 0 1em}.markdown h2{font-size:1.8em;font-weight:700;margin:1.275em 0 .85em}.markdown h3{font-size:1.6em;font-weight:700;margin:1.125em 0 .75em}.markdown h4{font-size:1.4em;font-weight:700;margin:.99em 0 .66em}.markdown h5{font-size:1.2em;font-weight:700;margin:.855em 0 .57em}.markdown h6{font-size:1em;font-weight:700;margin:.75em 0 .5em}.markdown h1+p,.markdown h1:first-child,.markdown h2+p,.markdown h2:first-child,.markdown h3+p,.markdown h3:first-child,.markdown h4+p,.markdown h4:first-child,.markdown h5+p,.markdown h5:first-child,.markdown h6+p,.markdown h6:first-child{margin-top:0}.markdown hr{border:1px solid #ccc}.markdown p{margin:1em 0;word-wrap:break-word}.markdown ol{list-style-type:decimal}.markdown li{display:list-item;line-height:1.4em}.markdown blockquote{margin:1em 20px}.markdown blockquote>:first-child{margin-top:0}.markdown blockquote>:last-child{margin-bottom:0}.markdown blockquote cite:before{content:'\2014 \00A0'}.markdown .code{border-radius:3px;word-wrap:break-word}.markdown pre{border-radius:3px;word-wrap:break-word;border:1px solid #ccc;overflow:auto;padding:.5em}.markdown pre code{border:0;display:block}.markdown pre>code{font-family:Consolas,Inconsolata,Courier,monospace;font-weight:700;white-space:pre;margin:0}.markdown code{border-radius:3px;word-wrap:break-word;border:1px solid #ccc;padding:0 5px;margin:0 2px}.markdown img{max-width:100%}.markdown mark{color:#000;background-color:#fcf8e3}.markdown table{padding:0;border-collapse:collapse;border-spacing:0;margin-bottom:16px}.markdown table tr td,.markdown table tr th{border:1px solid #ccc;margin:0;padding:6px 13px}.markdown table tr th{font-weight:700}.markdown table tr th>:first-child{margin-top:0}.markdown table tr th>:last-child{margin-bottom:0}.markdown table tr td>:first-child{margin-top:0}.markdown table tr td>:last-child{margin-bottom:0}.clearness{padding:20px;color:#737373;font-size:15px;background:#fff;-webkit-font-smoothing:antialiased}.clearness a{color:#1e6ea7}.clearness a:hover{color:#268bd2}.clearness h1,.clearness h2,.clearness h3,.clearness h4,.clearness h5{color:#404040}.clearness h2{border-bottom:1px solid #ccc;line-height:1.7em}.clearness h6{color:#666}.clearness hr{border:1px solid #e6e6e6}.clearness pre>code{font-size:.9em}.clearness blockquote{padding:0 15px;font-style:italic}.clearness blockquote:before{content:"\201C";font-size:40px;margin-left:-20px;color:#aaa}.clearness table{background-color:#fff;border-collapse:separate;border-spacing:2px}.clearness table tr td,.clearness table tr th{border:0;padding:.2em 1em}.clearness table tr th{border-bottom:1px solid #bfbfbf}.clearness table tr td{border-bottom:1px solid #d9d9d9}.clearness table tr:nth-child(2n){background-color:#fff}.hljs{display:block;overflow-x:auto;padding:.5em;background:#fdf6e3;color:#657b83;-webkit-text-size-adjust:none}.diff .hljs-header,.hljs-comment,.hljs-doctype,.hljs-javadoc,.hljs-pi,.lisp .hljs-string{color:#93a1a1}.css .hljs-tag,.hljs-addition,.hljs-keyword,.hljs-request,.hljs-status,.hljs-winutils,.method,.nginx .hljs-title{color:#859900}.hljs-command,.hljs-dartdoc,.hljs-hexcolor,.hljs-link_url,.hljs-number,.hljs-phpdoc,.hljs-regexp,.hljs-rules .hljs-value,.hljs-string,.hljs-tag .hljs-value,.tex .hljs-formula{color:#2aa198}.css .hljs-function,.hljs-built_in,.hljs-chunk,.hljs-decorator,.hljs-id,.hljs-identifier,.hljs-localvars,.hljs-title,.vhdl .hljs-literal{color:#268bd2}.hljs-attribute,.hljs-class .hljs-title,.hljs-constant,.hljs-link_reference,.hljs-parent,.hljs-type,.hljs-variable,.lisp .hljs-body,.smalltalk .hljs-number{color:#b58900}.css .hljs-pseudo,.diff .hljs-change,.hljs-attr_selector,.hljs-cdata,.hljs-header,.hljs-pragma,.hljs-preprocessor,.hljs-preprocessor .hljs-keyword,.hljs-shebang,.hljs-special,.hljs-subst,.hljs-symbol,.hljs-symbol .hljs-string{color:#cb4b16}.hljs-deletion,.hljs-important{color:#dc322f}.hljs-link_label{color:#6c71c4}.tex .hljs-formula{background:#eee8d5}.MathJax_Hover_Frame{border-radius:.25em;-webkit-border-radius:.25em;-moz-border-radius:.25em;-khtml-border-radius:.25em;box-shadow:0 0 15px #83A;-webkit-box-shadow:0 0 15px #83A;-moz-box-shadow:0 0 15px #83A;-khtml-box-shadow:0 0 15px #83A;border:1px solid #A6D!important;display:inline-block;position:absolute}.MathJax_Hover_Arrow{position:absolute;width:15px;height:11px;cursor:pointer}#MathJax_About{position:fixed;left:50%;width:auto;text-align:center;border:3px outset;padding:1em 2em;background-color:#DDD;color:#000;cursor:default;font-family:message-box;font-size:120%;font-style:normal;text-indent:0;text-transform:none;line-height:normal;letter-spacing:normal;word-spacing:normal;word-wrap:normal;white-space:nowrap;float:none;z-index:201;border-radius:15px;-webkit-border-radius:15px;-moz-border-radius:15px;-khtml-border-radius:15px;box-shadow:0 10px 20px gray;-webkit-box-shadow:0 10px 20px gray;-moz-box-shadow:0 10px 20px gray;-khtml-box-shadow:0 10px 20px gray;filter:progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}.MathJax_Menu{position:absolute;background-color:#fff;color:#000;width:auto;padding:5px 0;border:1px solid #CCC;margin:0;cursor:default;font:menu;text-align:left;text-indent:0;text-transform:none;line-height:normal;letter-spacing:normal;word-spacing:normal;word-wrap:normal;white-space:nowrap;float:none;z-index:201;border-radius:5px;-webkit-border-radius:5px;-moz-border-radius:5px;-khtml-border-radius:5px;box-shadow:0 10px 20px gray;-webkit-box-shadow:0 10px 20px gray;-moz-box-shadow:0 10px 20px gray;-khtml-box-shadow:0 10px 20px gray;filter:progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}.MathJax_MenuItem{padding:1px 2em;background:0 0}.MathJax_MenuArrow{position:absolute;right:.5em;color:#666}.MathJax_MenuActive .MathJax_MenuArrow{color:#fff}.MathJax_MenuArrow.RTL{left:.5em;right:auto}.MathJax_MenuCheck{position:absolute;left:.7em}.MathJax_MenuCheck.RTL{right:.7em;left:auto}.MathJax_MenuRadioCheck{position:absolute;left:.7em}.MathJax_MenuRadioCheck.RTL{right:.7em;left:auto}.MathJax_MenuLabel{padding:1px 2em 3px 1.33em;font-style:italic}.MathJax_MenuRule{border-top:1px solid #DDD;margin:4px 3px}.MathJax_MenuDisabled{color:GrayText}.MathJax_MenuActive{background-color:#606872;color:#fff}.MathJax_Menu_Close{position:absolute;width:31px;height:31px;top:-15px;left:-15px}#MathJax_Zoom{position:absolute;background-color:#F0F0F0;overflow:auto;display:block;z-index:301;padding:.5em;border:1px solid #000;margin:0;font-weight:400;font-style:normal;text-align:left;text-indent:0;text-transform:none;line-height:normal;letter-spacing:normal;word-spacing:normal;word-wrap:normal;white-space:nowrap;float:none;box-shadow:5px 5px 15px #AAA;-webkit-box-shadow:5px 5px 15px #AAA;-moz-box-shadow:5px 5px 15px #AAA;-khtml-box-shadow:5px 5px 15px #AAA;filter:progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}#MathJax_ZoomOverlay{position:absolute;left:0;top:0;z-index:300;display:inline-block;width:100%;height:100%;border:0;padding:0;margin:0;background-color:#fff;opacity:0;filter:alpha(opacity=0)}#MathJax_ZoomFrame{position:relative;display:inline-block;height:0;width:0}#MathJax_ZoomEventTrap{position:absolute;left:0;top:0;z-index:302;display:inline-block;border:0;padding:0;margin:0;background-color:#fff;opacity:0;filter:alpha(opacity=0)}.MathJax_Preview{color:#888}#MathJax_Message{position:fixed;left:1px;bottom:2px;background-color:#E6E6E6;border:1px solid #959595;margin:0;padding:2px 8px;z-index:102;color:#000;font-size:80%;width:auto;white-space:nowrap}#MathJax_MSIE_Frame{position:absolute;top:0;left:0;width:0;z-index:101;border:0;margin:0;padding:0}.MathJax_Error{color:#C00;font-style:italic}footer{position:fixed;font-size:.8em;text-align:right;bottom:0;margin-left:-25px;height:20px;width:100%}</style>
</head>
<body class="markdown clearness">
<p class="toc" style="undefined"></p><ul>
<li><ul>
<li><ul>
<li><ul>
<li><ul>
<li><span class="title">
<a href="#119帕斯卡三角第k行" title="119帕斯卡三角第k行">119帕斯卡三角第k行</a>
</span>
<!--span class="number">
0
</span-->
</li>
<li><span class="title">
<a href="#650-2-key-keyboard" title="650 2 key keyboard">650 2 key keyboard</a>
</span>
<!--span class="number">
1
</span-->
</li>
<li><span class="title">
<a href="#98-validate-bst" title="98 Validate BST">98 Validate BST</a>
</span>
<!--span class="number">
2
</span-->
</li>
<li><span class="title">
<a href="#383-random-note" title="383 random Note">383 random Note</a>
</span>
<!--span class="number">
3
</span-->
</li>
<li><span class="title">
<a href="#506relative-ranks" title="506relative ranks">506relative ranks</a>
</span>
<!--span class="number">
4
</span-->
</li>
<li><span class="title">
<a href="#640-solve-the-equation" title="640 solve the equation">640 solve the equation</a>
</span>
<!--span class="number">
5
</span-->
</li>
<li><span class="title">
<a href="#220-contains-duplicate-iii" title="220 Contains Duplicate III">220 Contains Duplicate III</a>
</span>
<!--span class="number">
6
</span-->
</li>
<li><span class="title">
<a href="#501-find-mode-in-bst" title="501 find mode in BST">501 find mode in BST</a>
</span>
<!--span class="number">
7
</span-->
</li>
<li><span class="title">
<a href="#459-repeated-substring-pattern" title="459 repeated substring pattern">459 repeated substring pattern</a>
</span>
<!--span class="number">
8
</span-->
</li>
<li><span class="title">
<a href="#73-matrix-setzeros" title="73 matrix setzeros">73 matrix setzeros</a>
</span>
<!--span class="number">
9
</span-->
</li>
<li><span class="title">
<a href="#657-judeg-route-circle" title="657 judeg route circle">657 judeg route circle</a>
</span>
<!--span class="number">
10
</span-->
</li>
<li><span class="title">
<a href="#343-interbreak" title="343 interbreak">343 interbreak</a>
</span>
<!--span class="number">
11
</span-->
</li>
<li><span class="title">
<a href="#112-path-sum" title="112 Path Sum">112 Path Sum</a>
</span>
<!--span class="number">
12
</span-->
</li>
<li><span class="title">
<a href="#49-group-anagrams" title="49 group Anagrams">49 group Anagrams</a>
</span>
<!--span class="number">
13
</span-->
</li>
<li><span class="title">
<a href="#24-swap-nodes-in-pairs" title="24 swap nodes in pairs">24 swap nodes in pairs</a>
</span>
<!--span class="number">
14
</span-->
</li>
<li><span class="title">
<a href="#319-bulb-switcher" title="319 Bulb Switcher">319 Bulb Switcher</a>
</span>
<!--span class="number">
15
</span-->
</li>
<li><span class="title">
<a href="#439-find-right-interval" title="439 find right interval">439 find right interval</a>
</span>
<!--span class="number">
16
</span-->
</li>
<li><span class="title">
<a href="#645-set-mismatch" title="645 set mismatch">645 set mismatch</a>
</span>
<!--span class="number">
17
</span-->
</li>
<li><span class="title">
<a href="#27-remove-element" title="27 remove element">27 remove element</a>
</span>
<!--span class="number">
18
</span-->
</li>
<li><span class="title">
<a href="#152-maximum-product-subarray" title="152 maximum product subarray">152 maximum product subarray</a>
</span>
<!--span class="number">
19
</span-->
</li>
<li><span class="title">
<a href="#166-fraction-to-recurring-decimal" title="166 fraction to recurring decimal">166 fraction to recurring decimal</a>
</span>
<!--span class="number">
20
</span-->
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>

</ul>
<p></p><h5 id="119帕斯卡三角第k行"><a name="119帕斯卡三角第k行" href="#119帕斯卡三角第k行"></a>119帕斯卡三角第k行</h5><p>1<br>1 1<br>1 2 1<br>1 3 3 1<br>1 4 6 4 1.<br>一开始以为可以从行数k直接推导公式,后来发现十分困难,不好总结(二次三次,,,的叠加)<br>于是想到可以从第0行开始计算.<br>第0行是[1]<br>那么第一行元素可以由第0行推导出来.这时,可以假设每一行左右都有两个[0]元素.这样就可以相加了.<br>那么由这个思路可以导出两种类似的解法,一个是上面说的两边加0,一个是左右各自加0,其实是一样的.</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>    def getRow(self, rowIndex):
        &quot;&quot;&quot;
        :type rowIndex: int
        :rtype: List[int]
        &quot;&quot;&quot;
        #Solution 1
        res = [1]
        for i in range(rowIndex):
            res = [x+y for x,y in zip([0]+res,res+[0])]
        return res
        #Solution 2
        res = [1]
        for i in range(rowIndex):
            res1 = [0]+res+[0]
            res = [res1[i]+res1[i+1] for i in range(len(res1)-1)]
        return res
</code></pre>">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getRow</span><span class="hljs-params">(self, rowIndex)</span>:</span>
        <span class="hljs-string">"""
        :type rowIndex: int
        :rtype: List[int]
        """</span>
        <span class="hljs-comment">#Solution 1</span>
        res = [<span class="hljs-number">1</span>]
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(rowIndex):
            res = [x+y <span class="hljs-keyword">for</span> x,y <span class="hljs-keyword">in</span> zip([<span class="hljs-number">0</span>]+res,res+[<span class="hljs-number">0</span>])]
        <span class="hljs-keyword">return</span> res
        <span class="hljs-comment">#Solution 2</span>
        res = [<span class="hljs-number">1</span>]
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(rowIndex):
            res1 = [<span class="hljs-number">0</span>]+res+[<span class="hljs-number">0</span>]
            res = [res1[i]+res1[i+<span class="hljs-number">1</span>] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(res1)-<span class="hljs-number">1</span>)]
        <span class="hljs-keyword">return</span> res
</code></pre><h5 id="650-2-key-keyboard"><a name="650-2-key-keyboard" href="#650-2-key-keyboard"></a>650 2 key keyboard</h5><p>给出n.假设book上初始只有一个’A’,只可以进行两个操作1复制book上文字,2粘贴.求解需要的最少步骤.<br>思路的话假设n=12,那么从后面思考,最后一步粘贴的个数k一定是n的约数,比如3,4,6这样的,那么只需要假设最后一步粘贴了3个,再求出第一次在book上制作出3个需要几步就行了.<br>这里为了避免处理1这个问题,(book)上本来就有1个,不需要进行其他操作,所以对1,2,3三种情况单独处理.并且也以1作为初始最少步数.递归即可.</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>def yueshu(n):
    res = []
    for i in range(2,n):
        if n%i == 0:
            res.append(i)
    return res
def minSteps(n):
    &quot;&quot;&quot;
    :type n: int
    :rtype: int
    &quot;&quot;&quot;
    if n == 1:
        return 0
    if n == 2:
        return 2
    if n == 3:
        return 3
    mins = n
    nowmins = n
    ylist = yueshu(n)
    for y in ylist:
        nowmins = (n-y)/y+1+minstep(y)
        mins = min(mins,nowmins)
    return mins
</code></pre>"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">yueshu</span><span class="hljs-params">(n)</span>:</span>
    res = []
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>,n):
        <span class="hljs-keyword">if</span> n%i == <span class="hljs-number">0</span>:
            res.append(i)
    <span class="hljs-keyword">return</span> res
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">minSteps</span><span class="hljs-params">(n)</span>:</span>
    <span class="hljs-string">"""
    :type n: int
    :rtype: int
    """</span>
    <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>
    <span class="hljs-keyword">if</span> n == <span class="hljs-number">2</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>
    <span class="hljs-keyword">if</span> n == <span class="hljs-number">3</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>
    mins = n
    nowmins = n
    ylist = yueshu(n)
    <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> ylist:
        nowmins = (n-y)/y+<span class="hljs-number">1</span>+minstep(y)
        mins = min(mins,nowmins)
    <span class="hljs-keyword">return</span> mins
</code></pre><h5 id="98-validate-bst"><a name="98-validate-bst" href="#98-validate-bst"></a>98 Validate BST</h5><p>题目比较简单,给定一个二叉树判断是不是二叉搜索树,刚开始想错了方向,以为递归比较左叶子和右叶子,忽略了BST的规则是要求左叶子的所有节点值也要小于该节点,而只比较该节点左右并递归则忽略了这一点.后来想到可以使用中序遍历的结果是否升序进行判断即可.</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>    def isValid(self,root,res):
        if root.left!=None:
            self.isValid(root.left,res)
        res.append(root.val)
        if root.right !=None:
            self.isValid(root.right,res)

    def isValidBST(self, root):
        &quot;&quot;&quot;
        :type root: TreeNode
        :rtype: bool
        &quot;&quot;&quot;
        res = []
        self.isValid(root,res)
        for i in range(len(res)-1):
            if res[i]&amp;gt;=res[i+1]:
                return False
        return True
</code></pre>">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isValid</span><span class="hljs-params">(self,root,res)</span>:</span>
        <span class="hljs-keyword">if</span> root.left!=<span class="hljs-keyword">None</span>:
            self.isValid(root.left,res)
        res.append(root.val)
        <span class="hljs-keyword">if</span> root.right !=<span class="hljs-keyword">None</span>:
            self.isValid(root.right,res)

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(self, root)</span>:</span>
        <span class="hljs-string">"""
        :type root: TreeNode
        :rtype: bool
        """</span>
        res = []
        self.isValid(root,res)
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(res)-<span class="hljs-number">1</span>):
            <span class="hljs-keyword">if</span> res[i]&gt;=res[i+<span class="hljs-number">1</span>]:
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">False</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">True</span>
</code></pre><h5 id="383-random-note"><a name="383-random-note" href="#383-random-note"></a>383 random Note</h5><p>给定两个字符串,判断前一个能否使用后一个里的内容组成,顺序无关,个数有关.<br>直接将后一个组成字典而后尝试组成第一个判断即可.</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>    def canConstruct(self, ransomNote, magazine):
        &quot;&quot;&quot;
        :type ransomNote: str
        :type magazine: str
        :rtype: bool
        &quot;&quot;&quot;
        dict2 = {}
        for i in magazine:
            if i in dict2:
                dict2[i] = dict2[i]+1
            else:
                dict2[i] = 1
        for i in ransomNote:
            if i not in dict2 or dict2[i]==0:
                return False
            else:
                dict2[i] = dict2[i]-1
        return True
</code></pre>">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">canConstruct</span><span class="hljs-params">(self, ransomNote, magazine)</span>:</span>
        <span class="hljs-string">"""
        :type ransomNote: str
        :type magazine: str
        :rtype: bool
        """</span>
        dict2 = {}
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> magazine:
            <span class="hljs-keyword">if</span> i <span class="hljs-keyword">in</span> dict2:
                dict2[i] = dict2[i]+<span class="hljs-number">1</span>
            <span class="hljs-keyword">else</span>:
                dict2[i] = <span class="hljs-number">1</span>
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> ransomNote:
            <span class="hljs-keyword">if</span> i <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> dict2 <span class="hljs-keyword">or</span> dict2[i]==<span class="hljs-number">0</span>:
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">False</span>
            <span class="hljs-keyword">else</span>:
                dict2[i] = dict2[i]-<span class="hljs-number">1</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">True</span>
</code></pre><h5 id="506relative-ranks"><a name="506relative-ranks" href="#506relative-ranks"></a>506relative ranks</h5><p>本题也比较简单,给定一串数字,给出他们相应的排名,前三名替换成相关的词语即可.<br>还是以一个dict存储数组的排名而后遍历数组查找排名值进行更改.</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>    def findRelativeRanks(self, nums):
        &quot;&quot;&quot;
        :type nums: List[int]
        :rtype: List[str]
        &quot;&quot;&quot;
        res = sorted(nums,reverse=True)
        dict1 = {i:inx for inx,i in enumerate(res)}
        print(nums)
        for inx,i in enumerate(nums):
            if dict1[i]&amp;gt;=3:
                nums[inx] = str(dict1[i]+1)
            elif dict1[i]==0:
                nums[inx]=&quot;Gold Medal&quot;
            elif dict1[i]==1:
                nums[inx] =&quot;Silver Medal&quot;
            else:
                nums[inx] =  &quot;Bronze Medal&quot;
        return nums
</code></pre>">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findRelativeRanks</span><span class="hljs-params">(self, nums)</span>:</span>
        <span class="hljs-string">"""
        :type nums: List[int]
        :rtype: List[str]
        """</span>
        res = sorted(nums,reverse=<span class="hljs-keyword">True</span>)
        dict1 = {i:inx <span class="hljs-keyword">for</span> inx,i <span class="hljs-keyword">in</span> enumerate(res)}
        print(nums)
        <span class="hljs-keyword">for</span> inx,i <span class="hljs-keyword">in</span> enumerate(nums):
            <span class="hljs-keyword">if</span> dict1[i]&gt;=<span class="hljs-number">3</span>:
                nums[inx] = str(dict1[i]+<span class="hljs-number">1</span>)
            <span class="hljs-keyword">elif</span> dict1[i]==<span class="hljs-number">0</span>:
                nums[inx]=<span class="hljs-string">"Gold Medal"</span>
            <span class="hljs-keyword">elif</span> dict1[i]==<span class="hljs-number">1</span>:
                nums[inx] =<span class="hljs-string">"Silver Medal"</span>
            <span class="hljs-keyword">else</span>:
                nums[inx] =  <span class="hljs-string">"Bronze Medal"</span>
        <span class="hljs-keyword">return</span> nums
</code></pre><h5 id="640-solve-the-equation"><a name="640-solve-the-equation" href="#640-solve-the-equation"></a>640 solve the equation</h5><p>求解一个方程式,简单之处在于确定了只有加减和x变量.<br>思路的话就是先将方程规范化后分别统计x的个数个常数的值最后进行计算即可.</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>class Solution(object):
    def makexp(self,str):
        xcount = 0
        numcount = 0
        start = 0
        end = 0
        i = 0
        while i &amp;lt; len(str):
            if str[i]=='+' or str[i]=='-':
                start = i
                i = i + 1
            while i&amp;lt;len(str) and (str[i]!='+' and str[i]!='-') :
                i = i + 1
            end = i
            tmp = str[start:end]
            if 'x' in tmp:
                xcount = xcount + int(tmp[0:-1])
            else:
                numcount = numcount + int(tmp)
            if end==len(str)-1:
                break
        return xcount,numcount
    def solveEquation(self, equation):
        &quot;&quot;&quot;
        :type equation: str
        :rtype: str
        &quot;&quot;&quot;
        str1 = equation[0:equation.index('=')]
        str2 = equation[equation.index('=')+1:]
        if str1[0]!='-':
            str1 = '+'+str1
        if str2[0]!='-':
            str2 = '+'+str2
        str1 = str1.replace('+x','+1x')
        str1 = str1.replace('-x','-1x')
        str2 = str2.replace('+x','+1x')
        str2 = str2.replace('-x','-1x')
        x1,n1 = self.makexp(str1)
        x2,n2 = self.makexp(str2)
        x = x1-x2
        n = n1-n2
        result = ''
        if x==0 and n!=0:
            result = 'No solution'
        elif x==0 and n == 0:
            result = 'Infinite solutions'
        else:
            result = 'x='+str(-1*n/x)
        return result
</code></pre>"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">makexp</span><span class="hljs-params">(self,str)</span>:</span>
        xcount = <span class="hljs-number">0</span>
        numcount = <span class="hljs-number">0</span>
        start = <span class="hljs-number">0</span>
        end = <span class="hljs-number">0</span>
        i = <span class="hljs-number">0</span>
        <span class="hljs-keyword">while</span> i &lt; len(str):
            <span class="hljs-keyword">if</span> str[i]==<span class="hljs-string">'+'</span> <span class="hljs-keyword">or</span> str[i]==<span class="hljs-string">'-'</span>:
                start = i
                i = i + <span class="hljs-number">1</span>
            <span class="hljs-keyword">while</span> i&lt;len(str) <span class="hljs-keyword">and</span> (str[i]!=<span class="hljs-string">'+'</span> <span class="hljs-keyword">and</span> str[i]!=<span class="hljs-string">'-'</span>) :
                i = i + <span class="hljs-number">1</span>
            end = i
            tmp = str[start:end]
            <span class="hljs-keyword">if</span> <span class="hljs-string">'x'</span> <span class="hljs-keyword">in</span> tmp:
                xcount = xcount + int(tmp[<span class="hljs-number">0</span>:-<span class="hljs-number">1</span>])
            <span class="hljs-keyword">else</span>:
                numcount = numcount + int(tmp)
            <span class="hljs-keyword">if</span> end==len(str)-<span class="hljs-number">1</span>:
                <span class="hljs-keyword">break</span>
        <span class="hljs-keyword">return</span> xcount,numcount
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">solveEquation</span><span class="hljs-params">(self, equation)</span>:</span>
        <span class="hljs-string">"""
        :type equation: str
        :rtype: str
        """</span>
        str1 = equation[<span class="hljs-number">0</span>:equation.index(<span class="hljs-string">'='</span>)]
        str2 = equation[equation.index(<span class="hljs-string">'='</span>)+<span class="hljs-number">1</span>:]
        <span class="hljs-keyword">if</span> str1[<span class="hljs-number">0</span>]!=<span class="hljs-string">'-'</span>:
            str1 = <span class="hljs-string">'+'</span>+str1
        <span class="hljs-keyword">if</span> str2[<span class="hljs-number">0</span>]!=<span class="hljs-string">'-'</span>:
            str2 = <span class="hljs-string">'+'</span>+str2
        str1 = str1.replace(<span class="hljs-string">'+x'</span>,<span class="hljs-string">'+1x'</span>)
        str1 = str1.replace(<span class="hljs-string">'-x'</span>,<span class="hljs-string">'-1x'</span>)
        str2 = str2.replace(<span class="hljs-string">'+x'</span>,<span class="hljs-string">'+1x'</span>)
        str2 = str2.replace(<span class="hljs-string">'-x'</span>,<span class="hljs-string">'-1x'</span>)
        x1,n1 = self.makexp(str1)
        x2,n2 = self.makexp(str2)
        x = x1-x2
        n = n1-n2
        result = <span class="hljs-string">''</span>
        <span class="hljs-keyword">if</span> x==<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> n!=<span class="hljs-number">0</span>:
            result = <span class="hljs-string">'No solution'</span>
        <span class="hljs-keyword">elif</span> x==<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> n == <span class="hljs-number">0</span>:
            result = <span class="hljs-string">'Infinite solutions'</span>
        <span class="hljs-keyword">else</span>:
            result = <span class="hljs-string">'x='</span>+str(-<span class="hljs-number">1</span>*n/x)
        <span class="hljs-keyword">return</span> result
</code></pre><h5 id="220-contains-duplicate-iii"><a name="220-contains-duplicate-iii" href="#220-contains-duplicate-iii"></a>220 Contains Duplicate III</h5><p>这道题目比较难.没有做出来,看了别人的思路后理解了.<br>首先最简单的思路肯定是循环遍历,这样的思路的话复杂度是kn,显然是没法通过的.<br>由此可以想到hash和桶这两种思路.<br>桶的话需要考虑一个桶的边界,这里因为要求两个数之间差值小于等于t,那么就以t+1作为桶的大小这样.然后就可以得到两个结论:分好桶之后,两个差值小于等于t的数必定是在同一个桶或者相邻两边的桶.如此即可判断.<br>这样的话需要考虑每过k个点需要将前面超过k长度的部分清空.这里其实很简单,之间每一步删除即可.这里有个小前提就是删除的话其实已经间接的表明了前面k个数里没有小于t的差值所以可以保证删除的那个正好就是向前数k个位置的.<br>这样通过遍历,每次求出当前数字的桶标号后查看左右两边是否符合,并且同时将向前数k个位置的删除.即可.</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>class Solution(object):
    def containsNearbyAlmostDuplicate(self, nums, k, t):
        &quot;&quot;&quot;
        :type nums: List[int]
        :type k: int
        :type t: int
        :rtype: bool
        &quot;&quot;&quot;
        if t&amp;lt;0:
            return False
        w = t + 1
        d ={}
        for i in range(len(nums)):
            m = nums[i]/w
            if m in d:
                return True
            if m-1 in d and abs(nums[i]-d[m-1])&amp;lt;w:
                return True
            if m+1 in d and abs(nums[i]-d[m+1])&amp;lt;w:
                return True
            d[m] = nums[i]
            if i&amp;gt;=k:
                del d[nums[i-k]/w]
        return False
</code></pre>"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">containsNearbyAlmostDuplicate</span><span class="hljs-params">(self, nums, k, t)</span>:</span>
        <span class="hljs-string">"""
        :type nums: List[int]
        :type k: int
        :type t: int
        :rtype: bool
        """</span>
        <span class="hljs-keyword">if</span> t&lt;<span class="hljs-number">0</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">False</span>
        w = t + <span class="hljs-number">1</span>
        d ={}
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(nums)):
            m = nums[i]/w
            <span class="hljs-keyword">if</span> m <span class="hljs-keyword">in</span> d:
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">True</span>
            <span class="hljs-keyword">if</span> m-<span class="hljs-number">1</span> <span class="hljs-keyword">in</span> d <span class="hljs-keyword">and</span> abs(nums[i]-d[m-<span class="hljs-number">1</span>])&lt;w:
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">True</span>
            <span class="hljs-keyword">if</span> m+<span class="hljs-number">1</span> <span class="hljs-keyword">in</span> d <span class="hljs-keyword">and</span> abs(nums[i]-d[m+<span class="hljs-number">1</span>])&lt;w:
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">True</span>
            d[m] = nums[i]
            <span class="hljs-keyword">if</span> i&gt;=k:
                <span class="hljs-keyword">del</span> d[nums[i-k]/w]
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">False</span>
</code></pre><h5 id="501-find-mode-in-bst"><a name="501-find-mode-in-bst" href="#501-find-mode-in-bst"></a>501 find mode in BST</h5><p>在BST中找出出现次数最多的.直接中序遍历后就已经是顺序的了,然后统计即可.可以遍历统计这样比较方便且节省存储.</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>class Solution(object):
    def isValid(self,root,res):
        if root.left!=None:
            self.isValid(root.left,res)
        res.append(root.val)
        if root.right !=None:
            self.isValid(root.right,res)
    def findMode(self, root):
        &quot;&quot;&quot;
        :type root: TreeNode
        :rtype: List[int]
        &quot;&quot;&quot;
        if root == None:
            return []
        res = []
        maxnow = 0
        self.isValid(root,res)
        n = len(res)
        if n == 1:
            return res
        i = 0
        rrr = []
        while i&amp;lt;n:
            time = 1
            while i+1&amp;lt;n and res[i]==res[i+1]:
                i = i + 1
                time = time + 1
            if time &amp;gt; maxnow:
                rrr = []
                rrr.append(res[i])
                maxnow = time
            elif time == maxnow:
                rrr.append(res[i])
            i = i + 1
        return rrr
</code></pre>"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isValid</span><span class="hljs-params">(self,root,res)</span>:</span>
        <span class="hljs-keyword">if</span> root.left!=<span class="hljs-keyword">None</span>:
            self.isValid(root.left,res)
        res.append(root.val)
        <span class="hljs-keyword">if</span> root.right !=<span class="hljs-keyword">None</span>:
            self.isValid(root.right,res)
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findMode</span><span class="hljs-params">(self, root)</span>:</span>
        <span class="hljs-string">"""
        :type root: TreeNode
        :rtype: List[int]
        """</span>
        <span class="hljs-keyword">if</span> root == <span class="hljs-keyword">None</span>:
            <span class="hljs-keyword">return</span> []
        res = []
        maxnow = <span class="hljs-number">0</span>
        self.isValid(root,res)
        n = len(res)
        <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span>:
            <span class="hljs-keyword">return</span> res
        i = <span class="hljs-number">0</span>
        rrr = []
        <span class="hljs-keyword">while</span> i&lt;n:
            time = <span class="hljs-number">1</span>
            <span class="hljs-keyword">while</span> i+<span class="hljs-number">1</span>&lt;n <span class="hljs-keyword">and</span> res[i]==res[i+<span class="hljs-number">1</span>]:
                i = i + <span class="hljs-number">1</span>
                time = time + <span class="hljs-number">1</span>
            <span class="hljs-keyword">if</span> time &gt; maxnow:
                rrr = []
                rrr.append(res[i])
                maxnow = time
            <span class="hljs-keyword">elif</span> time == maxnow:
                rrr.append(res[i])
            i = i + <span class="hljs-number">1</span>
        <span class="hljs-keyword">return</span> rrr
</code></pre><h5 id="459-repeated-substring-pattern"><a name="459-repeated-substring-pattern" href="#459-repeated-substring-pattern"></a>459 repeated substring pattern</h5><p>求一个字符串是否是由子串复制n次得出来的.<br>基本的思路是查看其中出现次数最少的字母出现的次数,那么循环区间长度一定是length/(次数的约数)这个范围内,而后挨个遍历即可.</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>    def repeatedSubstringPattern(self, s):
        &quot;&quot;&quot;
        :type s: str
        :rtype: bool
        &quot;&quot;&quot;
        d = {}
        for i in s:
            if i in d:
                d[i] = d[i] + 1
            else:
                d[i] = 1
        print(d)
        dk = min(d.values())
        if dk == 1:
            return False
        ys = []
        n = len(s)
        for i in range(dk,1,-1):
            if dk%i == 0 and n%i==0:
                ys.append(n/i)
        print(dk,ys)
        for i in ys:
            nowc = i
            flag = True
            for j in range(0,len(s)/nowc-1):
                if s[j*nowc:(j+1)*nowc] != s[(j+1)*nowc:(j+2)*nowc]:
                    flag = False
            if flag == True:
                return True
        return False
</code></pre>">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">repeatedSubstringPattern</span><span class="hljs-params">(self, s)</span>:</span>
        <span class="hljs-string">"""
        :type s: str
        :rtype: bool
        """</span>
        d = {}
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> s:
            <span class="hljs-keyword">if</span> i <span class="hljs-keyword">in</span> d:
                d[i] = d[i] + <span class="hljs-number">1</span>
            <span class="hljs-keyword">else</span>:
                d[i] = <span class="hljs-number">1</span>
        print(d)
        dk = min(d.values())
        <span class="hljs-keyword">if</span> dk == <span class="hljs-number">1</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">False</span>
        ys = []
        n = len(s)
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(dk,<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>):
            <span class="hljs-keyword">if</span> dk%i == <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> n%i==<span class="hljs-number">0</span>:
                ys.append(n/i)
        print(dk,ys)
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> ys:
            nowc = i
            flag = <span class="hljs-keyword">True</span>
            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>,len(s)/nowc-<span class="hljs-number">1</span>):
                <span class="hljs-keyword">if</span> s[j*nowc:(j+<span class="hljs-number">1</span>)*nowc] != s[(j+<span class="hljs-number">1</span>)*nowc:(j+<span class="hljs-number">2</span>)*nowc]:
                    flag = <span class="hljs-keyword">False</span>
            <span class="hljs-keyword">if</span> flag == <span class="hljs-keyword">True</span>:
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">True</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">False</span>
</code></pre><h5 id="73-matrix-setzeros"><a name="73-matrix-setzeros" href="#73-matrix-setzeros"></a>73 matrix setzeros</h5><p>要求将元素0的行列全部置换为0,要求原地修改.那么有一点需要注意的就是如果在统计的时候就修改了,后导致后面的统计出错.</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>class Solution(object):
    def setZeroes(self, matrix):
        &quot;&quot;&quot;
        :type matrix: List[List[int]]
        :rtype: void Do not return anything, modify matrix in-place instead.
        &quot;&quot;&quot;
        lx = len(matrix)
        ly = len(matrix[0])
        d = set()
        for row in range(len(matrix)):
            for col in range(len(matrix[0])):
                if matrix[row][col] == 0:
                    d.add((row,col))
        for (i,j) in d:
            nowx = i
            nowy = j
            print(i,j)
            matrix[i]=[0 for k in range(ly)]
            for k in range(lx):
                matrix[k][j]=0
</code></pre>"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">setZeroes</span><span class="hljs-params">(self, matrix)</span>:</span>
        <span class="hljs-string">"""
        :type matrix: List[List[int]]
        :rtype: void Do not return anything, modify matrix in-place instead.
        """</span>
        lx = len(matrix)
        ly = len(matrix[<span class="hljs-number">0</span>])
        d = set()
        <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> range(len(matrix)):
            <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> range(len(matrix[<span class="hljs-number">0</span>])):
                <span class="hljs-keyword">if</span> matrix[row][col] == <span class="hljs-number">0</span>:
                    d.add((row,col))
        <span class="hljs-keyword">for</span> (i,j) <span class="hljs-keyword">in</span> d:
            nowx = i
            nowy = j
            print(i,j)
            matrix[i]=[<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> range(ly)]
            <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> range(lx):
                matrix[k][j]=<span class="hljs-number">0</span>
</code></pre><h5 id="657-judeg-route-circle"><a name="657-judeg-route-circle" href="#657-judeg-route-circle"></a>657 judeg route circle</h5><p>起点0,0,经过几次移动后判断是否回到起点,直接模拟运动判断即可.</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>class Solution(object):
    def judgeCircle(self, moves):
        &quot;&quot;&quot;
        :type moves: str
        :rtype: bool
        &quot;&quot;&quot;
        &quot;LRUD&quot;
        origin = [0,0]
        for i in moves:
            if i=='L':
                origin[1] = origin[1]-1
            if i=='R':
                origin[1]=origin[1]+1
            if i=='U':
                origin[0]=origin[0]-1
            if i=='D':
                origin[0]=origin[0]+1
        if origin[0] == 0 and origin[1]==0:
            return True
        return False
</code></pre>"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">judgeCircle</span><span class="hljs-params">(self, moves)</span>:</span>
        <span class="hljs-string">"""
        :type moves: str
        :rtype: bool
        """</span>
        <span class="hljs-string">"LRUD"</span>
        origin = [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> moves:
            <span class="hljs-keyword">if</span> i==<span class="hljs-string">'L'</span>:
                origin[<span class="hljs-number">1</span>] = origin[<span class="hljs-number">1</span>]-<span class="hljs-number">1</span>
            <span class="hljs-keyword">if</span> i==<span class="hljs-string">'R'</span>:
                origin[<span class="hljs-number">1</span>]=origin[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>
            <span class="hljs-keyword">if</span> i==<span class="hljs-string">'U'</span>:
                origin[<span class="hljs-number">0</span>]=origin[<span class="hljs-number">0</span>]-<span class="hljs-number">1</span>
            <span class="hljs-keyword">if</span> i==<span class="hljs-string">'D'</span>:
                origin[<span class="hljs-number">0</span>]=origin[<span class="hljs-number">0</span>]+<span class="hljs-number">1</span>
        <span class="hljs-keyword">if</span> origin[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> origin[<span class="hljs-number">1</span>]==<span class="hljs-number">0</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">True</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">False</span>
</code></pre><h5 id="343-interbreak"><a name="343-interbreak" href="#343-interbreak"></a>343 interbreak</h5><p>给定一个整数,将其分解为几个正数之和使得这几个整数乘积最大.<br>直接递归即可,加上一个memory形成dp即可.需要注意这里需要比较的不仅仅是递归项inter(n-i)还有(n-i)本身的值.因为其有可能是大于inter(n-i)的.</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>class Solution(object):
    def inter(self,n,d):
        if n == 1:
            return 1
        maxvalue = 1
        tag = 0
        for i in range(1,n):
            tmp2 = 0
            if n-i in d:
                tmp2 = i*d[n-i]
            else:
                tmp2 = i*self.inter(n-i,d)
            if tmp2&amp;gt;maxvalue:
                tag = i
                maxvalue = tmp2
            if i*(n-i)&amp;gt;maxvalue:
                maxvalue = i*(n-i)
        d[n] = maxvalue
        return maxvalue
    def integerBreak(self, n):
        &quot;&quot;&quot;
        :type n: int
        :rtype: int
        &quot;&quot;&quot;
        d = {}
        res = self.inter(n,d)
        return res
</code></pre>"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">inter</span><span class="hljs-params">(self,n,d)</span>:</span>
        <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>
        maxvalue = <span class="hljs-number">1</span>
        tag = <span class="hljs-number">0</span>
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>,n):
            tmp2 = <span class="hljs-number">0</span>
            <span class="hljs-keyword">if</span> n-i <span class="hljs-keyword">in</span> d:
                tmp2 = i*d[n-i]
            <span class="hljs-keyword">else</span>:
                tmp2 = i*self.inter(n-i,d)
            <span class="hljs-keyword">if</span> tmp2&gt;maxvalue:
                tag = i
                maxvalue = tmp2
            <span class="hljs-keyword">if</span> i*(n-i)&gt;maxvalue:
                maxvalue = i*(n-i)
        d[n] = maxvalue
        <span class="hljs-keyword">return</span> maxvalue
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">integerBreak</span><span class="hljs-params">(self, n)</span>:</span>
        <span class="hljs-string">"""
        :type n: int
        :rtype: int
        """</span>
        d = {}
        res = self.inter(n,d)
        <span class="hljs-keyword">return</span> res
</code></pre><h5 id="112-path-sum"><a name="112-path-sum" href="#112-path-sum"></a>112 Path Sum</h5><p>给定二叉树,求解在所有从根到节点这样的路径上是否有和等于给定sum的.<br>采取了一个比较粗略的方式就是遍历整颗树直接将父节点的值增加到子节点上,最后统计叶子节点的值,没有再找出所有路径这样的.</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;># Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution(object):
    def dd(self,root,res):
        if root.left!=None:
            root.left.val = root.left.val+root.val
            self.dd(root.left,res)
        if root.right!=None:
            root.right.val = root.right.val+root.val
            self.dd(root.right,res)
        if root.left == None and root.right==None:
            res.append(root.val)


    def hasPathSum(self, root, sum):
        &quot;&quot;&quot;
        :type root: TreeNode
        :type sum: int
        :rtype: bool
        &quot;&quot;&quot;
        if root==None:
            return False
        res = []
        self.dd(root,res)
        if sum in res:
            return True
        return False
</code></pre>"><span class="hljs-comment"># Definition for a binary tree node.</span>
<span class="hljs-comment"># class TreeNode(object):</span>
<span class="hljs-comment">#     def __init__(self, x):</span>
<span class="hljs-comment">#         self.val = x</span>
<span class="hljs-comment">#         self.left = None</span>
<span class="hljs-comment">#         self.right = None</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dd</span><span class="hljs-params">(self,root,res)</span>:</span>
        <span class="hljs-keyword">if</span> root.left!=<span class="hljs-keyword">None</span>:
            root.left.val = root.left.val+root.val
            self.dd(root.left,res)
        <span class="hljs-keyword">if</span> root.right!=<span class="hljs-keyword">None</span>:
            root.right.val = root.right.val+root.val
            self.dd(root.right,res)
        <span class="hljs-keyword">if</span> root.left == <span class="hljs-keyword">None</span> <span class="hljs-keyword">and</span> root.right==<span class="hljs-keyword">None</span>:
            res.append(root.val)


    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hasPathSum</span><span class="hljs-params">(self, root, sum)</span>:</span>
        <span class="hljs-string">"""
        :type root: TreeNode
        :type sum: int
        :rtype: bool
        """</span>
        <span class="hljs-keyword">if</span> root==<span class="hljs-keyword">None</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">False</span>
        res = []
        self.dd(root,res)
        <span class="hljs-keyword">if</span> sum <span class="hljs-keyword">in</span> res:
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">True</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">False</span>
</code></pre><h5 id="49-group-anagrams"><a name="49-group-anagrams" href="#49-group-anagrams"></a>49 group Anagrams</h5><p>该题目给定一个字符串数组,需要将其中字符串内容一致的放在一起这样.<br>主要的内容是记录下一共几种字符串并且记录下相同字符串位置.这里采用了python里的tuple和dict分别记录了字符串种类和位置,然后重组即可.</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>class Solution(object):
    def groupAnagrams(self, strs):
        &quot;&quot;&quot;
        :type strs: List[str]
        :rtype: List[List[str]]
        [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;],
        [[&quot;ate&quot;, &quot;eat&quot;,&quot;tea&quot;],
        [&quot;nat&quot;,&quot;tan&quot;],
        [&quot;bat&quot;]
        &quot;&quot;&quot;
        res = []
        d = {}
        for i in range(len(strs)):
            tmp = tuple(sorted(strs[i]))
            if tmp in d:
                d[tmp] = d[tmp]+[i]
            else:
                d[tmp] = [i]
        for key in d:
            tmp = []
            for value in d[key]:
                tmp.append(strs[value])
            res.append(tmp)
        return res
</code></pre>"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">groupAnagrams</span><span class="hljs-params">(self, strs)</span>:</span>
        <span class="hljs-string">"""
        :type strs: List[str]
        :rtype: List[List[str]]
        ["eat", "tea", "tan", "ate", "nat", "bat"],
        [["ate", "eat","tea"],
        ["nat","tan"],
        ["bat"]
        """</span>
        res = []
        d = {}
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(strs)):
            tmp = tuple(sorted(strs[i]))
            <span class="hljs-keyword">if</span> tmp <span class="hljs-keyword">in</span> d:
                d[tmp] = d[tmp]+[i]
            <span class="hljs-keyword">else</span>:
                d[tmp] = [i]
        <span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> d:
            tmp = []
            <span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> d[key]:
                tmp.append(strs[value])
            res.append(tmp)
        <span class="hljs-keyword">return</span> res
</code></pre><h5 id="24-swap-nodes-in-pairs"><a name="24-swap-nodes-in-pairs" href="#24-swap-nodes-in-pairs"></a>24 swap nodes in pairs</h5><p>交换list里的每两个元素,要求是交换节点而不是节点的值.<br>思路的话交换两个节点的操作,需要一个prehead以避免头节点无指针,需要判断遍历到的节点是否为None以及下一个是否为None这样.最后还要记得保存下头节点(或者是交换后的头节点)</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;># Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution(object):
    def swapPairs(self, head):
        &quot;&quot;&quot;
        :type head: ListNode
        :rtype: ListNode
        &quot;&quot;&quot;
        if head==None:
            return head
        prehead = ListNode(0)
        prehead.next = head
        first = True
        bak = head
        while head!=None and head.next !=None:
            nextone = head.next
            head.next = nextone.next
            nextone.next = head
            prehead.next = nextone
            prehead = head
            head = head.next
            if first:
                bak = nextone
                first = False
        return bak
</code></pre>"><span class="hljs-comment"># Definition for singly-linked list.</span>
<span class="hljs-comment"># class ListNode(object):</span>
<span class="hljs-comment">#     def __init__(self, x):</span>
<span class="hljs-comment">#         self.val = x</span>
<span class="hljs-comment">#         self.next = None</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">swapPairs</span><span class="hljs-params">(self, head)</span>:</span>
        <span class="hljs-string">"""
        :type head: ListNode
        :rtype: ListNode
        """</span>
        <span class="hljs-keyword">if</span> head==<span class="hljs-keyword">None</span>:
            <span class="hljs-keyword">return</span> head
        prehead = ListNode(<span class="hljs-number">0</span>)
        prehead.next = head
        first = <span class="hljs-keyword">True</span>
        bak = head
        <span class="hljs-keyword">while</span> head!=<span class="hljs-keyword">None</span> <span class="hljs-keyword">and</span> head.next !=<span class="hljs-keyword">None</span>:
            nextone = head.next
            head.next = nextone.next
            nextone.next = head
            prehead.next = nextone
            prehead = head
            head = head.next
            <span class="hljs-keyword">if</span> first:
                bak = nextone
                first = <span class="hljs-keyword">False</span>
        <span class="hljs-keyword">return</span> bak
</code></pre><h5 id="319-bulb-switcher"><a name="319-bulb-switcher" href="#319-bulb-switcher"></a>319 Bulb Switcher</h5><p>给定一个n,表示有n个灯,然后第一次挨个按一下,第二次每两个按一下,第三次每三个按一下(不是圈,每次都从第一个开始数数,数到第n个后按下这样),最初是off,问最后有多少on.<br>很容易想到按下奇数次的是on,那么哪些数会被按下奇数次呢,首先可以确定的是每个位置被按下的次数是该数字的约数的个数,那么就容易知道被按下奇数次的那些是完全平方数.因为非完全平方数约数都是一一对应必定是偶数个的.</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>class Solution(object):
    def bulbSwitch(self, n):
        &quot;&quot;&quot;
        :type n: int
        :rtype: int
        &quot;&quot;&quot;
        count = 0
        inx = 1
        while inx*inx&amp;lt;=n:
            count = count + 1
            inx = inx + 1
        return count
</code></pre>"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bulbSwitch</span><span class="hljs-params">(self, n)</span>:</span>
        <span class="hljs-string">"""
        :type n: int
        :rtype: int
        """</span>
        count = <span class="hljs-number">0</span>
        inx = <span class="hljs-number">1</span>
        <span class="hljs-keyword">while</span> inx*inx&lt;=n:
            count = count + <span class="hljs-number">1</span>
            inx = inx + <span class="hljs-number">1</span>
        <span class="hljs-keyword">return</span> count
</code></pre><h5 id="439-find-right-interval"><a name="439-find-right-interval" href="#439-find-right-interval"></a>439 find right interval</h5><p>给定一个数组,里面元素表明了一条线的起点和终点位置.需要求的是每条线的终点后离的最近的那条线(以起点计),如果没有的话则为-1.<br>首先需要将所有线的起点排序,因为题意说了起点不重复且起点一定小于终点,所以很多特殊情况不需要考虑.<br>而后对每个线的终点,在排好序的起点里二分查找其对应的位置,并返回,然后根据这个点的值去对应出该起点在原数组里对应的坐标即可.</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;># Definition for an interval.
# class Interval(object):
#     def __init__(self, s=0, e=0):
#         self.start = s
#         self.end = e

class Solution(object):
    def bs(self,nums,key):
        left = 0
        right = len(nums)
        while left+1&amp;lt;right:
            medium = (left+right)/2
            if nums[medium]&amp;lt;key:
                left = medium
            elif nums[medium]&amp;gt;key:
                right = medium
            else:
                return medium
        if right&amp;gt;=len(nums):
            right = -1
        return right
    def findRightInterval(self, intervals):
        &quot;&quot;&quot;
        :type intervals: List[Interval]
        :rtype: List[int]
        &quot;&quot;&quot;
        rrr = []
        start = [i.start for i in intervals]
        sortstart = sorted(start)
        sdict = {i:inx for inx,i in enumerate(start)}
        for i in intervals:
            end = i.end
            inx = self.bs(sortstart,end)
            if inx == -1:
                rrr.append(-1)
            else:
                rn = sortstart[inx]
                ri = sdict[rn]
                rrr.append(ri)
        return rrr
</code></pre>"><span class="hljs-comment"># Definition for an interval.</span>
<span class="hljs-comment"># class Interval(object):</span>
<span class="hljs-comment">#     def __init__(self, s=0, e=0):</span>
<span class="hljs-comment">#         self.start = s</span>
<span class="hljs-comment">#         self.end = e</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bs</span><span class="hljs-params">(self,nums,key)</span>:</span>
        left = <span class="hljs-number">0</span>
        right = len(nums)
        <span class="hljs-keyword">while</span> left+<span class="hljs-number">1</span>&lt;right:
            medium = (left+right)/<span class="hljs-number">2</span>
            <span class="hljs-keyword">if</span> nums[medium]&lt;key:
                left = medium
            <span class="hljs-keyword">elif</span> nums[medium]&gt;key:
                right = medium
            <span class="hljs-keyword">else</span>:
                <span class="hljs-keyword">return</span> medium
        <span class="hljs-keyword">if</span> right&gt;=len(nums):
            right = -<span class="hljs-number">1</span>
        <span class="hljs-keyword">return</span> right
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findRightInterval</span><span class="hljs-params">(self, intervals)</span>:</span>
        <span class="hljs-string">"""
        :type intervals: List[Interval]
        :rtype: List[int]
        """</span>
        rrr = []
        start = [i.start <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> intervals]
        sortstart = sorted(start)
        sdict = {i:inx <span class="hljs-keyword">for</span> inx,i <span class="hljs-keyword">in</span> enumerate(start)}
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> intervals:
            end = i.end
            inx = self.bs(sortstart,end)
            <span class="hljs-keyword">if</span> inx == -<span class="hljs-number">1</span>:
                rrr.append(-<span class="hljs-number">1</span>)
            <span class="hljs-keyword">else</span>:
                rn = sortstart[inx]
                ri = sdict[rn]
                rrr.append(ri)
        <span class="hljs-keyword">return</span> rrr
</code></pre><h5 id="645-set-mismatch"><a name="645-set-mismatch" href="#645-set-mismatch"></a>645 set mismatch</h5><p>一个从1到n的数组里有一个元素变成了另一个元素,导致了一个数字出现两次一个没出现,求出这两个.<br>遍历两次即可.</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>class Solution(object):
    def findErrorNums(self, nums):
        &quot;&quot;&quot;
        :type nums: List[int]
        :rtype: List[int]
        &quot;&quot;&quot;
        d = {}
        double = 0
        remove = 0
        for i in nums:
            if i in d:
                double = i
                #break
            else:
                d[i] = 1
        for i in range(1,len(nums)+1):
            if i not in d:
                remove = i
                break
        return [double,remove]
</code></pre>"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findErrorNums</span><span class="hljs-params">(self, nums)</span>:</span>
        <span class="hljs-string">"""
        :type nums: List[int]
        :rtype: List[int]
        """</span>
        d = {}
        double = <span class="hljs-number">0</span>
        remove = <span class="hljs-number">0</span>
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> nums:
            <span class="hljs-keyword">if</span> i <span class="hljs-keyword">in</span> d:
                double = i
                <span class="hljs-comment">#break</span>
            <span class="hljs-keyword">else</span>:
                d[i] = <span class="hljs-number">1</span>
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>,len(nums)+<span class="hljs-number">1</span>):
            <span class="hljs-keyword">if</span> i <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> d:
                remove = i
                <span class="hljs-keyword">break</span>
        <span class="hljs-keyword">return</span> [double,remove]
</code></pre><h5 id="27-remove-element"><a name="27-remove-element" href="#27-remove-element"></a>27 remove element</h5><p>原地删除数组特定元素,位置可以混乱.<br>直接将后面的元素复制过来即可.记录下删除了多少个就行.</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>class Solution(object):
    def removeElement(self, nums, val):
        &quot;&quot;&quot;
        :type nums: List[int]
        :type val: int
        :rtype: int
        &quot;&quot;&quot;
        end = len(nums)-1
        rem = 0
        i = 0
        while i&amp;lt;len(nums)-rem:
            if nums[i]==val:
                nums[i]=nums[end]
                end = end -1
                rem = rem + 1
            else:
                i = i + 1
        return len(nums)-rem
</code></pre>"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">removeElement</span><span class="hljs-params">(self, nums, val)</span>:</span>
        <span class="hljs-string">"""
        :type nums: List[int]
        :type val: int
        :rtype: int
        """</span>
        end = len(nums)-<span class="hljs-number">1</span>
        rem = <span class="hljs-number">0</span>
        i = <span class="hljs-number">0</span>
        <span class="hljs-keyword">while</span> i&lt;len(nums)-rem:
            <span class="hljs-keyword">if</span> nums[i]==val:
                nums[i]=nums[end]
                end = end -<span class="hljs-number">1</span>
                rem = rem + <span class="hljs-number">1</span>
            <span class="hljs-keyword">else</span>:
                i = i + <span class="hljs-number">1</span>
        <span class="hljs-keyword">return</span> len(nums)-rem
</code></pre><h5 id="152-maximum-product-subarray"><a name="152-maximum-product-subarray" href="#152-maximum-product-subarray"></a>152 maximum product subarray</h5><p>给定一个数组(含负数),求乘积最大的子序列的乘积值是多少.<br>显然是使用dp,但是和和最大的子序列还不一样,这里因为有负数,所以存在某些情况下最大的值乘以负数后变成最小的值而后被丢掉的情况.所以我们在dp时需要保持两个,一个是以当前结尾的最大乘积,一个是最小乘积,当碰到负数时,最小乘积和最大乘积就需要调换以使得乘完后仍然满足最大最小.然后以一个res记录最大值即可.<br>这里主要是要考虑到负数并且想到使用增加记录一个当前乘积最小值的情况去包含进这种情况.主要是负数乘积仍然有可能在后面碰到一个负数使得其值变的很大.而如果只碰到一个负数,那么保留最小值也可以准确的表达出在这个地方的最大值.</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>class Solution(object):
    def maxProduct(self, nums):
        &quot;&quot;&quot;
        :type nums: List[int]
        :rtype: int
        &quot;&quot;&quot;
        n = len(nums)
        imax = nums[0]
        imin = nums[0]
        r = nums[0]
        for i in range(1,n):
            if nums[i]&amp;lt;0:
                imax,imin = imin,imax
            imax = max(imax*nums[i],nums[i])
            imin = min(imin*nums[i],nums[i])
            r = max(r,imax)
        return r
</code></pre>"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maxProduct</span><span class="hljs-params">(self, nums)</span>:</span>
        <span class="hljs-string">"""
        :type nums: List[int]
        :rtype: int
        """</span>
        n = len(nums)
        imax = nums[<span class="hljs-number">0</span>]
        imin = nums[<span class="hljs-number">0</span>]
        r = nums[<span class="hljs-number">0</span>]
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>,n):
            <span class="hljs-keyword">if</span> nums[i]&lt;<span class="hljs-number">0</span>:
                imax,imin = imin,imax
            imax = max(imax*nums[i],nums[i])
            imin = min(imin*nums[i],nums[i])
            r = max(r,imax)
        <span class="hljs-keyword">return</span> r
</code></pre><h5 id="166-fraction-to-recurring-decimal"><a name="166-fraction-to-recurring-decimal" href="#166-fraction-to-recurring-decimal"></a>166 fraction to recurring decimal</h5><p>给定除数和被除数,求出商,要求循环小数的话循环节需要括号括起来<br>这个的难点在于寻找正确的循环节.总体的思路是存储下每个余数对应的小数结果的序号,从而再计算到相同的余数时能够正确的取出循环节.其中细节很多,需要多调试总结不同的思路和情况.</p><pre class="python hljs"><code class="python" data-origin="<pre><code class=&quot;python&quot;>class Solution(object):
    def fractionToDecimal(self, numerator, denominator):
        &quot;&quot;&quot;
        :type numerator: int
        :type denominator: int
        :rtype: str
        &quot;&quot;&quot;
        zs = ''
        f = False
        if numerator*denominator&amp;lt;0:
            f = True
        if numerator&amp;lt;0:
            numerator = -1*numerator
        if denominator&amp;lt;0:
            denominator = -1*denominator
        if numerator&amp;lt;denominator:
            zs = '0'
        else:
            zs = str(numerator/denominator)
        if f == True:
            zs = '-'+zs
        ys = numerator - (numerator/denominator*denominator)
        #print(ys)
        if ys == 0:
            return zs
        zs = zs+'.'
        xslist = ''
        hisys = {}
        #hisys[ys] = 0
        while ys!=0:
            if ys in hisys:
                #print(hisys,ys)
                #xunhuan start,end
                start = hisys[ys]
                end = len(xslist)
                xslist = xslist[0:start]+'('+xslist[start:]+')'
                break
            hisys[ys] = len(xslist)
            #print(hisys)
            ys = ys*10
            hisys[ys] = len(xslist)+1
            while ys&amp;lt;denominator:
                ys = ys * 10
                #xslist=xslist+'0'
                if ys in hisys:
                #print(hisys,ys)
                #xunhuan start,end
                    start = hisys[ys]
                    end = len(xslist)
                    xslist = xslist[0:start]+'('+xslist[start:]+')'
                    break
                xslist=xslist+'0'
                hisys[ys] = len(xslist)+1
            jg = ys/denominator
            #xslist=xslist+str(jg)
            #print(xslist)
            ys = ys-jg*denominator
            xslist=xslist+str(jg)
            if ys == 0:
                break
        return zs+xslist
</code></pre>"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fractionToDecimal</span><span class="hljs-params">(self, numerator, denominator)</span>:</span>
        <span class="hljs-string">"""
        :type numerator: int
        :type denominator: int
        :rtype: str
        """</span>
        zs = <span class="hljs-string">''</span>
        f = <span class="hljs-keyword">False</span>
        <span class="hljs-keyword">if</span> numerator*denominator&lt;<span class="hljs-number">0</span>:
            f = <span class="hljs-keyword">True</span>
        <span class="hljs-keyword">if</span> numerator&lt;<span class="hljs-number">0</span>:
            numerator = -<span class="hljs-number">1</span>*numerator
        <span class="hljs-keyword">if</span> denominator&lt;<span class="hljs-number">0</span>:
            denominator = -<span class="hljs-number">1</span>*denominator
        <span class="hljs-keyword">if</span> numerator&lt;denominator:
            zs = <span class="hljs-string">'0'</span>
        <span class="hljs-keyword">else</span>:
            zs = str(numerator/denominator)
        <span class="hljs-keyword">if</span> f == <span class="hljs-keyword">True</span>:
            zs = <span class="hljs-string">'-'</span>+zs
        ys = numerator - (numerator/denominator*denominator)
        <span class="hljs-comment">#print(ys)</span>
        <span class="hljs-keyword">if</span> ys == <span class="hljs-number">0</span>:
            <span class="hljs-keyword">return</span> zs
        zs = zs+<span class="hljs-string">'.'</span>
        xslist = <span class="hljs-string">''</span>
        hisys = {}
        <span class="hljs-comment">#hisys[ys] = 0</span>
        <span class="hljs-keyword">while</span> ys!=<span class="hljs-number">0</span>:
            <span class="hljs-keyword">if</span> ys <span class="hljs-keyword">in</span> hisys:
                <span class="hljs-comment">#print(hisys,ys)</span>
                <span class="hljs-comment">#xunhuan start,end</span>
                start = hisys[ys]
                end = len(xslist)
                xslist = xslist[<span class="hljs-number">0</span>:start]+<span class="hljs-string">'('</span>+xslist[start:]+<span class="hljs-string">')'</span>
                <span class="hljs-keyword">break</span>
            hisys[ys] = len(xslist)
            <span class="hljs-comment">#print(hisys)</span>
            ys = ys*<span class="hljs-number">10</span>
            hisys[ys] = len(xslist)+<span class="hljs-number">1</span>
            <span class="hljs-keyword">while</span> ys&lt;denominator:
                ys = ys * <span class="hljs-number">10</span>
                <span class="hljs-comment">#xslist=xslist+'0'</span>
                <span class="hljs-keyword">if</span> ys <span class="hljs-keyword">in</span> hisys:
                <span class="hljs-comment">#print(hisys,ys)</span>
                <span class="hljs-comment">#xunhuan start,end</span>
                    start = hisys[ys]
                    end = len(xslist)
                    xslist = xslist[<span class="hljs-number">0</span>:start]+<span class="hljs-string">'('</span>+xslist[start:]+<span class="hljs-string">')'</span>
                    <span class="hljs-keyword">break</span>
                xslist=xslist+<span class="hljs-string">'0'</span>
                hisys[ys] = len(xslist)+<span class="hljs-number">1</span>
            jg = ys/denominator
            <span class="hljs-comment">#xslist=xslist+str(jg)</span>
            <span class="hljs-comment">#print(xslist)</span>
            ys = ys-jg*denominator
            xslist=xslist+str(jg)
            <span class="hljs-keyword">if</span> ys == <span class="hljs-number">0</span>:
                <span class="hljs-keyword">break</span>
        <span class="hljs-keyword">return</span> zs+xslist
</code></pre>

<footer style="position:fixed; font-size:.8em; text-align:right; bottom:0px; margin-left:-25px; height:20px; width:100%;">generated by <a href="http://pad.haroopress.com" target="_blank">haroopad</a></footer>
</body>
</html>
